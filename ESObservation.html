<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>ES.ESObservation API documentation</title>
<meta name="description" content="Created on Tue Aug
3 23:40:06 2021 …" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ES.ESObservation</code></h1>
</header>
<section id="section-intro">
<p>Created on Tue Aug
3 23:40:06 2021</p>
<p>@author: Philippe@loco-labs.io</p>
<p>The <code><a title="ES.ESObservation" href="#ES.ESObservation">ES.ESObservation</a></code> module contains the main class
of Environmental Sensing : <code><a title="ES.ESObservation.Observation" href="#ES.ESObservation.Observation">Observation</a></code> class.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
&#34;&#34;&#34;
Created on Tue Aug  3 23:40:06 2021

@author: Philippe@loco-labs.io

The `ES.ESObservation` module contains the main class
of Environmental Sensing : `ES.ESObservation.Observation` class.
&#34;&#34;&#34;
from ESObs import ESSetDatation, ESSetLocation, ESSetProperty, ESSetResult
from ESElement import ESObject, isESObs, isESAtt, isUserAtt
from ESconstante import ES #, Es, identity
from ESValue import LocationValue, DatationValue, PropertyValue, \
    ResultValue, _gshape
from shapely.geometry import shape
import json, folium, struct, copy
import numpy as np
import xarray as xr
#import geopandas as gp
import matplotlib.pyplot as plt

class Observation(ESObject):
    &#34;&#34;&#34;
    An `ES.ESObservation.Observation` is made up of objects from the `ES.ESObs` class
     which each describe a dimension of this object.
    
    Attributes :
    -----------
        - complet : consistency between Result and Datation, Location, Property
        - score : Observation structure codification
        - option : option 
        - setLocation : shortcut to ESSetLocation (@property)
        - setDatation : shortcut to ESSetDatation (@property)
        - setProperty : shortcut to ESSetProperty (@property)
        - setResult   : shortcut to ESSetResult   (@property)
        - nValueObs   : lenght of ESObs
        - name : textual description (inherited from ESObject)
        - typeES : &#39;observation&#39; (inherited from ESElement)
        - classES : &#39;observation&#39; (inherited from ESElement)
        - metaType : &#39;ESObject&#39; (inherited from ESElement)
        - mAtt : namedValue dictionnary (inherited from ESElement)
        - userAtt : namedValue dictionnary (inherited from ESElement)
        - pComposant : list of ESObs (inherited from ESElement)
        - pContenant : empty list (inherited from ESElement)
        - parameter : namedValue dictionnary (inherited from ESElement)

    &#34;&#34;&#34;
    #def __init__(self, jso = {}, order = &#39;dlp&#39;):
    def __init__(self, *args, order = &#39;dlp&#39;, **kwargs):
        ESObject.__init__(self)
        self.option = ES.mOption.copy()
        &#39;&#39;&#39;Dictionnary with options. &#39;&#39;&#39;
        self.mAtt[ES.obs_reference] = 0
        &#39;&#39;&#39; Attribut décrivant une `Observation` de référence utilisée pour compléter l&#39;Observation actuelle.&#39;&#39;&#39;
        self.score = -1
        &#39;&#39;&#39; Integer : Number of ESValue for each ESObs. For example, 122 means one PropertyValue (1), 
        several LocationValue (2), several DatationValue (2).&#39;&#39;&#39;
        self.complet = False
        &#39;&#39;&#39; Boolean : True if the number of ResultValue is consistent with the number of 
        LocationValue, DatationValue and PropertyValue.&#39;&#39;&#39;
        self.mAtt[ES.obs_resultTime] = &#34;null&#34;
        self.classES = ES.obs_classES
        self.typeES = ES.obs_typeES
        self.mAtt[ES.type] = &#34;obsError&#34;
        self.mAtt[ES.obs_id] = &#34;null&#34;
        for arg in args :
            if type(arg) in (dict, str) : self._init(arg)
            else : self.addESObs(arg)
        for k in kwargs :
            if type(kwargs[k]) in (ESSetDatation, ESSetLocation, ESSetProperty, ESSetResult) :
                self.addComposant(kwargs[k])
            else : self.addESObs(kwargs[k], k)
        self.majType(order)
    
    def _init(self, jso) :
        &#39;&#39;&#39; attributes and ESObs creation &#39;&#39;&#39;
        if type(jso) == str :
            try:
                js=json.loads(jso)
            except:
                return
        elif type(jso) == dict :
            js = jso.copy()
        else : return
        if js == {}: return
        if type(jso) == str and (ES.type not in list(js) or js[ES.type] != ES.obs_classES): return
        if ES.obs_id in list(js): self.mAtt[ES.obs_id] = js[ES.obs_id]
        if ES.obs_attributes in list(js): 
            if type(js[ES.obs_attributes]) == dict: js = js[ES.obs_attributes]
            else: return
        self.addAttributes(js)
        self.addESObs(js)
    
    def addESObs(self, js, classES = None) :
        &#39;&#39;&#39;
        Add a new `ES.ESObs` attached to `ES.ESObservation.Observation`. 
        The ES.ESObs child class is defined by classES or if None by the js structure.

        Parameters
        ----------
        js : ES.ESObs compatible type
        classES : string, optional
            value of the ES.ESObs ESclass attributes. The default is None.
        Returns
        -------
        None.

        &#39;&#39;&#39;
        if classES in (None, ES.dat_classES) and isESObs(ES.dat_classES, js): 
            ESSetDatation(pObs=self, jObj=js)
        if classES in (None, ES.loc_classES) and isESObs(ES.loc_classES, js): 
            ESSetLocation(pObs=self, jObj=js)
        if classES in (None, ES.prp_classES) and isESObs(ES.prp_classES, js): 
            ESSetProperty(pObs=self, jObj=js)
        if classES in (None, ES.res_classES) and isESObs(ES.res_classES, js): 
            ESSetResult  (pObs=self, jObj=js)

    def addAttributes(self, js):
        &#39;&#39;&#39;
        Add informations attached to `ES.ESObservation.Observation`

        Parameters
        ----------
        js : Dictionnary
            Keys are Observation keys or users keys.
        Returns
        -------
        None
        &#39;&#39;&#39;
        if type(js) != dict: return
        for k, v in js.items():
            if isESAtt(ES.obs_classES, k) or isUserAtt(k): self.mAtt[k] = v
            if k == ES.parameter: 
                try:  self.parameter = json.dumps(v)
                except:  self.parameter = &#34;null&#34;

    @property
    def bounds(self):
        &#39;&#39;&#39;tuple : Observation boundingBox (xmin, ymin, xmax, ymax).&#39;&#39;&#39;
        if self.setLocation : return shape(self).bounds
        else : return None

    @property
    def __geo_interface__(self):
        &#39;&#39;&#39;dict : geometry (see shapely)&#39;&#39;&#39;
        if self.setLocation : 
            return _gshape(self.setLocation.jsonSet(self.option)).__geo_interface__
            #return gshape(self.setLocation.geoInterface(self.option)).__geo_interface__
            &#39;&#39;&#39;return gshape(json.dumps(json.loads(&#39;{&#39; \
                        #+ self.setLocation.json(False, False, False, False)\
                        + self.setLocation.geoInterface(self.option)\
                        #+ &#39;}&#39;)[&#34;coordinates&#34;])).__geo_interface__
                        + &#39;}&#39;)[ES.loc_valName[indice]])).__geo_interface__&#39;&#39;&#39;
        else : return &#34;&#34;

    @property
    def jsonFeature(self):
        &#39;&#39;&#39; string : &#34;FeatureCollection&#34; with geometry in the Observation&#39;&#39;&#39;
        if self.setLocation : 
            geo = self.__geo_interface__
            if geo[&#39;type&#39;] == &#34;MultiPolygon&#34;: typ = &#34;Polygon&#34;
            else : typ = &#34;Point&#34;
            lis = list(dict(((&#34;type&#34;, typ), (&#34;coordinates&#34;, geo[&#39;coordinates&#39;][i]))) for i in range(len(geo[&#39;coordinates&#39;])))
            fea = list(dict(((&#34;type&#34;,&#34;Feature&#34;), (&#34;id&#34;, i), (&#34;geometry&#34;, lis[i]))) for i in range(len(geo[&#39;coordinates&#39;])))
            return json.dumps(dict(((&#34;type&#34;,&#34;FeatureCollection&#34;), (&#34;features&#34;,fea))))            
        else: return &#39;&#39;  
            
    @property
    def setLocation(self):
        &#39;&#39;&#39;object `ES.ESObs.ESSetLocation` if exists, None otherwise.&#39;&#39;&#39;
        return self.element(ES.loc_classES)
    @property
    def setDatation(self):  
        &#39;&#39;&#39;object `ES.ESObs.ESSetDatation` if exists, None otherwise.&#39;&#39;&#39;
        return self.element(ES.dat_classES)
    
    @property
    def setProperty(self):  
        &#39;&#39;&#39;object `ES.ESObs.ESSetProperty` if exists, None otherwise.&#39;&#39;&#39;
        return self.element(ES.prp_classES)
    
    @property
    def setResult(self):  
        &#39;&#39;&#39;object `ES.ESObs.ESSetResult` if exists, None otherwise.&#39;&#39;&#39;
        return self.element(ES.res_classES)

    def __copy__(self):
        return copy.deepcopy(self)
        &#39;&#39;&#39;opt = self.option
        self.option[&#34;json_obs_val&#34;] = True
        cop = Observation(self.json())
        self.option = opt
        cop.option = opt
        return cop&#39;&#39;&#39;

    def __iadd__(self, other):
        &#39;&#39;&#39; Add other&#39;s values to self&#39;s values&#39;&#39;&#39;
        other_opt = other.option
        self_opt = self.option
        ndat = nloc = nprp = 0
        idat = 0; iloc = 1; iprp = 2
        other.option[&#34;maj_index&#34;] = True
        other.majType()
        self.option[&#34;maj_index&#34;] = True
        self.majType()
        if other.setResult != None and other.setResult.getMaxIndex() &gt; -1:
            for resVal in other.setResult.valueList:
                ndat = self.addValue(other.setDatation.valueList[resVal.ind[idat]])
                nloc = self.addValue(other.setLocation.valueList[resVal.ind[iloc]])
                nprp = self.addValue(other.setProperty.valueList[resVal.ind[iprp]])
                resv = ResultValue(resVal.value)
                resv.ind = [ndat, nloc, nprp]
                self.addResultValue(resv)
            self.majType()
        other.option = other_opt
        self.option = self_opt
        return self
    
    def __add__(self, other):
        &#39;&#39;&#39; Add other&#39;s values to self&#39;s values in a new Observation&#39;&#39;&#39;
        obres = self.__copy__()
        obres.__iadd__(other)
        return obres
    
    def extend(self, obs):
        &#39;&#39;&#39;
        Copy `ES.ESObs` from obs to self (if it daesn&#39;t exist)

        Parameters
        ----------
        obs : object ES.ESObservation.Observation to copy
        Returns
        -------
        None.
        &#39;&#39;&#39;
        for p in obs.pComposant :
            if self.element(p.classES) == None : self.addComposant(p)
        self.majType()    
        
    def addResultValue(self, esValue):
        &#39;&#39;&#39;
        Add a new `ES.ESValue.ResultValue` in the `ES.ESObs.ESSetResult`

        Parameters
        ----------
        esValue : ES.ESValue.ResultValue
        Returns
        -------
        Int : last index in the `ES.ESValue.ESSet` valueList.
        &#39;&#39;&#39;
        return self.element(ES.res_valueType).addValue(ResultValue, esValue)
    
    def addValue(self, esValue):
        &#39;&#39;&#39;
        Add a new `ES.ESValue` in the `ES.ESValue.ESSet`

        Parameters
        ----------
        esValue : ES.ESValue
        Returns
        -------
        Int : last index in the `ES.ESValue.ESSet` valueList.
        &#39;&#39;&#39;
        if type(esValue)== PropertyValue:
            if self.element(ES.prp_valueType) == None: ESSetProperty(pObs=self)
            return self.element(ES.prp_valueType).addValue(PropertyValue, esValue)
        elif type(esValue)== LocationValue:
            if self.element(ES.loc_valueType) == None: ESSetLocation(pObs=self)
            return self.element(ES.loc_valueType).addValue(LocationValue, esValue)
        elif type(esValue)== DatationValue:
            if self.element(ES.dat_valueType) == None: ESSetDatation(pObs=self)
            return self.element(ES.dat_valueType).addValue(DatationValue, esValue)
        else: return 0

    def addListResultValue(self, listEsValue):
        &#39;&#39;&#39;
        Add a list of new `ES.ESValue.ResultValue` in the `ES.ESObs.ESSetResult`.

        Parameters
        ----------
        listEsValue : list of `ES.ESValue.ResultValue`
        Returns
        -------
        None
        &#39;&#39;&#39;
        if type(listEsValue) != list : return
        if self.element(ES.res_valueType) == None: resSet = ESSetResult(pObs=self)
        else: resSet = self.setResult
        for val in listEsValue : resSet.addValue(ResultValue, ResultValue(val))
            #self.addResultValue(ResultValue(val) )

    def majList(self, ValueClass, listVal, info = &#39;name&#39;):
        &#39;&#39;&#39;
        Modify a list of one attribute (name or value) in an `ES.ESObs`

        Parameters
        ----------
        ValueClass : class ES.ESObs 
        listVal : list of values
        info : string, optional, 
            Attribute. The default is &#39;name&#39;. 
        Returns
        -------
        None
        &#39;&#39;&#39;
        if ValueClass == DatationValue and self.setDatation != None : 
            if info == &#39;name&#39;: self.setDatation.majListName(listVal)
            else : self.setDatation.majListValue(ValueClass, listVal, info == &#39;base&#39;)
        elif ValueClass == LocationValue and self.setLocation != None : 
            if info == &#39;name&#39;: self.setLocation.majListName(listVal)
            else : self.setLocation.majListValue(ValueClass, listVal, info == &#39;base&#39;)
        elif ValueClass == PropertyValue and self.setProperty != None : 
            if info == &#39;name&#39;: self.setProperty.majListName(listVal)

    def addListValue(self, ValueClass, listEsValue):
        &#39;&#39;&#39;
        Add a list of new `ES.ESValue` in a `ES.ESValue.ESSet`.

        Parameters
        ----------
        ValueClass : name of the selected class ES.ESValue
        listEsValue : list of ES.ESValue
        Returns
        -------
        None
        &#39;&#39;&#39;
        for val in listEsValue : self.addValue(ValueClass(val) )
        
    def addValueObservation(self, val, idat, iloc, iprp):
        &#39;&#39;&#39;
        Add a new `ES.ESValue.ResultValue` 
        
        Parameters
        ----------
        val : ES.ESValue.ResultValue compatible type
        idat, iloc, iprp : integer, ES.ESValue.ESIndexValue
        Returns
        -------
        Int : last index in the `ES.ESValue.ESSet` valueList.
        &#39;&#39;&#39;
        if self.element(ES.res_valueType) == None: ESSetResult(pObs=self)
        return self.addResultValue(ResultValue(val, [idat, iloc, iprp]))

    def addListValueObservation(self, listVal, listIdat, listIloc, listIprp):
        &#39;&#39;&#39;
        Add a list of new `ES.ESValue.ResultValue` 
        
        Parameters
        ----------
        listVal : list of ES.ESValue.ResultValue compatible type
        listIdat, listIloc, listIprp : list of integer in ES.ESValue.ESIndexValue
        Returns
        -------
        None
        &#39;&#39;&#39;
        if len(listVal)==len(listIdat)==len(listIloc)==len(listIprp) :
            for i in range(len(listVal)) :
                self.addResultValue(ResultValue(listVal[i], [listIdat[i], listIloc[i], listIprp[i]]))

    def addValueSensor(self, resVal, datVal, locVal, nprp):
        &#39;&#39;&#39;
        Add `ES.ESValue.ResultValue`,  `ES.ESValue.DatationValue`,  `ES.ESValue.LocationValue`
        for a defined property.

        Parameters
        ----------
        resVal : ES.ESValue.ResultValue compatible type, 
        datVal : ES.ESValue.DatationValue compatible type
        locVal : ES.ESValue.LocationValue compatible type
        nprp : integer, index of the ES.ESValue.PropertyValue
        Returns
        -------
        Int : last index in the `ES.ESValue.ESSet` valueList.

        &#39;&#39;&#39;
        return self.addValueObservation(resVal, self.addValue(DatationValue(datVal)), 
                                        self.addValue(LocationValue(locVal)), nprp)

    def json(self): 
        &#39;&#39;&#39;
        Export in Json format. 
        
        Returns
        -------
        string : Json string 

        &#39;&#39;&#39;
        if self.option[&#34;json_elt_type&#34;]: option_type = 1
        else: option_type = 0
        js =&#34;&#34;
        if self.option[&#34;json_obs_val&#34;]: js = &#34;{&#34;
        js += &#39;&#34;&#39; + ES.type +&#39;&#34;:&#34;&#39; + ES.obs_classES +&#39;&#34;,&#39;
        if self.mAtt[ES.obs_id] != &#34;null&#34;: js += &#39;&#34;&#39; + ES.obs_id + &#39;&#34;:&#34;&#39; + self.mAtt[ES.obs_id] + &#39;&#34;,&#39;
        if self.option[&#34;json_obs_attrib&#34;]: js += &#39;&#34;&#39; + ES.obs_attributes + &#39;&#34;:{&#39;
        js += self._jsonAtt(option_type)
        for cp in self.pComposant:
            js += cp.json(self.option)
            if js[-1] != &#39;,&#39;: js += &#34;,&#34;
        if self.option[&#34;json_param&#34;] and self.parameter != &#34;null&#34;: 
            js += &#39;&#34;&#39; + ES.parameter +&#39;&#34;:&#39; + self.parameter + &#39;,&#39;
        jsInfo = self._jsonInfo(self.option[&#34;json_info_type&#34;], self.option[&#34;json_info_nval&#34;],
                            self.option[&#34;json_info_box&#34;], self.option[&#34;json_info_autre&#34;])
        if jsInfo != &#34;&#34; : js +=  jsInfo + &#39;,&#39;
        if js[-1] == &#39;,&#39;: js = js[:-1]
        if self.option[&#34;json_obs_attrib&#34;]: js += &#34;}&#34;
        if self.option[&#34;json_obs_val&#34;]:    js += &#34;}&#34;
        return js
    
    def to_bytes(self):
        &#39;&#39;&#39;
        Export in binary format. 
        
        Returns
        -------
        bytes : binary representation of the ES.ESObservation.Observation

        &#39;&#39;&#39;
        byt = bytes()
        code_el = ES.codeb[self.classES] 
        byt += struct.pack(&#39;&lt;B&#39;, (code_el &lt;&lt; 5) | self.mAtt[ES.obs_reference])
        if self.setProperty != None: 
            byt += self.setProperty.to_bytes(self.option[&#34;json_prp_name&#34;])
        if self.setLocation != None: 
            byt += self.setLocation.to_bytes(self.option[&#34;json_loc_name&#34;])
        if self.setDatation != None: 
            byt += self.setDatation.to_bytes(self.option[&#34;json_dat_name&#34;])
        if self.setResult != None: 
            propList = [self.setProperty.valueList[i].pType 
                        for i in range(self.setProperty.nValue)]
            byt += self.setResult.to_bytes(False, self.option[&#34;json_res_index&#34;], 
                                           self.option[&#34;bytes_res_format&#34;], propList)
        return byt
        
    def from_bytes(self, byt):
        &#39;&#39;&#39;
        Complete an empty `ES.ESObservation.Observation` with binary data. 
        
        Parameters
        -------
        byt : binary representation of an ES.ESObservation.Observation
        Returns
        -------
        None
        &#39;&#39;&#39;
        code_ob = (byt[0] &amp; 0b11100000) &gt;&gt; 5
        self.mAtt[ES.obs_reference] = byt[0] &amp; 0b00011111
        if code_ob != ES.codeb[self.classES]: return
        idx = 1
        while idx &lt; byt.__len__() :
            code_el = (byt[idx] &amp; 0b11100000) &gt;&gt; 5
            #forma =  byt[idx] &amp; 0b00001111
            if   code_el == 1: es = ESSetLocation(pObs=self)
            elif code_el == 2: es = ESSetDatation(pObs=self)
            elif code_el == 3: es = ESSetProperty(pObs=self)
            elif code_el &lt; 6:
                es = ESSetResult(pObs=self)
                if code_el == 5: 
                    propList = [self.setProperty.valueList[i].pType 
                            for i in range(self.setProperty.nValue)]
                else :
                    es.from_bytes(byt[idx:], [])
                    es.majIndex(es.nValue, self.setProperty.nValue, 
                            self.setDatation.nValue, self.setLocation.nValue)
                    propList = [self.setProperty.valueList[es.valueList[i].ind[2]].pType
                            for i in range(es.nValue)]
                    es.__init__()
            else: return
            if code_el &lt; 4 : 
                idx += es.from_bytes(byt[idx:])
            else :
                idx += es.from_bytes(byt[idx:], propList)
    
    def _jsonInfoTypes(self, dcinf):
        &#39;&#39;&#39; Add information&#39;s key-value to dict dcinf&#39;&#39;&#39;
        dcinf[ES.json_type_obs] = self.mAtt[ES.type]
        if self.setLocation != None :
            if self.setLocation.nValue &gt; 1 : 
                dcinf[ES.json_type_loc] = ES.multi + self.setLocation.mAtt[ES.type]
            else :
                dcinf[ES.json_type_loc] = self.setLocation.mAtt[ES.type]
        if self.setDatation != None :
            if self.setDatation.nValue &gt; 1 : 
                dcinf[ES.json_type_dat] = ES.multi + self.setDatation.mAtt[ES.type]
            else :
                dcinf[ES.json_type_dat] = self.setDatation.mAtt[ES.type]
        if self.setProperty != None :
            if self.setProperty.nValue &gt; 1 : 
                dcinf[ES.json_type_prp] = ES.multi + self.setProperty.mAtt[ES.type]
            else :
                dcinf[ES.json_type_prp] = self.setProperty.mAtt[ES.type]
        if self.setResult != None :
            if self.setResult.nValue &gt; 1 : 
                dcinf[ES.json_type_res] = ES.multi + self.setResult.mAtt[ES.type]
            else :
                dcinf[ES.json_type_res] = self.setResult.mAtt[ES.type]

    def _jsonInfoNval(self, dcinf):
        &#39;&#39;&#39; Add valueList lenght to dict dcinf&#39;&#39;&#39;
        if self.setLocation != None : dcinf[ES.json_nval_loc] = self.setLocation.nValue
        if self.setDatation != None : dcinf[ES.json_nval_dat] = self.setDatation.nValue
        if self.setProperty != None : dcinf[ES.json_nval_prp] = self.setProperty.nValue
        if self.setResult   != None : dcinf[ES.json_nval_res] = self.setResult.nValue

    def _jsonInfoBox(self, dcinf):
        &#39;&#39;&#39; Add box informations&#39;s key-value to dict dcinf&#39;&#39;&#39;
        if self.setLocation != None :
            dcinf[ES.loc_boxMin] = self.setLocation.boxMin.point
            dcinf[ES.loc_boxMax] = self.setLocation.boxMax.point
        if self.setDatation != None :
            dcinf[ES.dat_boxMin] = self.setDatation.boxMin.json(ES.mOption)
            dcinf[ES.dat_boxMax] = self.setDatation.boxMax.json(ES.mOption)

    def _jsonInfoAutre(self, dcinf):
        &#39;&#39;&#39; Add other&#39;s information key-value to dict dcinf&#39;&#39;&#39;
        dcinf[ES.obs_complet] = self.complet
        dcinf[ES.obs_score] = self.score
        if self.setResult != None :
            dcinf[ES.res_mRate] = self.setResult.measureRate
            dcinf[ES.res_dim] = self.setResult.dim
            dcinf[ES.res_axes] = self.setResult.axes

    def _jsonInfo(self, types, nval, box, autre):
        &#39;&#39;&#39; Create json string with dict datas&#39;&#39;&#39;
        dcinf = dict()
        if types :  self._jsonInfoTypes(dcinf)
        if nval :   self._jsonInfoNval(dcinf)
        if box :    self._jsonInfoBox(dcinf)
        if autre:   self._jsonInfoAutre(dcinf)
        ldel =[]
        for k,v in dcinf.items() :
            if type(v) == str and (v == &#34;null&#34; or v ==&#39;&#39;)   : ldel.append(k)
            if type(v) == list and v == ES.nullCoor         : ldel.append(k) 
        for k in ldel :         del dcinf[k]
        if len(dcinf) == 0 :    return &#34;&#34;
        else :                  return &#39;&#34;&#39; +ES.information + &#39;&#34;:&#39; + json.dumps(dcinf)

    @property 
    def nValueObs(self):
        &#39;&#39;&#39;list : lenght of `ES.ESObs.ESSetProperty`, `ES.ESObs.ESSetDatation`, 
                `ES.ESObs.ESSetLocation`, `ES.ESObs.ESSetResult`.&#39;&#39;&#39;
        nPrp = nDat = nLoc = nRes = 0
        if self.setResult   != None: nRes = self.setResult.nValue
        if self.setLocation != None: nLoc = self.setLocation.nValue
        if self.setDatation != None: nDat = self.setDatation.nValue
        if self.setProperty != None: nPrp = self.setProperty.nValue
        return [nPrp, nDat, nLoc, nRes]

    def iloc(self, idat, iloc, iprp):
        &#39;&#39;&#39;
        Return the `ES.ESValue` values for an `ES.ESValue.ESIndexValue`. 

        Parameters
        ----------
        idat, iloc, iprp : ES.ESValue.ESIndexValue

        Returns
        -------
        dictionnary, ES.ESValue of each ES.ESObs
        &#39;&#39;&#39;
        if not self.complet : return dict()
        dic = dict()
        if self.setDatation != None and idat &lt; self.setDatation.nValue: 
            dic[ES.dat_classES] = self.setDatation.valueList[idat].json(self.option)
        if self.setLocation != None and iloc &lt; self.setLocation.nValue: 
            dic[ES.loc_classES] = self.setLocation.valueList[iloc].json(self.option)
        if self.setProperty != None and iprp &lt; self.setProperty.nValue: 
            dic[ES.prp_classES] = self.setProperty.valueList[iprp].json(self.option)
        if self.setResult != None : 
            for i in range(self.setResult.nValue) : 
                if self.setResult.valueList[i].ind == [idat, iloc, iprp] : 
                    dic[ES.res_classES] = self.setResult.valueList[i].json(self.option)
        return dic
    
    def _typeObs(self):
        [nPrp, nDat, nLoc, nRes] = self.nValueObs
        self.score = min(max(min(nPrp, 2) * 100 + min(nLoc,2) * 10 + min(nDat, 2), -1), 229);
        if self.setResult == None or (self.setResult.error or self.setResult.getMaxIndex() == -1 or \
           self.setResult.nInd[0] &gt; nDat or self.setResult.nInd[1] &gt; nLoc or self.setResult.nInd[2] &gt; nPrp):
               self.mAtt[ES.type] = &#34;obserror&#34;
               return
        if self.score == 22  and self.setResult.dim == 2:       self.score = 23
        if self.score == 122 and self.setResult.dim == 2:       self.score = 123
        if self.score == 202 and self.setResult.dim == 2:       self.score = 203
        if self.score == 212 and self.setResult.dim == 2:       self.score = 213
        if self.score == 220 and self.setResult.dim == 2:       self.score = 223
        if self.score == 221 and self.setResult.dim == 2:       self.score = 224
        if self.score == 222 and self.setResult.dim == 3:       self.score = 228
        if self.score == 222 and self.setResult.dim == 2 and 2 in self.setResult.axes:  self.score = 225
        if self.score == 222 and self.setResult.dim == 2 and 1 in self.setResult.axes:  self.score = 226
        if self.score == 222 and self.setResult.dim == 2 and 0 in self.setResult.axes:  self.score = 227
        self.mAtt[ES.type] = ES.obsCat[self.score]

    @staticmethod
    def _sortAlign(npInd, list1, ind1, ind2):
        return [int(npInd[list(npInd[:,ind1]).index(i),:][ind2])  for i in list1]    
    
    def full(self, maj=True) : 
        &#39;&#39;&#39;
        Add empty `ES.ESValue.ResultValue` to have a &#39;complete&#39; `ES.ESObservation.Observation`

        Parameters
        ----------
        maj : boolean, optional
            If True, add value to Observation, else return listValue. The default is True.
        Returns
        -------
        empty list if maj is True, else `ES.ESObs.ESSetResult` listValue.
        &#39;&#39;&#39;
        return self.setResult.full(maj)
    
    def sort(self, order = &#39;dlp&#39;, cross = True, sort = [[], [], []]): 
        &#39;&#39;&#39;
        Modify the order of `ES.ESValue`.

        Parameters
        ----------
        order : string, optional
            Ordered list to follow (d:dat, l:loc, p:prp). The default is &#39;dlp&#39;.
        cross : boolean, optional
            If True, synchronize the order to have a less dimension. The default is True.
        sort : list, optional
            If empty, order is follow, if not sorting follows the list provided. The default is empty [[], [], []].
        Returns
        -------
        None.
        &#39;&#39;&#39;
        if self.setResult == None or not self.setResult.isIndex() : return
        tr = tri = [[], [], []]
        orde = [ES.nax[order[0]], ES.nax[order[1]], ES.nax[order[2]]]
        # ordre de tri de chacun des axes
        for i in range(3) : tri[i] = self._sortSet(i, sort[i], False)
        npInd = np.array(self.setResult.vListIndex)
        if cross:
            for ax in self.setResult.axes : 
                if ax &gt; 100 : 
                    tri[orde[1]] = self._sortAlign(npInd, tri[orde[0]], orde[0], orde[1])
                    tri[orde[2]] = self._sortAlign(npInd, tri[orde[0]], orde[0], orde[2])
                elif ax &gt; 9 :
                    (first, second) = (ax//10, ax%10)
                    if orde.index(second) &lt; orde.index(first) : (first, second) = (second, first)
                    tri[second] = self._sortAlign(npInd, tri[first], first, second)
        for i in range(3) : tr[i] = self._sortSet(i, tri[i])
        for resVal in self.setResult.valueList :
            for i in range(3) : resVal.ind[i] = tr[i].index(resVal.ind[i])
        self.setResult.sort()
    
    def _sortSet(self, ax, tri = [], update = True):
        if ax == 0 and self.setDatation != None : return self.setDatation.sort(tri, update)
        if ax == 1 and self.setLocation != None : return self.setLocation.sort(tri, update)
        if ax == 2 and self.setProperty != None : return self.setProperty.sort(tri, update)
        return [0]
    
    def majType(self, order = &#39;dlp&#39;):
        &#39;&#39;&#39;
        Generate the `ES.ESObservation.Observation` and associates `ES.ESObs` 
        characteristics (e.g. complet, score, dim...) and the index for `ES.ESValue.ResultValue` data.
        
        Parameters
        ----------
        order : String, optional
            Result ordering for result without index. The order is define with
            three letters : l (location), d (datation), p (property). The default is &#39;dlp&#39;.
        Returns
        -------
        None.
        &#39;&#39;&#39;
        [nprp, ndat, nloc, nRes] = self.nValueObs
        nPrp = max(1, nprp)
        nDat = max(1, ndat)
        nLoc = max(1, nloc)
        if len(order) == 3 : 
            self.complet = nRes == nLoc * nDat * nPrp \
                        or nRes == nDat * nPrp == nDat * nLoc \
                        or nRes == nLoc * nPrp == nLoc * nDat \
                        or nRes == nPrp * nLoc == nPrp * nDat \
                        or nRes == nLoc == nDat == nPrp
        if len(order) == 2 : 
            self.complet = nRes == nDat * nPrp == nDat * nLoc \
                        or nRes == nLoc * nPrp == nLoc * nDat \
                        or nRes == nPrp * nLoc == nPrp * nDat \
                        or nRes == nLoc == nDat == nPrp
        if len(order) == 1 : 
            self.complet = nRes == nLoc == nDat == nPrp
        
        if self.complet: self.setResult.majIndex(nRes, nPrp, nDat, nLoc, order)
        if self.setResult   != None: self.setResult.  analyse()
        if self.setLocation != None: self.setLocation.analyse()
        if self.setDatation != None: self.setDatation.analyse()
        self._typeObs()

    def _xlist(self):
        xList = {}
        if self.setLocation != None: 
            xList[&#39;loc&#39;]    = self.setLocation.to_numpy()
            xList[&#39;locstr&#39;] = self.setLocation.to_numpy(func = LocationValue.json)
            xList[&#39;loclon&#39;] = self.setLocation.to_numpy(func = LocationValue.vPointX)
            xList[&#39;loclat&#39;] = self.setLocation.to_numpy(func = LocationValue.vPointY)
            xList[&#39;locnam&#39;] = self.setLocation.to_numpy(func = LocationValue.vName)
            xList[&#39;locran&#39;] = np.arange(len(xList[&#39;loc&#39;]))
        if self.setDatation != None: 
            xList[&#39;dat&#39;]    = self.setDatation.to_numpy()
            xList[&#39;datstr&#39;] = self.setDatation.to_numpy(func = DatationValue.json)
            xList[&#39;datnam&#39;] = self.setDatation.to_numpy(func = DatationValue.vName)
            xList[&#39;datran&#39;] = np.arange(len(xList[&#39;dat&#39;]))
        if self.setProperty != None: 
            xList[&#39;prp&#39;]    = self.setProperty.to_numpy()
            xList[&#39;prpstr&#39;] = self.setProperty.to_numpy(func = PropertyValue.json)
            xList[&#39;prpnam&#39;] = self.setProperty.to_numpy(func = PropertyValue.vName)
            xList[&#39;prpran&#39;] = np.arange(len(xList[&#39;prp&#39;]))
        if self.setResult  != None: 
            xList[&#39;res&#39;]    = self.setResult.to_numpy()
            xList[&#39;resval&#39;] = self.setResult.to_numpy(func = ResultValue.to_float)
            xList[&#39;resstr&#39;] = self.setResult.to_numpy(func = ResultValue.json)
            xList[&#39;resnam&#39;] = self.setResult.to_numpy(func = ResultValue.vName)
            xList[&#39;resran&#39;] = np.arange(len(xList[&#39;res&#39;]))
        return xList

    def _xAttrs(self) :
        attrs = ES.xattrs
        attrs[&#39;info&#39;]   = json.loads(&#34;{&#34; + self._jsonInfo(True, False, True, False) + &#34;}&#34;)[&#34;information&#34;]
        return attrs

    def _axeCoor(self, nValAxe) :
        for ax in self.setResult.axes :
            if ax &gt; 100 : return ax
            if ax &lt; 9 and nValAxe == ax : return ax
            elif ax &gt; 9 and (nValAxe == ax//10 or nValAxe == ax%10) : return ax
        return None
    
    def _xCoord(self, xList, attrs, dataArray, complet, numeric) :
        #nax = {&#39;dat&#39; : 0, &#39;loc&#39; : 1, &#39;prp&#39; : 2}
        coord = {}
        for key, val in xList.items() :
            if key[:3] != &#39;res&#39; and self._axeCoor(ES.nax[key[:3]]) != None \
                and (complet or (not complet and len(key) == 3)):
                coord[key] = ([ES.axes[self._axeCoor(ES.nax[key[:3]])]], val, attrs[key[:3]])
                if key == &#39;loclon&#39; : coord[key] = (coord[key][0], val, attrs[&#39;lon&#39;])
                if key == &#39;loclat&#39; : coord[key] = (coord[key][0], val, attrs[&#39;lat&#39;])
        for ax in self.setResult.axes :
            if ax &gt; 9 :
                le = len(xList[ES.axes[ax%10]])
                coord[ES.axes[ax]] = ([ES.axes[ax]], np.arange(le))
                if ax &gt; 100 : lis = [str(xList[&#39;datstr&#39;][i]) + xList[&#39;locstr&#39;][i] + 
                                     xList[&#39;prpstr&#39;][i] for i in range(le)]
                else : lis = [str(xList[ES.axes[ax%10]+&#39;str&#39;][i]) + 
                              str(xList[ES.axes[ax//10]+&#39;str&#39;][i]) for i in range(le)]
                coord[ES.axes[ax]+&#39;str&#39;] = ([ES.axes[ax]], lis)
        if numeric :
            if &#39;loc&#39; in coord.keys() : coord[&#39;loc&#39;] = (coord[&#39;loc&#39;][0], xList[&#39;locran&#39;], coord[&#39;loc&#39;][2])
            if &#39;dat&#39; in coord.keys() : coord[&#39;dat&#39;] = (coord[&#39;dat&#39;][0], xList[&#39;datstr&#39;], coord[&#39;dat&#39;][2])
            if &#39;prp&#39; in coord.keys() : coord[&#39;prp&#39;] = (coord[&#39;prp&#39;][0], xList[&#39;prpran&#39;], coord[&#39;prp&#39;][2])
        return coord
    

    def to_xarray(self, dataArray = True, sort = True, complet = False, info = False, numeric = False):
        &#39;&#39;&#39;
        Convert `ES.ESObservation.Observation` to DataArray or DataSet with the smallest dimension. 
        
        Parameters
        ----------
        dataArray : Boolean, optional
            DataArray ou DataSet. The default is True.
        sort : Boolean, optional
            Sort along an axis. The default is True.
        complet : Boolean, optional
            Generate all the DataArray.Coords or only one. The default is False.
        info : Boolean, optional
            Generate a specific Coords with Observation characteristics. The default is False.
        numeric : Boolean, optional
            Generate a numeric DataArray.Values. The default is False.
        Returns
        -------
        xarray.DataArray or xarray.DataSet.
        &#39;&#39;&#39;
        if self.setResult.getMaxIndex() == -1 : return None
        if sort : self.sort()
        xList = self._xlist()
        attrs = self._xAttrs()
        coord = self._xCoord(xList, attrs, dataArray, complet, numeric = False)
        self.setResult.triAxe()
        dims = [ES.axes[ax] for ax in self.setResult.axes]
        if numeric  : xres = xList[&#39;resval&#39;]
        else        : xres = xList[&#39;res&#39;]
        if dataArray and info :
            return xr.DataArray(xres, coord, dims, attrs=attrs[&#39;info&#39;])
        elif dataArray and not info :
            return xr.DataArray(xres, coord, dims)
        return None

    def voxel(self, sort=False):
        &#39;&#39;&#39;
        Visualize `ES.ESValue.ResultValue` in a cube with voxels.
        
        Parameters
        ----------
        sort : Boolean, optional
            Sort along axis. The default is False.
        Returns
        -------
        None.
        &#39;&#39;&#39;
        if self.setResult.getMaxIndex() == -1 : return        
        obc = copy.deepcopy(self)
        obc.setResult.full()
        obx = obc.to_xarray(numeric = True, complet=True, sort=sort)
        obp = obx&gt;=0
        obp.set_index(loc=&#39;locran&#39;, dat=&#39;datran&#39;, prp=&#39;prpran&#39;)
        ax = plt.figure().add_subplot(projection=&#39;3d&#39;)
        ax.voxels(obp, edgecolor=&#39;k&#39;)
        ax.set_xticks(np.arange(self.setDatation.nValue))
        ax.set_yticks(np.arange(self.setLocation.nValue))
        ax.set_zticks(np.arange(self.setProperty.nValue))
        ax.set(xlabel=&#39;dat (index)&#39;, ylabel=&#39;loc (index)&#39;, zlabel=&#39;prp (index)&#39;)
        plt.show()
        
    def plot(self, switch = False, line = True, sort = True, size = 5, marker=&#39;o&#39;):
        &#39;&#39;&#39;
        This function visualize an `ES.ESObservation.Observation` with line or colormesh.
        
        Parameters
        ----------
        switch : Boolean, optional
            Switch between x and y axis. The default is False.
        line : Boolean, optional
            Choice line or colormesh. The default is True.
        sort : Boolean, optional
            Sort along an axis. The default is True.
        size : Integer, optional
            Size of the figure to plot. The default is 5.
        marker : Character, optional
            Synbol for each point. The default is &#39;o&#39;.
        Returns
        -------
        None.
        &#39;&#39;&#39;
        if self.setResult.getMaxIndex() == -1 : return
        obx = self.to_xarray(numeric = True, complet=True, sort=sort)
        if len(obx.dims) == 1:
                obx.plot.line(x=obx.dims[0]+&#39;str&#39;, size=size, marker=marker)
        elif len(obx.dims) == 2:
            order = [0,1]
            ext = [&#39;&#39;, &#39;&#39;]
            for i in (0,1):
                if obx.dims[i] == &#39;dat&#39; : ext[i] = &#39;str&#39;
                elif str(obx.coords[obx.dims[i]].dtype)[0] != &#39;i&#39;: ext[i] = &#39;ran&#39;
            if switch : [order[0], order[1]] = [order[1], order[0]]
            if line :   
                obx.plot.line(x=obx.dims[order[0]]+ &#39;str&#39;, 
                              xticks=list(obx.coords[obx.dims[0]+&#39;str&#39;].values), 
                              #hue=obx.dims[order[1]]+ext[order[1]], size=size, marker=marker)
                              hue=obx.dims[order[1]]+&#39;str&#39;, size=size, marker=marker)
            else: 
                obx.plot(x=obx.dims[order[0]]+ext[order[0]], y=obx.dims[order[1]]+ext[order[1]], 
                         xticks=list(obx.coords[obx.dims[order[0]]+ext[order[0]]].values), 
                         yticks=list(obx.coords[obx.dims[order[1]]+ext[order[1]]].values), 
                         size = size)
            #τobg = self.to_geoDataFrame()
            #for i in range(len(self.setProperty)): obg.plot(obg.columns.array[i], legend=True)
        elif len(obx.dims) == 3:       
            if line :
                obx = obx.set_index(prp = &#34;prpstr&#34;, dat=&#34;datstr&#34;, loc=&#34;locstr&#34;)
                obx.sortby([&#34;dat&#34;,&#34;loc&#34;,&#34;prp&#34;]).plot.line(x=&#34;dat&#34;, col=&#34;prp&#34;, 
                                                          xticks=list(obx.coords[&#39;dat&#39;].values), 
                                                          col_wrap=2, size=size,
                                                          marker=marker)
            else :
                obx = obx.set_index(prp = &#34;prpstr&#34;, dat=&#34;datstr&#34;, loc=&#34;locran&#34;)
                obx.sortby([&#34;dat&#34;,&#34;loc&#34;,&#34;prp&#34;]).plot(x=&#34;dat&#34;, y=&#34;loc&#34;, col=&#34;prp&#34;, 
                                                     col_wrap=2, size=size, 
                                                     xticks=list(obx.coords[&#39;dat&#39;].values), 
                                                     yticks=list(obx.coords[&#39;loc&#39;].values))
            #obg = self.to_geoDataFrame()
            #for i in range(len(self.setProperty)): obg.plot(obg.columns.array[i], legend=True)
            #plt.legend(obx.coords[&#39;locstr&#39;].to_index().to_list())
        plt.show()

    def to_dataFrame(self):
        if self.setResult.dim &gt; 0 : return self.to_xarray(False).to_dataframe()
        else : return None

    def choropleth(self):
        if self.setResult.dim == 1 or self.setResult.dim // 10 == 1:
            m = folium.Map(location=self.setLocation.valueList[0].coorInv, zoom_start=6)
            folium.PolyLine(
                list(self.setLocation.valueList[i].coorInv for i in range(len(self.setLocation.valueList)))
            ).add_to(m)
            folium.Choropleth(
                geo_data=self.jsonFeature,
                name=&#34;test choropleth&#34;,
                data=self.to_dataFrame(),
                key_on=&#34;feature.id&#34;,
                #columns=[&#34;point&#34;, json.loads(self.setProperty[0].json(False))[ES.prp_propType]],
                columns=[&#34;point&#34;, json.loads(self.setProperty[0].json(ES.mOption))[ES.prp_propType]],
                fill_color=&#34;BuGn&#34;,
                fill_opacity=0.7,
                line_opacity=0.2,
                legend_name=&#34;test choropleth&#34;
            ).add_to(m)
            folium.LayerControl().add_to(m)
            return m
        return None</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ES.ESObservation.Observation"><code class="flex name class">
<span>class <span class="ident">Observation</span></span>
<span>(</span><span>*args, order='dlp', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>An <code><a title="ES.ESObservation.Observation" href="#ES.ESObservation.Observation">Observation</a></code> is made up of objects from the <code><a title="ES.ESObs" href="ESObs.html">ES.ESObs</a></code> class
which each describe a dimension of this object.</p>
<h2 id="attributes">Attributes :</h2>
<pre><code>- complet : consistency between Result and Datation, Location, Property
- score : Observation structure codification
- option : option 
- setLocation : shortcut to ESSetLocation (@property)
- setDatation : shortcut to ESSetDatation (@property)
- setProperty : shortcut to ESSetProperty (@property)
- setResult   : shortcut to ESSetResult   (@property)
- nValueObs   : lenght of ESObs
- name : textual description (inherited from ESObject)
- typeES : 'observation' (inherited from ESElement)
- classES : 'observation' (inherited from ESElement)
- metaType : 'ESObject' (inherited from ESElement)
- mAtt : namedValue dictionnary (inherited from ESElement)
- userAtt : namedValue dictionnary (inherited from ESElement)
- pComposant : list of ESObs (inherited from ESElement)
- pContenant : empty list (inherited from ESElement)
- parameter : namedValue dictionnary (inherited from ESElement)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Observation(ESObject):
    &#34;&#34;&#34;
    An `ES.ESObservation.Observation` is made up of objects from the `ES.ESObs` class
     which each describe a dimension of this object.
    
    Attributes :
    -----------
        - complet : consistency between Result and Datation, Location, Property
        - score : Observation structure codification
        - option : option 
        - setLocation : shortcut to ESSetLocation (@property)
        - setDatation : shortcut to ESSetDatation (@property)
        - setProperty : shortcut to ESSetProperty (@property)
        - setResult   : shortcut to ESSetResult   (@property)
        - nValueObs   : lenght of ESObs
        - name : textual description (inherited from ESObject)
        - typeES : &#39;observation&#39; (inherited from ESElement)
        - classES : &#39;observation&#39; (inherited from ESElement)
        - metaType : &#39;ESObject&#39; (inherited from ESElement)
        - mAtt : namedValue dictionnary (inherited from ESElement)
        - userAtt : namedValue dictionnary (inherited from ESElement)
        - pComposant : list of ESObs (inherited from ESElement)
        - pContenant : empty list (inherited from ESElement)
        - parameter : namedValue dictionnary (inherited from ESElement)

    &#34;&#34;&#34;
    #def __init__(self, jso = {}, order = &#39;dlp&#39;):
    def __init__(self, *args, order = &#39;dlp&#39;, **kwargs):
        ESObject.__init__(self)
        self.option = ES.mOption.copy()
        &#39;&#39;&#39;Dictionnary with options. &#39;&#39;&#39;
        self.mAtt[ES.obs_reference] = 0
        &#39;&#39;&#39; Attribut décrivant une `Observation` de référence utilisée pour compléter l&#39;Observation actuelle.&#39;&#39;&#39;
        self.score = -1
        &#39;&#39;&#39; Integer : Number of ESValue for each ESObs. For example, 122 means one PropertyValue (1), 
        several LocationValue (2), several DatationValue (2).&#39;&#39;&#39;
        self.complet = False
        &#39;&#39;&#39; Boolean : True if the number of ResultValue is consistent with the number of 
        LocationValue, DatationValue and PropertyValue.&#39;&#39;&#39;
        self.mAtt[ES.obs_resultTime] = &#34;null&#34;
        self.classES = ES.obs_classES
        self.typeES = ES.obs_typeES
        self.mAtt[ES.type] = &#34;obsError&#34;
        self.mAtt[ES.obs_id] = &#34;null&#34;
        for arg in args :
            if type(arg) in (dict, str) : self._init(arg)
            else : self.addESObs(arg)
        for k in kwargs :
            if type(kwargs[k]) in (ESSetDatation, ESSetLocation, ESSetProperty, ESSetResult) :
                self.addComposant(kwargs[k])
            else : self.addESObs(kwargs[k], k)
        self.majType(order)
    
    def _init(self, jso) :
        &#39;&#39;&#39; attributes and ESObs creation &#39;&#39;&#39;
        if type(jso) == str :
            try:
                js=json.loads(jso)
            except:
                return
        elif type(jso) == dict :
            js = jso.copy()
        else : return
        if js == {}: return
        if type(jso) == str and (ES.type not in list(js) or js[ES.type] != ES.obs_classES): return
        if ES.obs_id in list(js): self.mAtt[ES.obs_id] = js[ES.obs_id]
        if ES.obs_attributes in list(js): 
            if type(js[ES.obs_attributes]) == dict: js = js[ES.obs_attributes]
            else: return
        self.addAttributes(js)
        self.addESObs(js)
    
    def addESObs(self, js, classES = None) :
        &#39;&#39;&#39;
        Add a new `ES.ESObs` attached to `ES.ESObservation.Observation`. 
        The ES.ESObs child class is defined by classES or if None by the js structure.

        Parameters
        ----------
        js : ES.ESObs compatible type
        classES : string, optional
            value of the ES.ESObs ESclass attributes. The default is None.
        Returns
        -------
        None.

        &#39;&#39;&#39;
        if classES in (None, ES.dat_classES) and isESObs(ES.dat_classES, js): 
            ESSetDatation(pObs=self, jObj=js)
        if classES in (None, ES.loc_classES) and isESObs(ES.loc_classES, js): 
            ESSetLocation(pObs=self, jObj=js)
        if classES in (None, ES.prp_classES) and isESObs(ES.prp_classES, js): 
            ESSetProperty(pObs=self, jObj=js)
        if classES in (None, ES.res_classES) and isESObs(ES.res_classES, js): 
            ESSetResult  (pObs=self, jObj=js)

    def addAttributes(self, js):
        &#39;&#39;&#39;
        Add informations attached to `ES.ESObservation.Observation`

        Parameters
        ----------
        js : Dictionnary
            Keys are Observation keys or users keys.
        Returns
        -------
        None
        &#39;&#39;&#39;
        if type(js) != dict: return
        for k, v in js.items():
            if isESAtt(ES.obs_classES, k) or isUserAtt(k): self.mAtt[k] = v
            if k == ES.parameter: 
                try:  self.parameter = json.dumps(v)
                except:  self.parameter = &#34;null&#34;

    @property
    def bounds(self):
        &#39;&#39;&#39;tuple : Observation boundingBox (xmin, ymin, xmax, ymax).&#39;&#39;&#39;
        if self.setLocation : return shape(self).bounds
        else : return None

    @property
    def __geo_interface__(self):
        &#39;&#39;&#39;dict : geometry (see shapely)&#39;&#39;&#39;
        if self.setLocation : 
            return _gshape(self.setLocation.jsonSet(self.option)).__geo_interface__
            #return gshape(self.setLocation.geoInterface(self.option)).__geo_interface__
            &#39;&#39;&#39;return gshape(json.dumps(json.loads(&#39;{&#39; \
                        #+ self.setLocation.json(False, False, False, False)\
                        + self.setLocation.geoInterface(self.option)\
                        #+ &#39;}&#39;)[&#34;coordinates&#34;])).__geo_interface__
                        + &#39;}&#39;)[ES.loc_valName[indice]])).__geo_interface__&#39;&#39;&#39;
        else : return &#34;&#34;

    @property
    def jsonFeature(self):
        &#39;&#39;&#39; string : &#34;FeatureCollection&#34; with geometry in the Observation&#39;&#39;&#39;
        if self.setLocation : 
            geo = self.__geo_interface__
            if geo[&#39;type&#39;] == &#34;MultiPolygon&#34;: typ = &#34;Polygon&#34;
            else : typ = &#34;Point&#34;
            lis = list(dict(((&#34;type&#34;, typ), (&#34;coordinates&#34;, geo[&#39;coordinates&#39;][i]))) for i in range(len(geo[&#39;coordinates&#39;])))
            fea = list(dict(((&#34;type&#34;,&#34;Feature&#34;), (&#34;id&#34;, i), (&#34;geometry&#34;, lis[i]))) for i in range(len(geo[&#39;coordinates&#39;])))
            return json.dumps(dict(((&#34;type&#34;,&#34;FeatureCollection&#34;), (&#34;features&#34;,fea))))            
        else: return &#39;&#39;  
            
    @property
    def setLocation(self):
        &#39;&#39;&#39;object `ES.ESObs.ESSetLocation` if exists, None otherwise.&#39;&#39;&#39;
        return self.element(ES.loc_classES)
    @property
    def setDatation(self):  
        &#39;&#39;&#39;object `ES.ESObs.ESSetDatation` if exists, None otherwise.&#39;&#39;&#39;
        return self.element(ES.dat_classES)
    
    @property
    def setProperty(self):  
        &#39;&#39;&#39;object `ES.ESObs.ESSetProperty` if exists, None otherwise.&#39;&#39;&#39;
        return self.element(ES.prp_classES)
    
    @property
    def setResult(self):  
        &#39;&#39;&#39;object `ES.ESObs.ESSetResult` if exists, None otherwise.&#39;&#39;&#39;
        return self.element(ES.res_classES)

    def __copy__(self):
        return copy.deepcopy(self)
        &#39;&#39;&#39;opt = self.option
        self.option[&#34;json_obs_val&#34;] = True
        cop = Observation(self.json())
        self.option = opt
        cop.option = opt
        return cop&#39;&#39;&#39;

    def __iadd__(self, other):
        &#39;&#39;&#39; Add other&#39;s values to self&#39;s values&#39;&#39;&#39;
        other_opt = other.option
        self_opt = self.option
        ndat = nloc = nprp = 0
        idat = 0; iloc = 1; iprp = 2
        other.option[&#34;maj_index&#34;] = True
        other.majType()
        self.option[&#34;maj_index&#34;] = True
        self.majType()
        if other.setResult != None and other.setResult.getMaxIndex() &gt; -1:
            for resVal in other.setResult.valueList:
                ndat = self.addValue(other.setDatation.valueList[resVal.ind[idat]])
                nloc = self.addValue(other.setLocation.valueList[resVal.ind[iloc]])
                nprp = self.addValue(other.setProperty.valueList[resVal.ind[iprp]])
                resv = ResultValue(resVal.value)
                resv.ind = [ndat, nloc, nprp]
                self.addResultValue(resv)
            self.majType()
        other.option = other_opt
        self.option = self_opt
        return self
    
    def __add__(self, other):
        &#39;&#39;&#39; Add other&#39;s values to self&#39;s values in a new Observation&#39;&#39;&#39;
        obres = self.__copy__()
        obres.__iadd__(other)
        return obres
    
    def extend(self, obs):
        &#39;&#39;&#39;
        Copy `ES.ESObs` from obs to self (if it daesn&#39;t exist)

        Parameters
        ----------
        obs : object ES.ESObservation.Observation to copy
        Returns
        -------
        None.
        &#39;&#39;&#39;
        for p in obs.pComposant :
            if self.element(p.classES) == None : self.addComposant(p)
        self.majType()    
        
    def addResultValue(self, esValue):
        &#39;&#39;&#39;
        Add a new `ES.ESValue.ResultValue` in the `ES.ESObs.ESSetResult`

        Parameters
        ----------
        esValue : ES.ESValue.ResultValue
        Returns
        -------
        Int : last index in the `ES.ESValue.ESSet` valueList.
        &#39;&#39;&#39;
        return self.element(ES.res_valueType).addValue(ResultValue, esValue)
    
    def addValue(self, esValue):
        &#39;&#39;&#39;
        Add a new `ES.ESValue` in the `ES.ESValue.ESSet`

        Parameters
        ----------
        esValue : ES.ESValue
        Returns
        -------
        Int : last index in the `ES.ESValue.ESSet` valueList.
        &#39;&#39;&#39;
        if type(esValue)== PropertyValue:
            if self.element(ES.prp_valueType) == None: ESSetProperty(pObs=self)
            return self.element(ES.prp_valueType).addValue(PropertyValue, esValue)
        elif type(esValue)== LocationValue:
            if self.element(ES.loc_valueType) == None: ESSetLocation(pObs=self)
            return self.element(ES.loc_valueType).addValue(LocationValue, esValue)
        elif type(esValue)== DatationValue:
            if self.element(ES.dat_valueType) == None: ESSetDatation(pObs=self)
            return self.element(ES.dat_valueType).addValue(DatationValue, esValue)
        else: return 0

    def addListResultValue(self, listEsValue):
        &#39;&#39;&#39;
        Add a list of new `ES.ESValue.ResultValue` in the `ES.ESObs.ESSetResult`.

        Parameters
        ----------
        listEsValue : list of `ES.ESValue.ResultValue`
        Returns
        -------
        None
        &#39;&#39;&#39;
        if type(listEsValue) != list : return
        if self.element(ES.res_valueType) == None: resSet = ESSetResult(pObs=self)
        else: resSet = self.setResult
        for val in listEsValue : resSet.addValue(ResultValue, ResultValue(val))
            #self.addResultValue(ResultValue(val) )

    def majList(self, ValueClass, listVal, info = &#39;name&#39;):
        &#39;&#39;&#39;
        Modify a list of one attribute (name or value) in an `ES.ESObs`

        Parameters
        ----------
        ValueClass : class ES.ESObs 
        listVal : list of values
        info : string, optional, 
            Attribute. The default is &#39;name&#39;. 
        Returns
        -------
        None
        &#39;&#39;&#39;
        if ValueClass == DatationValue and self.setDatation != None : 
            if info == &#39;name&#39;: self.setDatation.majListName(listVal)
            else : self.setDatation.majListValue(ValueClass, listVal, info == &#39;base&#39;)
        elif ValueClass == LocationValue and self.setLocation != None : 
            if info == &#39;name&#39;: self.setLocation.majListName(listVal)
            else : self.setLocation.majListValue(ValueClass, listVal, info == &#39;base&#39;)
        elif ValueClass == PropertyValue and self.setProperty != None : 
            if info == &#39;name&#39;: self.setProperty.majListName(listVal)

    def addListValue(self, ValueClass, listEsValue):
        &#39;&#39;&#39;
        Add a list of new `ES.ESValue` in a `ES.ESValue.ESSet`.

        Parameters
        ----------
        ValueClass : name of the selected class ES.ESValue
        listEsValue : list of ES.ESValue
        Returns
        -------
        None
        &#39;&#39;&#39;
        for val in listEsValue : self.addValue(ValueClass(val) )
        
    def addValueObservation(self, val, idat, iloc, iprp):
        &#39;&#39;&#39;
        Add a new `ES.ESValue.ResultValue` 
        
        Parameters
        ----------
        val : ES.ESValue.ResultValue compatible type
        idat, iloc, iprp : integer, ES.ESValue.ESIndexValue
        Returns
        -------
        Int : last index in the `ES.ESValue.ESSet` valueList.
        &#39;&#39;&#39;
        if self.element(ES.res_valueType) == None: ESSetResult(pObs=self)
        return self.addResultValue(ResultValue(val, [idat, iloc, iprp]))

    def addListValueObservation(self, listVal, listIdat, listIloc, listIprp):
        &#39;&#39;&#39;
        Add a list of new `ES.ESValue.ResultValue` 
        
        Parameters
        ----------
        listVal : list of ES.ESValue.ResultValue compatible type
        listIdat, listIloc, listIprp : list of integer in ES.ESValue.ESIndexValue
        Returns
        -------
        None
        &#39;&#39;&#39;
        if len(listVal)==len(listIdat)==len(listIloc)==len(listIprp) :
            for i in range(len(listVal)) :
                self.addResultValue(ResultValue(listVal[i], [listIdat[i], listIloc[i], listIprp[i]]))

    def addValueSensor(self, resVal, datVal, locVal, nprp):
        &#39;&#39;&#39;
        Add `ES.ESValue.ResultValue`,  `ES.ESValue.DatationValue`,  `ES.ESValue.LocationValue`
        for a defined property.

        Parameters
        ----------
        resVal : ES.ESValue.ResultValue compatible type, 
        datVal : ES.ESValue.DatationValue compatible type
        locVal : ES.ESValue.LocationValue compatible type
        nprp : integer, index of the ES.ESValue.PropertyValue
        Returns
        -------
        Int : last index in the `ES.ESValue.ESSet` valueList.

        &#39;&#39;&#39;
        return self.addValueObservation(resVal, self.addValue(DatationValue(datVal)), 
                                        self.addValue(LocationValue(locVal)), nprp)

    def json(self): 
        &#39;&#39;&#39;
        Export in Json format. 
        
        Returns
        -------
        string : Json string 

        &#39;&#39;&#39;
        if self.option[&#34;json_elt_type&#34;]: option_type = 1
        else: option_type = 0
        js =&#34;&#34;
        if self.option[&#34;json_obs_val&#34;]: js = &#34;{&#34;
        js += &#39;&#34;&#39; + ES.type +&#39;&#34;:&#34;&#39; + ES.obs_classES +&#39;&#34;,&#39;
        if self.mAtt[ES.obs_id] != &#34;null&#34;: js += &#39;&#34;&#39; + ES.obs_id + &#39;&#34;:&#34;&#39; + self.mAtt[ES.obs_id] + &#39;&#34;,&#39;
        if self.option[&#34;json_obs_attrib&#34;]: js += &#39;&#34;&#39; + ES.obs_attributes + &#39;&#34;:{&#39;
        js += self._jsonAtt(option_type)
        for cp in self.pComposant:
            js += cp.json(self.option)
            if js[-1] != &#39;,&#39;: js += &#34;,&#34;
        if self.option[&#34;json_param&#34;] and self.parameter != &#34;null&#34;: 
            js += &#39;&#34;&#39; + ES.parameter +&#39;&#34;:&#39; + self.parameter + &#39;,&#39;
        jsInfo = self._jsonInfo(self.option[&#34;json_info_type&#34;], self.option[&#34;json_info_nval&#34;],
                            self.option[&#34;json_info_box&#34;], self.option[&#34;json_info_autre&#34;])
        if jsInfo != &#34;&#34; : js +=  jsInfo + &#39;,&#39;
        if js[-1] == &#39;,&#39;: js = js[:-1]
        if self.option[&#34;json_obs_attrib&#34;]: js += &#34;}&#34;
        if self.option[&#34;json_obs_val&#34;]:    js += &#34;}&#34;
        return js
    
    def to_bytes(self):
        &#39;&#39;&#39;
        Export in binary format. 
        
        Returns
        -------
        bytes : binary representation of the ES.ESObservation.Observation

        &#39;&#39;&#39;
        byt = bytes()
        code_el = ES.codeb[self.classES] 
        byt += struct.pack(&#39;&lt;B&#39;, (code_el &lt;&lt; 5) | self.mAtt[ES.obs_reference])
        if self.setProperty != None: 
            byt += self.setProperty.to_bytes(self.option[&#34;json_prp_name&#34;])
        if self.setLocation != None: 
            byt += self.setLocation.to_bytes(self.option[&#34;json_loc_name&#34;])
        if self.setDatation != None: 
            byt += self.setDatation.to_bytes(self.option[&#34;json_dat_name&#34;])
        if self.setResult != None: 
            propList = [self.setProperty.valueList[i].pType 
                        for i in range(self.setProperty.nValue)]
            byt += self.setResult.to_bytes(False, self.option[&#34;json_res_index&#34;], 
                                           self.option[&#34;bytes_res_format&#34;], propList)
        return byt
        
    def from_bytes(self, byt):
        &#39;&#39;&#39;
        Complete an empty `ES.ESObservation.Observation` with binary data. 
        
        Parameters
        -------
        byt : binary representation of an ES.ESObservation.Observation
        Returns
        -------
        None
        &#39;&#39;&#39;
        code_ob = (byt[0] &amp; 0b11100000) &gt;&gt; 5
        self.mAtt[ES.obs_reference] = byt[0] &amp; 0b00011111
        if code_ob != ES.codeb[self.classES]: return
        idx = 1
        while idx &lt; byt.__len__() :
            code_el = (byt[idx] &amp; 0b11100000) &gt;&gt; 5
            #forma =  byt[idx] &amp; 0b00001111
            if   code_el == 1: es = ESSetLocation(pObs=self)
            elif code_el == 2: es = ESSetDatation(pObs=self)
            elif code_el == 3: es = ESSetProperty(pObs=self)
            elif code_el &lt; 6:
                es = ESSetResult(pObs=self)
                if code_el == 5: 
                    propList = [self.setProperty.valueList[i].pType 
                            for i in range(self.setProperty.nValue)]
                else :
                    es.from_bytes(byt[idx:], [])
                    es.majIndex(es.nValue, self.setProperty.nValue, 
                            self.setDatation.nValue, self.setLocation.nValue)
                    propList = [self.setProperty.valueList[es.valueList[i].ind[2]].pType
                            for i in range(es.nValue)]
                    es.__init__()
            else: return
            if code_el &lt; 4 : 
                idx += es.from_bytes(byt[idx:])
            else :
                idx += es.from_bytes(byt[idx:], propList)
    
    def _jsonInfoTypes(self, dcinf):
        &#39;&#39;&#39; Add information&#39;s key-value to dict dcinf&#39;&#39;&#39;
        dcinf[ES.json_type_obs] = self.mAtt[ES.type]
        if self.setLocation != None :
            if self.setLocation.nValue &gt; 1 : 
                dcinf[ES.json_type_loc] = ES.multi + self.setLocation.mAtt[ES.type]
            else :
                dcinf[ES.json_type_loc] = self.setLocation.mAtt[ES.type]
        if self.setDatation != None :
            if self.setDatation.nValue &gt; 1 : 
                dcinf[ES.json_type_dat] = ES.multi + self.setDatation.mAtt[ES.type]
            else :
                dcinf[ES.json_type_dat] = self.setDatation.mAtt[ES.type]
        if self.setProperty != None :
            if self.setProperty.nValue &gt; 1 : 
                dcinf[ES.json_type_prp] = ES.multi + self.setProperty.mAtt[ES.type]
            else :
                dcinf[ES.json_type_prp] = self.setProperty.mAtt[ES.type]
        if self.setResult != None :
            if self.setResult.nValue &gt; 1 : 
                dcinf[ES.json_type_res] = ES.multi + self.setResult.mAtt[ES.type]
            else :
                dcinf[ES.json_type_res] = self.setResult.mAtt[ES.type]

    def _jsonInfoNval(self, dcinf):
        &#39;&#39;&#39; Add valueList lenght to dict dcinf&#39;&#39;&#39;
        if self.setLocation != None : dcinf[ES.json_nval_loc] = self.setLocation.nValue
        if self.setDatation != None : dcinf[ES.json_nval_dat] = self.setDatation.nValue
        if self.setProperty != None : dcinf[ES.json_nval_prp] = self.setProperty.nValue
        if self.setResult   != None : dcinf[ES.json_nval_res] = self.setResult.nValue

    def _jsonInfoBox(self, dcinf):
        &#39;&#39;&#39; Add box informations&#39;s key-value to dict dcinf&#39;&#39;&#39;
        if self.setLocation != None :
            dcinf[ES.loc_boxMin] = self.setLocation.boxMin.point
            dcinf[ES.loc_boxMax] = self.setLocation.boxMax.point
        if self.setDatation != None :
            dcinf[ES.dat_boxMin] = self.setDatation.boxMin.json(ES.mOption)
            dcinf[ES.dat_boxMax] = self.setDatation.boxMax.json(ES.mOption)

    def _jsonInfoAutre(self, dcinf):
        &#39;&#39;&#39; Add other&#39;s information key-value to dict dcinf&#39;&#39;&#39;
        dcinf[ES.obs_complet] = self.complet
        dcinf[ES.obs_score] = self.score
        if self.setResult != None :
            dcinf[ES.res_mRate] = self.setResult.measureRate
            dcinf[ES.res_dim] = self.setResult.dim
            dcinf[ES.res_axes] = self.setResult.axes

    def _jsonInfo(self, types, nval, box, autre):
        &#39;&#39;&#39; Create json string with dict datas&#39;&#39;&#39;
        dcinf = dict()
        if types :  self._jsonInfoTypes(dcinf)
        if nval :   self._jsonInfoNval(dcinf)
        if box :    self._jsonInfoBox(dcinf)
        if autre:   self._jsonInfoAutre(dcinf)
        ldel =[]
        for k,v in dcinf.items() :
            if type(v) == str and (v == &#34;null&#34; or v ==&#39;&#39;)   : ldel.append(k)
            if type(v) == list and v == ES.nullCoor         : ldel.append(k) 
        for k in ldel :         del dcinf[k]
        if len(dcinf) == 0 :    return &#34;&#34;
        else :                  return &#39;&#34;&#39; +ES.information + &#39;&#34;:&#39; + json.dumps(dcinf)

    @property 
    def nValueObs(self):
        &#39;&#39;&#39;list : lenght of `ES.ESObs.ESSetProperty`, `ES.ESObs.ESSetDatation`, 
                `ES.ESObs.ESSetLocation`, `ES.ESObs.ESSetResult`.&#39;&#39;&#39;
        nPrp = nDat = nLoc = nRes = 0
        if self.setResult   != None: nRes = self.setResult.nValue
        if self.setLocation != None: nLoc = self.setLocation.nValue
        if self.setDatation != None: nDat = self.setDatation.nValue
        if self.setProperty != None: nPrp = self.setProperty.nValue
        return [nPrp, nDat, nLoc, nRes]

    def iloc(self, idat, iloc, iprp):
        &#39;&#39;&#39;
        Return the `ES.ESValue` values for an `ES.ESValue.ESIndexValue`. 

        Parameters
        ----------
        idat, iloc, iprp : ES.ESValue.ESIndexValue

        Returns
        -------
        dictionnary, ES.ESValue of each ES.ESObs
        &#39;&#39;&#39;
        if not self.complet : return dict()
        dic = dict()
        if self.setDatation != None and idat &lt; self.setDatation.nValue: 
            dic[ES.dat_classES] = self.setDatation.valueList[idat].json(self.option)
        if self.setLocation != None and iloc &lt; self.setLocation.nValue: 
            dic[ES.loc_classES] = self.setLocation.valueList[iloc].json(self.option)
        if self.setProperty != None and iprp &lt; self.setProperty.nValue: 
            dic[ES.prp_classES] = self.setProperty.valueList[iprp].json(self.option)
        if self.setResult != None : 
            for i in range(self.setResult.nValue) : 
                if self.setResult.valueList[i].ind == [idat, iloc, iprp] : 
                    dic[ES.res_classES] = self.setResult.valueList[i].json(self.option)
        return dic
    
    def _typeObs(self):
        [nPrp, nDat, nLoc, nRes] = self.nValueObs
        self.score = min(max(min(nPrp, 2) * 100 + min(nLoc,2) * 10 + min(nDat, 2), -1), 229);
        if self.setResult == None or (self.setResult.error or self.setResult.getMaxIndex() == -1 or \
           self.setResult.nInd[0] &gt; nDat or self.setResult.nInd[1] &gt; nLoc or self.setResult.nInd[2] &gt; nPrp):
               self.mAtt[ES.type] = &#34;obserror&#34;
               return
        if self.score == 22  and self.setResult.dim == 2:       self.score = 23
        if self.score == 122 and self.setResult.dim == 2:       self.score = 123
        if self.score == 202 and self.setResult.dim == 2:       self.score = 203
        if self.score == 212 and self.setResult.dim == 2:       self.score = 213
        if self.score == 220 and self.setResult.dim == 2:       self.score = 223
        if self.score == 221 and self.setResult.dim == 2:       self.score = 224
        if self.score == 222 and self.setResult.dim == 3:       self.score = 228
        if self.score == 222 and self.setResult.dim == 2 and 2 in self.setResult.axes:  self.score = 225
        if self.score == 222 and self.setResult.dim == 2 and 1 in self.setResult.axes:  self.score = 226
        if self.score == 222 and self.setResult.dim == 2 and 0 in self.setResult.axes:  self.score = 227
        self.mAtt[ES.type] = ES.obsCat[self.score]

    @staticmethod
    def _sortAlign(npInd, list1, ind1, ind2):
        return [int(npInd[list(npInd[:,ind1]).index(i),:][ind2])  for i in list1]    
    
    def full(self, maj=True) : 
        &#39;&#39;&#39;
        Add empty `ES.ESValue.ResultValue` to have a &#39;complete&#39; `ES.ESObservation.Observation`

        Parameters
        ----------
        maj : boolean, optional
            If True, add value to Observation, else return listValue. The default is True.
        Returns
        -------
        empty list if maj is True, else `ES.ESObs.ESSetResult` listValue.
        &#39;&#39;&#39;
        return self.setResult.full(maj)
    
    def sort(self, order = &#39;dlp&#39;, cross = True, sort = [[], [], []]): 
        &#39;&#39;&#39;
        Modify the order of `ES.ESValue`.

        Parameters
        ----------
        order : string, optional
            Ordered list to follow (d:dat, l:loc, p:prp). The default is &#39;dlp&#39;.
        cross : boolean, optional
            If True, synchronize the order to have a less dimension. The default is True.
        sort : list, optional
            If empty, order is follow, if not sorting follows the list provided. The default is empty [[], [], []].
        Returns
        -------
        None.
        &#39;&#39;&#39;
        if self.setResult == None or not self.setResult.isIndex() : return
        tr = tri = [[], [], []]
        orde = [ES.nax[order[0]], ES.nax[order[1]], ES.nax[order[2]]]
        # ordre de tri de chacun des axes
        for i in range(3) : tri[i] = self._sortSet(i, sort[i], False)
        npInd = np.array(self.setResult.vListIndex)
        if cross:
            for ax in self.setResult.axes : 
                if ax &gt; 100 : 
                    tri[orde[1]] = self._sortAlign(npInd, tri[orde[0]], orde[0], orde[1])
                    tri[orde[2]] = self._sortAlign(npInd, tri[orde[0]], orde[0], orde[2])
                elif ax &gt; 9 :
                    (first, second) = (ax//10, ax%10)
                    if orde.index(second) &lt; orde.index(first) : (first, second) = (second, first)
                    tri[second] = self._sortAlign(npInd, tri[first], first, second)
        for i in range(3) : tr[i] = self._sortSet(i, tri[i])
        for resVal in self.setResult.valueList :
            for i in range(3) : resVal.ind[i] = tr[i].index(resVal.ind[i])
        self.setResult.sort()
    
    def _sortSet(self, ax, tri = [], update = True):
        if ax == 0 and self.setDatation != None : return self.setDatation.sort(tri, update)
        if ax == 1 and self.setLocation != None : return self.setLocation.sort(tri, update)
        if ax == 2 and self.setProperty != None : return self.setProperty.sort(tri, update)
        return [0]
    
    def majType(self, order = &#39;dlp&#39;):
        &#39;&#39;&#39;
        Generate the `ES.ESObservation.Observation` and associates `ES.ESObs` 
        characteristics (e.g. complet, score, dim...) and the index for `ES.ESValue.ResultValue` data.
        
        Parameters
        ----------
        order : String, optional
            Result ordering for result without index. The order is define with
            three letters : l (location), d (datation), p (property). The default is &#39;dlp&#39;.
        Returns
        -------
        None.
        &#39;&#39;&#39;
        [nprp, ndat, nloc, nRes] = self.nValueObs
        nPrp = max(1, nprp)
        nDat = max(1, ndat)
        nLoc = max(1, nloc)
        if len(order) == 3 : 
            self.complet = nRes == nLoc * nDat * nPrp \
                        or nRes == nDat * nPrp == nDat * nLoc \
                        or nRes == nLoc * nPrp == nLoc * nDat \
                        or nRes == nPrp * nLoc == nPrp * nDat \
                        or nRes == nLoc == nDat == nPrp
        if len(order) == 2 : 
            self.complet = nRes == nDat * nPrp == nDat * nLoc \
                        or nRes == nLoc * nPrp == nLoc * nDat \
                        or nRes == nPrp * nLoc == nPrp * nDat \
                        or nRes == nLoc == nDat == nPrp
        if len(order) == 1 : 
            self.complet = nRes == nLoc == nDat == nPrp
        
        if self.complet: self.setResult.majIndex(nRes, nPrp, nDat, nLoc, order)
        if self.setResult   != None: self.setResult.  analyse()
        if self.setLocation != None: self.setLocation.analyse()
        if self.setDatation != None: self.setDatation.analyse()
        self._typeObs()

    def _xlist(self):
        xList = {}
        if self.setLocation != None: 
            xList[&#39;loc&#39;]    = self.setLocation.to_numpy()
            xList[&#39;locstr&#39;] = self.setLocation.to_numpy(func = LocationValue.json)
            xList[&#39;loclon&#39;] = self.setLocation.to_numpy(func = LocationValue.vPointX)
            xList[&#39;loclat&#39;] = self.setLocation.to_numpy(func = LocationValue.vPointY)
            xList[&#39;locnam&#39;] = self.setLocation.to_numpy(func = LocationValue.vName)
            xList[&#39;locran&#39;] = np.arange(len(xList[&#39;loc&#39;]))
        if self.setDatation != None: 
            xList[&#39;dat&#39;]    = self.setDatation.to_numpy()
            xList[&#39;datstr&#39;] = self.setDatation.to_numpy(func = DatationValue.json)
            xList[&#39;datnam&#39;] = self.setDatation.to_numpy(func = DatationValue.vName)
            xList[&#39;datran&#39;] = np.arange(len(xList[&#39;dat&#39;]))
        if self.setProperty != None: 
            xList[&#39;prp&#39;]    = self.setProperty.to_numpy()
            xList[&#39;prpstr&#39;] = self.setProperty.to_numpy(func = PropertyValue.json)
            xList[&#39;prpnam&#39;] = self.setProperty.to_numpy(func = PropertyValue.vName)
            xList[&#39;prpran&#39;] = np.arange(len(xList[&#39;prp&#39;]))
        if self.setResult  != None: 
            xList[&#39;res&#39;]    = self.setResult.to_numpy()
            xList[&#39;resval&#39;] = self.setResult.to_numpy(func = ResultValue.to_float)
            xList[&#39;resstr&#39;] = self.setResult.to_numpy(func = ResultValue.json)
            xList[&#39;resnam&#39;] = self.setResult.to_numpy(func = ResultValue.vName)
            xList[&#39;resran&#39;] = np.arange(len(xList[&#39;res&#39;]))
        return xList

    def _xAttrs(self) :
        attrs = ES.xattrs
        attrs[&#39;info&#39;]   = json.loads(&#34;{&#34; + self._jsonInfo(True, False, True, False) + &#34;}&#34;)[&#34;information&#34;]
        return attrs

    def _axeCoor(self, nValAxe) :
        for ax in self.setResult.axes :
            if ax &gt; 100 : return ax
            if ax &lt; 9 and nValAxe == ax : return ax
            elif ax &gt; 9 and (nValAxe == ax//10 or nValAxe == ax%10) : return ax
        return None
    
    def _xCoord(self, xList, attrs, dataArray, complet, numeric) :
        #nax = {&#39;dat&#39; : 0, &#39;loc&#39; : 1, &#39;prp&#39; : 2}
        coord = {}
        for key, val in xList.items() :
            if key[:3] != &#39;res&#39; and self._axeCoor(ES.nax[key[:3]]) != None \
                and (complet or (not complet and len(key) == 3)):
                coord[key] = ([ES.axes[self._axeCoor(ES.nax[key[:3]])]], val, attrs[key[:3]])
                if key == &#39;loclon&#39; : coord[key] = (coord[key][0], val, attrs[&#39;lon&#39;])
                if key == &#39;loclat&#39; : coord[key] = (coord[key][0], val, attrs[&#39;lat&#39;])
        for ax in self.setResult.axes :
            if ax &gt; 9 :
                le = len(xList[ES.axes[ax%10]])
                coord[ES.axes[ax]] = ([ES.axes[ax]], np.arange(le))
                if ax &gt; 100 : lis = [str(xList[&#39;datstr&#39;][i]) + xList[&#39;locstr&#39;][i] + 
                                     xList[&#39;prpstr&#39;][i] for i in range(le)]
                else : lis = [str(xList[ES.axes[ax%10]+&#39;str&#39;][i]) + 
                              str(xList[ES.axes[ax//10]+&#39;str&#39;][i]) for i in range(le)]
                coord[ES.axes[ax]+&#39;str&#39;] = ([ES.axes[ax]], lis)
        if numeric :
            if &#39;loc&#39; in coord.keys() : coord[&#39;loc&#39;] = (coord[&#39;loc&#39;][0], xList[&#39;locran&#39;], coord[&#39;loc&#39;][2])
            if &#39;dat&#39; in coord.keys() : coord[&#39;dat&#39;] = (coord[&#39;dat&#39;][0], xList[&#39;datstr&#39;], coord[&#39;dat&#39;][2])
            if &#39;prp&#39; in coord.keys() : coord[&#39;prp&#39;] = (coord[&#39;prp&#39;][0], xList[&#39;prpran&#39;], coord[&#39;prp&#39;][2])
        return coord
    

    def to_xarray(self, dataArray = True, sort = True, complet = False, info = False, numeric = False):
        &#39;&#39;&#39;
        Convert `ES.ESObservation.Observation` to DataArray or DataSet with the smallest dimension. 
        
        Parameters
        ----------
        dataArray : Boolean, optional
            DataArray ou DataSet. The default is True.
        sort : Boolean, optional
            Sort along an axis. The default is True.
        complet : Boolean, optional
            Generate all the DataArray.Coords or only one. The default is False.
        info : Boolean, optional
            Generate a specific Coords with Observation characteristics. The default is False.
        numeric : Boolean, optional
            Generate a numeric DataArray.Values. The default is False.
        Returns
        -------
        xarray.DataArray or xarray.DataSet.
        &#39;&#39;&#39;
        if self.setResult.getMaxIndex() == -1 : return None
        if sort : self.sort()
        xList = self._xlist()
        attrs = self._xAttrs()
        coord = self._xCoord(xList, attrs, dataArray, complet, numeric = False)
        self.setResult.triAxe()
        dims = [ES.axes[ax] for ax in self.setResult.axes]
        if numeric  : xres = xList[&#39;resval&#39;]
        else        : xres = xList[&#39;res&#39;]
        if dataArray and info :
            return xr.DataArray(xres, coord, dims, attrs=attrs[&#39;info&#39;])
        elif dataArray and not info :
            return xr.DataArray(xres, coord, dims)
        return None

    def voxel(self, sort=False):
        &#39;&#39;&#39;
        Visualize `ES.ESValue.ResultValue` in a cube with voxels.
        
        Parameters
        ----------
        sort : Boolean, optional
            Sort along axis. The default is False.
        Returns
        -------
        None.
        &#39;&#39;&#39;
        if self.setResult.getMaxIndex() == -1 : return        
        obc = copy.deepcopy(self)
        obc.setResult.full()
        obx = obc.to_xarray(numeric = True, complet=True, sort=sort)
        obp = obx&gt;=0
        obp.set_index(loc=&#39;locran&#39;, dat=&#39;datran&#39;, prp=&#39;prpran&#39;)
        ax = plt.figure().add_subplot(projection=&#39;3d&#39;)
        ax.voxels(obp, edgecolor=&#39;k&#39;)
        ax.set_xticks(np.arange(self.setDatation.nValue))
        ax.set_yticks(np.arange(self.setLocation.nValue))
        ax.set_zticks(np.arange(self.setProperty.nValue))
        ax.set(xlabel=&#39;dat (index)&#39;, ylabel=&#39;loc (index)&#39;, zlabel=&#39;prp (index)&#39;)
        plt.show()
        
    def plot(self, switch = False, line = True, sort = True, size = 5, marker=&#39;o&#39;):
        &#39;&#39;&#39;
        This function visualize an `ES.ESObservation.Observation` with line or colormesh.
        
        Parameters
        ----------
        switch : Boolean, optional
            Switch between x and y axis. The default is False.
        line : Boolean, optional
            Choice line or colormesh. The default is True.
        sort : Boolean, optional
            Sort along an axis. The default is True.
        size : Integer, optional
            Size of the figure to plot. The default is 5.
        marker : Character, optional
            Synbol for each point. The default is &#39;o&#39;.
        Returns
        -------
        None.
        &#39;&#39;&#39;
        if self.setResult.getMaxIndex() == -1 : return
        obx = self.to_xarray(numeric = True, complet=True, sort=sort)
        if len(obx.dims) == 1:
                obx.plot.line(x=obx.dims[0]+&#39;str&#39;, size=size, marker=marker)
        elif len(obx.dims) == 2:
            order = [0,1]
            ext = [&#39;&#39;, &#39;&#39;]
            for i in (0,1):
                if obx.dims[i] == &#39;dat&#39; : ext[i] = &#39;str&#39;
                elif str(obx.coords[obx.dims[i]].dtype)[0] != &#39;i&#39;: ext[i] = &#39;ran&#39;
            if switch : [order[0], order[1]] = [order[1], order[0]]
            if line :   
                obx.plot.line(x=obx.dims[order[0]]+ &#39;str&#39;, 
                              xticks=list(obx.coords[obx.dims[0]+&#39;str&#39;].values), 
                              #hue=obx.dims[order[1]]+ext[order[1]], size=size, marker=marker)
                              hue=obx.dims[order[1]]+&#39;str&#39;, size=size, marker=marker)
            else: 
                obx.plot(x=obx.dims[order[0]]+ext[order[0]], y=obx.dims[order[1]]+ext[order[1]], 
                         xticks=list(obx.coords[obx.dims[order[0]]+ext[order[0]]].values), 
                         yticks=list(obx.coords[obx.dims[order[1]]+ext[order[1]]].values), 
                         size = size)
            #τobg = self.to_geoDataFrame()
            #for i in range(len(self.setProperty)): obg.plot(obg.columns.array[i], legend=True)
        elif len(obx.dims) == 3:       
            if line :
                obx = obx.set_index(prp = &#34;prpstr&#34;, dat=&#34;datstr&#34;, loc=&#34;locstr&#34;)
                obx.sortby([&#34;dat&#34;,&#34;loc&#34;,&#34;prp&#34;]).plot.line(x=&#34;dat&#34;, col=&#34;prp&#34;, 
                                                          xticks=list(obx.coords[&#39;dat&#39;].values), 
                                                          col_wrap=2, size=size,
                                                          marker=marker)
            else :
                obx = obx.set_index(prp = &#34;prpstr&#34;, dat=&#34;datstr&#34;, loc=&#34;locran&#34;)
                obx.sortby([&#34;dat&#34;,&#34;loc&#34;,&#34;prp&#34;]).plot(x=&#34;dat&#34;, y=&#34;loc&#34;, col=&#34;prp&#34;, 
                                                     col_wrap=2, size=size, 
                                                     xticks=list(obx.coords[&#39;dat&#39;].values), 
                                                     yticks=list(obx.coords[&#39;loc&#39;].values))
            #obg = self.to_geoDataFrame()
            #for i in range(len(self.setProperty)): obg.plot(obg.columns.array[i], legend=True)
            #plt.legend(obx.coords[&#39;locstr&#39;].to_index().to_list())
        plt.show()

    def to_dataFrame(self):
        if self.setResult.dim &gt; 0 : return self.to_xarray(False).to_dataframe()
        else : return None

    def choropleth(self):
        if self.setResult.dim == 1 or self.setResult.dim // 10 == 1:
            m = folium.Map(location=self.setLocation.valueList[0].coorInv, zoom_start=6)
            folium.PolyLine(
                list(self.setLocation.valueList[i].coorInv for i in range(len(self.setLocation.valueList)))
            ).add_to(m)
            folium.Choropleth(
                geo_data=self.jsonFeature,
                name=&#34;test choropleth&#34;,
                data=self.to_dataFrame(),
                key_on=&#34;feature.id&#34;,
                #columns=[&#34;point&#34;, json.loads(self.setProperty[0].json(False))[ES.prp_propType]],
                columns=[&#34;point&#34;, json.loads(self.setProperty[0].json(ES.mOption))[ES.prp_propType]],
                fill_color=&#34;BuGn&#34;,
                fill_opacity=0.7,
                line_opacity=0.2,
                legend_name=&#34;test choropleth&#34;
            ).add_to(m)
            folium.LayerControl().add_to(m)
            return m
        return None</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>ESElement.ESObject</li>
<li>ESElement.ESElement</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="ES.ESObservation.Observation.bounds"><code class="name">var <span class="ident">bounds</span></code></dt>
<dd>
<div class="desc"><p>tuple : Observation boundingBox (xmin, ymin, xmax, ymax).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def bounds(self):
    &#39;&#39;&#39;tuple : Observation boundingBox (xmin, ymin, xmax, ymax).&#39;&#39;&#39;
    if self.setLocation : return shape(self).bounds
    else : return None</code></pre>
</details>
</dd>
<dt id="ES.ESObservation.Observation.complet"><code class="name">var <span class="ident">complet</span></code></dt>
<dd>
<div class="desc"><p>Boolean : True if the number of ResultValue is consistent with the number of
LocationValue, DatationValue and PropertyValue.</p></div>
</dd>
<dt id="ES.ESObservation.Observation.jsonFeature"><code class="name">var <span class="ident">jsonFeature</span></code></dt>
<dd>
<div class="desc"><p>string : "FeatureCollection" with geometry in the Observation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def jsonFeature(self):
    &#39;&#39;&#39; string : &#34;FeatureCollection&#34; with geometry in the Observation&#39;&#39;&#39;
    if self.setLocation : 
        geo = self.__geo_interface__
        if geo[&#39;type&#39;] == &#34;MultiPolygon&#34;: typ = &#34;Polygon&#34;
        else : typ = &#34;Point&#34;
        lis = list(dict(((&#34;type&#34;, typ), (&#34;coordinates&#34;, geo[&#39;coordinates&#39;][i]))) for i in range(len(geo[&#39;coordinates&#39;])))
        fea = list(dict(((&#34;type&#34;,&#34;Feature&#34;), (&#34;id&#34;, i), (&#34;geometry&#34;, lis[i]))) for i in range(len(geo[&#39;coordinates&#39;])))
        return json.dumps(dict(((&#34;type&#34;,&#34;FeatureCollection&#34;), (&#34;features&#34;,fea))))            
    else: return &#39;&#39;  </code></pre>
</details>
</dd>
<dt id="ES.ESObservation.Observation.nValueObs"><code class="name">var <span class="ident">nValueObs</span></code></dt>
<dd>
<div class="desc"><p>list : lenght of <code><a title="ES.ESObs.ESSetProperty" href="ESObs.html#ES.ESObs.ESSetProperty">ESSetProperty</a></code>, <code><a title="ES.ESObs.ESSetDatation" href="ESObs.html#ES.ESObs.ESSetDatation">ESSetDatation</a></code>,
<code><a title="ES.ESObs.ESSetLocation" href="ESObs.html#ES.ESObs.ESSetLocation">ESSetLocation</a></code>, <code><a title="ES.ESObs.ESSetResult" href="ESObs.html#ES.ESObs.ESSetResult">ESSetResult</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property 
def nValueObs(self):
    &#39;&#39;&#39;list : lenght of `ES.ESObs.ESSetProperty`, `ES.ESObs.ESSetDatation`, 
            `ES.ESObs.ESSetLocation`, `ES.ESObs.ESSetResult`.&#39;&#39;&#39;
    nPrp = nDat = nLoc = nRes = 0
    if self.setResult   != None: nRes = self.setResult.nValue
    if self.setLocation != None: nLoc = self.setLocation.nValue
    if self.setDatation != None: nDat = self.setDatation.nValue
    if self.setProperty != None: nPrp = self.setProperty.nValue
    return [nPrp, nDat, nLoc, nRes]</code></pre>
</details>
</dd>
<dt id="ES.ESObservation.Observation.option"><code class="name">var <span class="ident">option</span></code></dt>
<dd>
<div class="desc"><p>Dictionnary with options.</p></div>
</dd>
<dt id="ES.ESObservation.Observation.score"><code class="name">var <span class="ident">score</span></code></dt>
<dd>
<div class="desc"><p>Integer : Number of ESValue for each ESObs. For example, 122 means one PropertyValue (1),
several LocationValue (2), several DatationValue (2).</p></div>
</dd>
<dt id="ES.ESObservation.Observation.setDatation"><code class="name">var <span class="ident">setDatation</span></code></dt>
<dd>
<div class="desc"><p>object <code><a title="ES.ESObs.ESSetDatation" href="ESObs.html#ES.ESObs.ESSetDatation">ESSetDatation</a></code> if exists, None otherwise.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def setDatation(self):  
    &#39;&#39;&#39;object `ES.ESObs.ESSetDatation` if exists, None otherwise.&#39;&#39;&#39;
    return self.element(ES.dat_classES)</code></pre>
</details>
</dd>
<dt id="ES.ESObservation.Observation.setLocation"><code class="name">var <span class="ident">setLocation</span></code></dt>
<dd>
<div class="desc"><p>object <code><a title="ES.ESObs.ESSetLocation" href="ESObs.html#ES.ESObs.ESSetLocation">ESSetLocation</a></code> if exists, None otherwise.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def setLocation(self):
    &#39;&#39;&#39;object `ES.ESObs.ESSetLocation` if exists, None otherwise.&#39;&#39;&#39;
    return self.element(ES.loc_classES)</code></pre>
</details>
</dd>
<dt id="ES.ESObservation.Observation.setProperty"><code class="name">var <span class="ident">setProperty</span></code></dt>
<dd>
<div class="desc"><p>object <code><a title="ES.ESObs.ESSetProperty" href="ESObs.html#ES.ESObs.ESSetProperty">ESSetProperty</a></code> if exists, None otherwise.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def setProperty(self):  
    &#39;&#39;&#39;object `ES.ESObs.ESSetProperty` if exists, None otherwise.&#39;&#39;&#39;
    return self.element(ES.prp_classES)</code></pre>
</details>
</dd>
<dt id="ES.ESObservation.Observation.setResult"><code class="name">var <span class="ident">setResult</span></code></dt>
<dd>
<div class="desc"><p>object <code><a title="ES.ESObs.ESSetResult" href="ESObs.html#ES.ESObs.ESSetResult">ESSetResult</a></code> if exists, None otherwise.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def setResult(self):  
    &#39;&#39;&#39;object `ES.ESObs.ESSetResult` if exists, None otherwise.&#39;&#39;&#39;
    return self.element(ES.res_classES)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="ES.ESObservation.Observation.addAttributes"><code class="name flex">
<span>def <span class="ident">addAttributes</span></span>(<span>self, js)</span>
</code></dt>
<dd>
<div class="desc"><p>Add informations attached to <code><a title="ES.ESObservation.Observation" href="#ES.ESObservation.Observation">Observation</a></code></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>js</code></strong> :&ensp;<code>Dictionnary</code></dt>
<dd>Keys are Observation keys or users keys.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addAttributes(self, js):
    &#39;&#39;&#39;
    Add informations attached to `ES.ESObservation.Observation`

    Parameters
    ----------
    js : Dictionnary
        Keys are Observation keys or users keys.
    Returns
    -------
    None
    &#39;&#39;&#39;
    if type(js) != dict: return
    for k, v in js.items():
        if isESAtt(ES.obs_classES, k) or isUserAtt(k): self.mAtt[k] = v
        if k == ES.parameter: 
            try:  self.parameter = json.dumps(v)
            except:  self.parameter = &#34;null&#34;</code></pre>
</details>
</dd>
<dt id="ES.ESObservation.Observation.addESObs"><code class="name flex">
<span>def <span class="ident">addESObs</span></span>(<span>self, js, classES=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a new <code><a title="ES.ESObs" href="ESObs.html">ES.ESObs</a></code> attached to <code><a title="ES.ESObservation.Observation" href="#ES.ESObservation.Observation">Observation</a></code>.
The ES.ESObs child class is defined by classES or if None by the js structure.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>js</code></strong> :&ensp;<code><a title="ES.ESObs" href="ESObs.html">ES.ESObs</a> compatible type</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>classES</code></strong> :&ensp;<code>string</code>, optional</dt>
<dd>value of the ES.ESObs ESclass attributes. The default is None.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addESObs(self, js, classES = None) :
    &#39;&#39;&#39;
    Add a new `ES.ESObs` attached to `ES.ESObservation.Observation`. 
    The ES.ESObs child class is defined by classES or if None by the js structure.

    Parameters
    ----------
    js : ES.ESObs compatible type
    classES : string, optional
        value of the ES.ESObs ESclass attributes. The default is None.
    Returns
    -------
    None.

    &#39;&#39;&#39;
    if classES in (None, ES.dat_classES) and isESObs(ES.dat_classES, js): 
        ESSetDatation(pObs=self, jObj=js)
    if classES in (None, ES.loc_classES) and isESObs(ES.loc_classES, js): 
        ESSetLocation(pObs=self, jObj=js)
    if classES in (None, ES.prp_classES) and isESObs(ES.prp_classES, js): 
        ESSetProperty(pObs=self, jObj=js)
    if classES in (None, ES.res_classES) and isESObs(ES.res_classES, js): 
        ESSetResult  (pObs=self, jObj=js)</code></pre>
</details>
</dd>
<dt id="ES.ESObservation.Observation.addListResultValue"><code class="name flex">
<span>def <span class="ident">addListResultValue</span></span>(<span>self, listEsValue)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a list of new <code><a title="ES.ESValue.ResultValue" href="ESValue.html#ES.ESValue.ResultValue">ResultValue</a></code> in the <code><a title="ES.ESObs.ESSetResult" href="ESObs.html#ES.ESObs.ESSetResult">ESSetResult</a></code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>listEsValue</code></strong> :&ensp;<code>list</code> of <code><a title="ES.ESValue.ResultValue" href="ESValue.html#ES.ESValue.ResultValue">ResultValue</a></code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addListResultValue(self, listEsValue):
    &#39;&#39;&#39;
    Add a list of new `ES.ESValue.ResultValue` in the `ES.ESObs.ESSetResult`.

    Parameters
    ----------
    listEsValue : list of `ES.ESValue.ResultValue`
    Returns
    -------
    None
    &#39;&#39;&#39;
    if type(listEsValue) != list : return
    if self.element(ES.res_valueType) == None: resSet = ESSetResult(pObs=self)
    else: resSet = self.setResult
    for val in listEsValue : resSet.addValue(ResultValue, ResultValue(val))
        #self.addResultValue(ResultValue(val) )</code></pre>
</details>
</dd>
<dt id="ES.ESObservation.Observation.addListValue"><code class="name flex">
<span>def <span class="ident">addListValue</span></span>(<span>self, ValueClass, listEsValue)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a list of new <code><a title="ES.ESValue" href="ESValue.html">ES.ESValue</a></code> in a <code><a title="ES.ESValue.ESSet" href="ESValue.html#ES.ESValue.ESSet">ESSet</a></code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ValueClass</code></strong> :&ensp;<code>name</code> of <code>the selected class <a title="ES.ESValue" href="ESValue.html">ES.ESValue</a></code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>listEsValue</code></strong> :&ensp;<code>list</code> of <code><a title="ES.ESValue" href="ESValue.html">ES.ESValue</a></code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addListValue(self, ValueClass, listEsValue):
    &#39;&#39;&#39;
    Add a list of new `ES.ESValue` in a `ES.ESValue.ESSet`.

    Parameters
    ----------
    ValueClass : name of the selected class ES.ESValue
    listEsValue : list of ES.ESValue
    Returns
    -------
    None
    &#39;&#39;&#39;
    for val in listEsValue : self.addValue(ValueClass(val) )</code></pre>
</details>
</dd>
<dt id="ES.ESObservation.Observation.addListValueObservation"><code class="name flex">
<span>def <span class="ident">addListValueObservation</span></span>(<span>self, listVal, listIdat, listIloc, listIprp)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a list of new <code><a title="ES.ESValue.ResultValue" href="ESValue.html#ES.ESValue.ResultValue">ResultValue</a></code> </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>listVal</code></strong> :&ensp;<code>list</code> of <code><a title="ES.ESValue.ResultValue" href="ESValue.html#ES.ESValue.ResultValue">ResultValue</a> compatible type</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>listIdat</code></strong>, <strong><code>listIloc</code></strong>, <strong><code>listIprp</code></strong> :&ensp;<code>list</code> of <code>integer in <a title="ES.ESValue.ESIndexValue" href="ESValue.html#ES.ESValue.ESIndexValue">ESIndexValue</a></code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addListValueObservation(self, listVal, listIdat, listIloc, listIprp):
    &#39;&#39;&#39;
    Add a list of new `ES.ESValue.ResultValue` 
    
    Parameters
    ----------
    listVal : list of ES.ESValue.ResultValue compatible type
    listIdat, listIloc, listIprp : list of integer in ES.ESValue.ESIndexValue
    Returns
    -------
    None
    &#39;&#39;&#39;
    if len(listVal)==len(listIdat)==len(listIloc)==len(listIprp) :
        for i in range(len(listVal)) :
            self.addResultValue(ResultValue(listVal[i], [listIdat[i], listIloc[i], listIprp[i]]))</code></pre>
</details>
</dd>
<dt id="ES.ESObservation.Observation.addResultValue"><code class="name flex">
<span>def <span class="ident">addResultValue</span></span>(<span>self, esValue)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a new <code><a title="ES.ESValue.ResultValue" href="ESValue.html#ES.ESValue.ResultValue">ResultValue</a></code> in the <code><a title="ES.ESObs.ESSetResult" href="ESObs.html#ES.ESObs.ESSetResult">ESSetResult</a></code></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>esValue</code></strong> :&ensp;<code><a title="ES.ESValue.ResultValue" href="ESValue.html#ES.ESValue.ResultValue">ResultValue</a></code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Int : last index in the <code><a title="ES.ESValue.ESSet" href="ESValue.html#ES.ESValue.ESSet">ESSet</a></code> valueList.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addResultValue(self, esValue):
    &#39;&#39;&#39;
    Add a new `ES.ESValue.ResultValue` in the `ES.ESObs.ESSetResult`

    Parameters
    ----------
    esValue : ES.ESValue.ResultValue
    Returns
    -------
    Int : last index in the `ES.ESValue.ESSet` valueList.
    &#39;&#39;&#39;
    return self.element(ES.res_valueType).addValue(ResultValue, esValue)</code></pre>
</details>
</dd>
<dt id="ES.ESObservation.Observation.addValue"><code class="name flex">
<span>def <span class="ident">addValue</span></span>(<span>self, esValue)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a new <code><a title="ES.ESValue" href="ESValue.html">ES.ESValue</a></code> in the <code><a title="ES.ESValue.ESSet" href="ESValue.html#ES.ESValue.ESSet">ESSet</a></code></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>esValue</code></strong> :&ensp;<code><a title="ES.ESValue" href="ESValue.html">ES.ESValue</a></code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Int : last index in the <code><a title="ES.ESValue.ESSet" href="ESValue.html#ES.ESValue.ESSet">ESSet</a></code> valueList.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addValue(self, esValue):
    &#39;&#39;&#39;
    Add a new `ES.ESValue` in the `ES.ESValue.ESSet`

    Parameters
    ----------
    esValue : ES.ESValue
    Returns
    -------
    Int : last index in the `ES.ESValue.ESSet` valueList.
    &#39;&#39;&#39;
    if type(esValue)== PropertyValue:
        if self.element(ES.prp_valueType) == None: ESSetProperty(pObs=self)
        return self.element(ES.prp_valueType).addValue(PropertyValue, esValue)
    elif type(esValue)== LocationValue:
        if self.element(ES.loc_valueType) == None: ESSetLocation(pObs=self)
        return self.element(ES.loc_valueType).addValue(LocationValue, esValue)
    elif type(esValue)== DatationValue:
        if self.element(ES.dat_valueType) == None: ESSetDatation(pObs=self)
        return self.element(ES.dat_valueType).addValue(DatationValue, esValue)
    else: return 0</code></pre>
</details>
</dd>
<dt id="ES.ESObservation.Observation.addValueObservation"><code class="name flex">
<span>def <span class="ident">addValueObservation</span></span>(<span>self, val, idat, iloc, iprp)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a new <code><a title="ES.ESValue.ResultValue" href="ESValue.html#ES.ESValue.ResultValue">ResultValue</a></code> </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>val</code></strong> :&ensp;<code><a title="ES.ESValue.ResultValue" href="ESValue.html#ES.ESValue.ResultValue">ResultValue</a> compatible type</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>idat</code></strong>, <strong><code>iloc</code></strong>, <strong><code>iprp</code></strong> :&ensp;<code>integer, <a title="ES.ESValue.ESIndexValue" href="ESValue.html#ES.ESValue.ESIndexValue">ESIndexValue</a></code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Int : last index in the <code><a title="ES.ESValue.ESSet" href="ESValue.html#ES.ESValue.ESSet">ESSet</a></code> valueList.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addValueObservation(self, val, idat, iloc, iprp):
    &#39;&#39;&#39;
    Add a new `ES.ESValue.ResultValue` 
    
    Parameters
    ----------
    val : ES.ESValue.ResultValue compatible type
    idat, iloc, iprp : integer, ES.ESValue.ESIndexValue
    Returns
    -------
    Int : last index in the `ES.ESValue.ESSet` valueList.
    &#39;&#39;&#39;
    if self.element(ES.res_valueType) == None: ESSetResult(pObs=self)
    return self.addResultValue(ResultValue(val, [idat, iloc, iprp]))</code></pre>
</details>
</dd>
<dt id="ES.ESObservation.Observation.addValueSensor"><code class="name flex">
<span>def <span class="ident">addValueSensor</span></span>(<span>self, resVal, datVal, locVal, nprp)</span>
</code></dt>
<dd>
<div class="desc"><p>Add <code><a title="ES.ESValue.ResultValue" href="ESValue.html#ES.ESValue.ResultValue">ResultValue</a></code>,
<code><a title="ES.ESValue.DatationValue" href="ESValue.html#ES.ESValue.DatationValue">DatationValue</a></code>,
<code><a title="ES.ESValue.LocationValue" href="ESValue.html#ES.ESValue.LocationValue">LocationValue</a></code>
for a defined property.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>resVal</code></strong> :&ensp;<code><a title="ES.ESValue.ResultValue" href="ESValue.html#ES.ESValue.ResultValue">ResultValue</a> compatible type, </code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>datVal</code></strong> :&ensp;<code><a title="ES.ESValue.DatationValue" href="ESValue.html#ES.ESValue.DatationValue">DatationValue</a> compatible type</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>locVal</code></strong> :&ensp;<code><a title="ES.ESValue.LocationValue" href="ESValue.html#ES.ESValue.LocationValue">LocationValue</a> compatible type</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>nprp</code></strong> :&ensp;<code>integer, index</code> of <code>the <a title="ES.ESValue.PropertyValue" href="ESValue.html#ES.ESValue.PropertyValue">PropertyValue</a></code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Int : last index in the <code><a title="ES.ESValue.ESSet" href="ESValue.html#ES.ESValue.ESSet">ESSet</a></code> valueList.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addValueSensor(self, resVal, datVal, locVal, nprp):
    &#39;&#39;&#39;
    Add `ES.ESValue.ResultValue`,  `ES.ESValue.DatationValue`,  `ES.ESValue.LocationValue`
    for a defined property.

    Parameters
    ----------
    resVal : ES.ESValue.ResultValue compatible type, 
    datVal : ES.ESValue.DatationValue compatible type
    locVal : ES.ESValue.LocationValue compatible type
    nprp : integer, index of the ES.ESValue.PropertyValue
    Returns
    -------
    Int : last index in the `ES.ESValue.ESSet` valueList.

    &#39;&#39;&#39;
    return self.addValueObservation(resVal, self.addValue(DatationValue(datVal)), 
                                    self.addValue(LocationValue(locVal)), nprp)</code></pre>
</details>
</dd>
<dt id="ES.ESObservation.Observation.choropleth"><code class="name flex">
<span>def <span class="ident">choropleth</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def choropleth(self):
    if self.setResult.dim == 1 or self.setResult.dim // 10 == 1:
        m = folium.Map(location=self.setLocation.valueList[0].coorInv, zoom_start=6)
        folium.PolyLine(
            list(self.setLocation.valueList[i].coorInv for i in range(len(self.setLocation.valueList)))
        ).add_to(m)
        folium.Choropleth(
            geo_data=self.jsonFeature,
            name=&#34;test choropleth&#34;,
            data=self.to_dataFrame(),
            key_on=&#34;feature.id&#34;,
            #columns=[&#34;point&#34;, json.loads(self.setProperty[0].json(False))[ES.prp_propType]],
            columns=[&#34;point&#34;, json.loads(self.setProperty[0].json(ES.mOption))[ES.prp_propType]],
            fill_color=&#34;BuGn&#34;,
            fill_opacity=0.7,
            line_opacity=0.2,
            legend_name=&#34;test choropleth&#34;
        ).add_to(m)
        folium.LayerControl().add_to(m)
        return m
    return None</code></pre>
</details>
</dd>
<dt id="ES.ESObservation.Observation.extend"><code class="name flex">
<span>def <span class="ident">extend</span></span>(<span>self, obs)</span>
</code></dt>
<dd>
<div class="desc"><p>Copy <code><a title="ES.ESObs" href="ESObs.html">ES.ESObs</a></code> from obs to self (if it daesn't exist)</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>obs</code></strong> :&ensp;<code>object <a title="ES.ESObservation.Observation" href="#ES.ESObservation.Observation">Observation</a> to copy</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extend(self, obs):
    &#39;&#39;&#39;
    Copy `ES.ESObs` from obs to self (if it daesn&#39;t exist)

    Parameters
    ----------
    obs : object ES.ESObservation.Observation to copy
    Returns
    -------
    None.
    &#39;&#39;&#39;
    for p in obs.pComposant :
        if self.element(p.classES) == None : self.addComposant(p)
    self.majType()    </code></pre>
</details>
</dd>
<dt id="ES.ESObservation.Observation.from_bytes"><code class="name flex">
<span>def <span class="ident">from_bytes</span></span>(<span>self, byt)</span>
</code></dt>
<dd>
<div class="desc"><p>Complete an empty <code><a title="ES.ESObservation.Observation" href="#ES.ESObservation.Observation">Observation</a></code> with binary data. </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>byt</code></strong> :&ensp;<code>binary representation</code> of <code>an <a title="ES.ESObservation.Observation" href="#ES.ESObservation.Observation">Observation</a></code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_bytes(self, byt):
    &#39;&#39;&#39;
    Complete an empty `ES.ESObservation.Observation` with binary data. 
    
    Parameters
    -------
    byt : binary representation of an ES.ESObservation.Observation
    Returns
    -------
    None
    &#39;&#39;&#39;
    code_ob = (byt[0] &amp; 0b11100000) &gt;&gt; 5
    self.mAtt[ES.obs_reference] = byt[0] &amp; 0b00011111
    if code_ob != ES.codeb[self.classES]: return
    idx = 1
    while idx &lt; byt.__len__() :
        code_el = (byt[idx] &amp; 0b11100000) &gt;&gt; 5
        #forma =  byt[idx] &amp; 0b00001111
        if   code_el == 1: es = ESSetLocation(pObs=self)
        elif code_el == 2: es = ESSetDatation(pObs=self)
        elif code_el == 3: es = ESSetProperty(pObs=self)
        elif code_el &lt; 6:
            es = ESSetResult(pObs=self)
            if code_el == 5: 
                propList = [self.setProperty.valueList[i].pType 
                        for i in range(self.setProperty.nValue)]
            else :
                es.from_bytes(byt[idx:], [])
                es.majIndex(es.nValue, self.setProperty.nValue, 
                        self.setDatation.nValue, self.setLocation.nValue)
                propList = [self.setProperty.valueList[es.valueList[i].ind[2]].pType
                        for i in range(es.nValue)]
                es.__init__()
        else: return
        if code_el &lt; 4 : 
            idx += es.from_bytes(byt[idx:])
        else :
            idx += es.from_bytes(byt[idx:], propList)</code></pre>
</details>
</dd>
<dt id="ES.ESObservation.Observation.full"><code class="name flex">
<span>def <span class="ident">full</span></span>(<span>self, maj=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Add empty <code><a title="ES.ESValue.ResultValue" href="ESValue.html#ES.ESValue.ResultValue">ResultValue</a></code> to have a 'complete' <code><a title="ES.ESObservation.Observation" href="#ES.ESObservation.Observation">Observation</a></code></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>maj</code></strong> :&ensp;<code>boolean</code>, optional</dt>
<dd>If True, add value to Observation, else return listValue. The default is True.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>empty list if maj is True, else <code><a title="ES.ESObs.ESSetResult" href="ESObs.html#ES.ESObs.ESSetResult">ESSetResult</a></code> listValue.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def full(self, maj=True) : 
    &#39;&#39;&#39;
    Add empty `ES.ESValue.ResultValue` to have a &#39;complete&#39; `ES.ESObservation.Observation`

    Parameters
    ----------
    maj : boolean, optional
        If True, add value to Observation, else return listValue. The default is True.
    Returns
    -------
    empty list if maj is True, else `ES.ESObs.ESSetResult` listValue.
    &#39;&#39;&#39;
    return self.setResult.full(maj)</code></pre>
</details>
</dd>
<dt id="ES.ESObservation.Observation.iloc"><code class="name flex">
<span>def <span class="ident">iloc</span></span>(<span>self, idat, iloc, iprp)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the <code><a title="ES.ESValue" href="ESValue.html">ES.ESValue</a></code> values for an <code><a title="ES.ESValue.ESIndexValue" href="ESValue.html#ES.ESValue.ESIndexValue">ESIndexValue</a></code>. </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>idat</code></strong>, <strong><code>iloc</code></strong>, <strong><code>iprp</code></strong> :&ensp;<code><a title="ES.ESValue.ESIndexValue" href="ESValue.html#ES.ESValue.ESIndexValue">ESIndexValue</a></code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dictionnary, <a title="ES.ESValue" href="ESValue.html">ES.ESValue</a></code> of <code>each <a title="ES.ESObs" href="ESObs.html">ES.ESObs</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def iloc(self, idat, iloc, iprp):
    &#39;&#39;&#39;
    Return the `ES.ESValue` values for an `ES.ESValue.ESIndexValue`. 

    Parameters
    ----------
    idat, iloc, iprp : ES.ESValue.ESIndexValue

    Returns
    -------
    dictionnary, ES.ESValue of each ES.ESObs
    &#39;&#39;&#39;
    if not self.complet : return dict()
    dic = dict()
    if self.setDatation != None and idat &lt; self.setDatation.nValue: 
        dic[ES.dat_classES] = self.setDatation.valueList[idat].json(self.option)
    if self.setLocation != None and iloc &lt; self.setLocation.nValue: 
        dic[ES.loc_classES] = self.setLocation.valueList[iloc].json(self.option)
    if self.setProperty != None and iprp &lt; self.setProperty.nValue: 
        dic[ES.prp_classES] = self.setProperty.valueList[iprp].json(self.option)
    if self.setResult != None : 
        for i in range(self.setResult.nValue) : 
            if self.setResult.valueList[i].ind == [idat, iloc, iprp] : 
                dic[ES.res_classES] = self.setResult.valueList[i].json(self.option)
    return dic</code></pre>
</details>
</dd>
<dt id="ES.ESObservation.Observation.json"><code class="name flex">
<span>def <span class="ident">json</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Export in Json format. </p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>string</code></strong> :&ensp;<code>Json string</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def json(self): 
    &#39;&#39;&#39;
    Export in Json format. 
    
    Returns
    -------
    string : Json string 

    &#39;&#39;&#39;
    if self.option[&#34;json_elt_type&#34;]: option_type = 1
    else: option_type = 0
    js =&#34;&#34;
    if self.option[&#34;json_obs_val&#34;]: js = &#34;{&#34;
    js += &#39;&#34;&#39; + ES.type +&#39;&#34;:&#34;&#39; + ES.obs_classES +&#39;&#34;,&#39;
    if self.mAtt[ES.obs_id] != &#34;null&#34;: js += &#39;&#34;&#39; + ES.obs_id + &#39;&#34;:&#34;&#39; + self.mAtt[ES.obs_id] + &#39;&#34;,&#39;
    if self.option[&#34;json_obs_attrib&#34;]: js += &#39;&#34;&#39; + ES.obs_attributes + &#39;&#34;:{&#39;
    js += self._jsonAtt(option_type)
    for cp in self.pComposant:
        js += cp.json(self.option)
        if js[-1] != &#39;,&#39;: js += &#34;,&#34;
    if self.option[&#34;json_param&#34;] and self.parameter != &#34;null&#34;: 
        js += &#39;&#34;&#39; + ES.parameter +&#39;&#34;:&#39; + self.parameter + &#39;,&#39;
    jsInfo = self._jsonInfo(self.option[&#34;json_info_type&#34;], self.option[&#34;json_info_nval&#34;],
                        self.option[&#34;json_info_box&#34;], self.option[&#34;json_info_autre&#34;])
    if jsInfo != &#34;&#34; : js +=  jsInfo + &#39;,&#39;
    if js[-1] == &#39;,&#39;: js = js[:-1]
    if self.option[&#34;json_obs_attrib&#34;]: js += &#34;}&#34;
    if self.option[&#34;json_obs_val&#34;]:    js += &#34;}&#34;
    return js</code></pre>
</details>
</dd>
<dt id="ES.ESObservation.Observation.majList"><code class="name flex">
<span>def <span class="ident">majList</span></span>(<span>self, ValueClass, listVal, info='name')</span>
</code></dt>
<dd>
<div class="desc"><p>Modify a list of one attribute (name or value) in an <code><a title="ES.ESObs" href="ESObs.html">ES.ESObs</a></code></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ValueClass</code></strong> :&ensp;<code>class <a title="ES.ESObs" href="ESObs.html">ES.ESObs</a> </code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>listVal</code></strong> :&ensp;<code>list</code> of <code>values</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>info</code></strong> :&ensp;<code>string</code>, optional<code>, </code></dt>
<dd>Attribute. The default is 'name'.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def majList(self, ValueClass, listVal, info = &#39;name&#39;):
    &#39;&#39;&#39;
    Modify a list of one attribute (name or value) in an `ES.ESObs`

    Parameters
    ----------
    ValueClass : class ES.ESObs 
    listVal : list of values
    info : string, optional, 
        Attribute. The default is &#39;name&#39;. 
    Returns
    -------
    None
    &#39;&#39;&#39;
    if ValueClass == DatationValue and self.setDatation != None : 
        if info == &#39;name&#39;: self.setDatation.majListName(listVal)
        else : self.setDatation.majListValue(ValueClass, listVal, info == &#39;base&#39;)
    elif ValueClass == LocationValue and self.setLocation != None : 
        if info == &#39;name&#39;: self.setLocation.majListName(listVal)
        else : self.setLocation.majListValue(ValueClass, listVal, info == &#39;base&#39;)
    elif ValueClass == PropertyValue and self.setProperty != None : 
        if info == &#39;name&#39;: self.setProperty.majListName(listVal)</code></pre>
</details>
</dd>
<dt id="ES.ESObservation.Observation.majType"><code class="name flex">
<span>def <span class="ident">majType</span></span>(<span>self, order='dlp')</span>
</code></dt>
<dd>
<div class="desc"><p>Generate the <code><a title="ES.ESObservation.Observation" href="#ES.ESObservation.Observation">Observation</a></code> and associates <code><a title="ES.ESObs" href="ESObs.html">ES.ESObs</a></code>
characteristics (e.g. complet, score, dim&hellip;) and the index for <code><a title="ES.ESValue.ResultValue" href="ESValue.html#ES.ESValue.ResultValue">ResultValue</a></code> data.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>order</code></strong> :&ensp;<code>String</code>, optional</dt>
<dd>Result ordering for result without index. The order is define with
three letters : l (location), d (datation), p (property). The default is 'dlp'.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def majType(self, order = &#39;dlp&#39;):
    &#39;&#39;&#39;
    Generate the `ES.ESObservation.Observation` and associates `ES.ESObs` 
    characteristics (e.g. complet, score, dim...) and the index for `ES.ESValue.ResultValue` data.
    
    Parameters
    ----------
    order : String, optional
        Result ordering for result without index. The order is define with
        three letters : l (location), d (datation), p (property). The default is &#39;dlp&#39;.
    Returns
    -------
    None.
    &#39;&#39;&#39;
    [nprp, ndat, nloc, nRes] = self.nValueObs
    nPrp = max(1, nprp)
    nDat = max(1, ndat)
    nLoc = max(1, nloc)
    if len(order) == 3 : 
        self.complet = nRes == nLoc * nDat * nPrp \
                    or nRes == nDat * nPrp == nDat * nLoc \
                    or nRes == nLoc * nPrp == nLoc * nDat \
                    or nRes == nPrp * nLoc == nPrp * nDat \
                    or nRes == nLoc == nDat == nPrp
    if len(order) == 2 : 
        self.complet = nRes == nDat * nPrp == nDat * nLoc \
                    or nRes == nLoc * nPrp == nLoc * nDat \
                    or nRes == nPrp * nLoc == nPrp * nDat \
                    or nRes == nLoc == nDat == nPrp
    if len(order) == 1 : 
        self.complet = nRes == nLoc == nDat == nPrp
    
    if self.complet: self.setResult.majIndex(nRes, nPrp, nDat, nLoc, order)
    if self.setResult   != None: self.setResult.  analyse()
    if self.setLocation != None: self.setLocation.analyse()
    if self.setDatation != None: self.setDatation.analyse()
    self._typeObs()</code></pre>
</details>
</dd>
<dt id="ES.ESObservation.Observation.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self, switch=False, line=True, sort=True, size=5, marker='o')</span>
</code></dt>
<dd>
<div class="desc"><p>This function visualize an <code><a title="ES.ESObservation.Observation" href="#ES.ESObservation.Observation">Observation</a></code> with line or colormesh.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>switch</code></strong> :&ensp;<code>Boolean</code>, optional</dt>
<dd>Switch between x and y axis. The default is False.</dd>
<dt><strong><code>line</code></strong> :&ensp;<code>Boolean</code>, optional</dt>
<dd>Choice line or colormesh. The default is True.</dd>
<dt><strong><code>sort</code></strong> :&ensp;<code>Boolean</code>, optional</dt>
<dd>Sort along an axis. The default is True.</dd>
<dt><strong><code>size</code></strong> :&ensp;<code>Integer</code>, optional</dt>
<dd>Size of the figure to plot. The default is 5.</dd>
<dt><strong><code>marker</code></strong> :&ensp;<code>Character</code>, optional</dt>
<dd>Synbol for each point. The default is 'o'.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self, switch = False, line = True, sort = True, size = 5, marker=&#39;o&#39;):
    &#39;&#39;&#39;
    This function visualize an `ES.ESObservation.Observation` with line or colormesh.
    
    Parameters
    ----------
    switch : Boolean, optional
        Switch between x and y axis. The default is False.
    line : Boolean, optional
        Choice line or colormesh. The default is True.
    sort : Boolean, optional
        Sort along an axis. The default is True.
    size : Integer, optional
        Size of the figure to plot. The default is 5.
    marker : Character, optional
        Synbol for each point. The default is &#39;o&#39;.
    Returns
    -------
    None.
    &#39;&#39;&#39;
    if self.setResult.getMaxIndex() == -1 : return
    obx = self.to_xarray(numeric = True, complet=True, sort=sort)
    if len(obx.dims) == 1:
            obx.plot.line(x=obx.dims[0]+&#39;str&#39;, size=size, marker=marker)
    elif len(obx.dims) == 2:
        order = [0,1]
        ext = [&#39;&#39;, &#39;&#39;]
        for i in (0,1):
            if obx.dims[i] == &#39;dat&#39; : ext[i] = &#39;str&#39;
            elif str(obx.coords[obx.dims[i]].dtype)[0] != &#39;i&#39;: ext[i] = &#39;ran&#39;
        if switch : [order[0], order[1]] = [order[1], order[0]]
        if line :   
            obx.plot.line(x=obx.dims[order[0]]+ &#39;str&#39;, 
                          xticks=list(obx.coords[obx.dims[0]+&#39;str&#39;].values), 
                          #hue=obx.dims[order[1]]+ext[order[1]], size=size, marker=marker)
                          hue=obx.dims[order[1]]+&#39;str&#39;, size=size, marker=marker)
        else: 
            obx.plot(x=obx.dims[order[0]]+ext[order[0]], y=obx.dims[order[1]]+ext[order[1]], 
                     xticks=list(obx.coords[obx.dims[order[0]]+ext[order[0]]].values), 
                     yticks=list(obx.coords[obx.dims[order[1]]+ext[order[1]]].values), 
                     size = size)
        #τobg = self.to_geoDataFrame()
        #for i in range(len(self.setProperty)): obg.plot(obg.columns.array[i], legend=True)
    elif len(obx.dims) == 3:       
        if line :
            obx = obx.set_index(prp = &#34;prpstr&#34;, dat=&#34;datstr&#34;, loc=&#34;locstr&#34;)
            obx.sortby([&#34;dat&#34;,&#34;loc&#34;,&#34;prp&#34;]).plot.line(x=&#34;dat&#34;, col=&#34;prp&#34;, 
                                                      xticks=list(obx.coords[&#39;dat&#39;].values), 
                                                      col_wrap=2, size=size,
                                                      marker=marker)
        else :
            obx = obx.set_index(prp = &#34;prpstr&#34;, dat=&#34;datstr&#34;, loc=&#34;locran&#34;)
            obx.sortby([&#34;dat&#34;,&#34;loc&#34;,&#34;prp&#34;]).plot(x=&#34;dat&#34;, y=&#34;loc&#34;, col=&#34;prp&#34;, 
                                                 col_wrap=2, size=size, 
                                                 xticks=list(obx.coords[&#39;dat&#39;].values), 
                                                 yticks=list(obx.coords[&#39;loc&#39;].values))
        #obg = self.to_geoDataFrame()
        #for i in range(len(self.setProperty)): obg.plot(obg.columns.array[i], legend=True)
        #plt.legend(obx.coords[&#39;locstr&#39;].to_index().to_list())
    plt.show()</code></pre>
</details>
</dd>
<dt id="ES.ESObservation.Observation.sort"><code class="name flex">
<span>def <span class="ident">sort</span></span>(<span>self, order='dlp', cross=True, sort=[[], [], []])</span>
</code></dt>
<dd>
<div class="desc"><p>Modify the order of <code><a title="ES.ESValue" href="ESValue.html">ES.ESValue</a></code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>order</code></strong> :&ensp;<code>string</code>, optional</dt>
<dd>Ordered list to follow (d:dat, l:loc, p:prp). The default is 'dlp'.</dd>
<dt><strong><code>cross</code></strong> :&ensp;<code>boolean</code>, optional</dt>
<dd>If True, synchronize the order to have a less dimension. The default is True.</dd>
<dt><strong><code>sort</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>If empty, order is follow, if not sorting follows the list provided. The default is empty [[], [], []].</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sort(self, order = &#39;dlp&#39;, cross = True, sort = [[], [], []]): 
    &#39;&#39;&#39;
    Modify the order of `ES.ESValue`.

    Parameters
    ----------
    order : string, optional
        Ordered list to follow (d:dat, l:loc, p:prp). The default is &#39;dlp&#39;.
    cross : boolean, optional
        If True, synchronize the order to have a less dimension. The default is True.
    sort : list, optional
        If empty, order is follow, if not sorting follows the list provided. The default is empty [[], [], []].
    Returns
    -------
    None.
    &#39;&#39;&#39;
    if self.setResult == None or not self.setResult.isIndex() : return
    tr = tri = [[], [], []]
    orde = [ES.nax[order[0]], ES.nax[order[1]], ES.nax[order[2]]]
    # ordre de tri de chacun des axes
    for i in range(3) : tri[i] = self._sortSet(i, sort[i], False)
    npInd = np.array(self.setResult.vListIndex)
    if cross:
        for ax in self.setResult.axes : 
            if ax &gt; 100 : 
                tri[orde[1]] = self._sortAlign(npInd, tri[orde[0]], orde[0], orde[1])
                tri[orde[2]] = self._sortAlign(npInd, tri[orde[0]], orde[0], orde[2])
            elif ax &gt; 9 :
                (first, second) = (ax//10, ax%10)
                if orde.index(second) &lt; orde.index(first) : (first, second) = (second, first)
                tri[second] = self._sortAlign(npInd, tri[first], first, second)
    for i in range(3) : tr[i] = self._sortSet(i, tri[i])
    for resVal in self.setResult.valueList :
        for i in range(3) : resVal.ind[i] = tr[i].index(resVal.ind[i])
    self.setResult.sort()</code></pre>
</details>
</dd>
<dt id="ES.ESObservation.Observation.to_bytes"><code class="name flex">
<span>def <span class="ident">to_bytes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Export in binary format. </p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>bytes</code></strong> :&ensp;<code>binary representation</code> of <code>the <a title="ES.ESObservation.Observation" href="#ES.ESObservation.Observation">Observation</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_bytes(self):
    &#39;&#39;&#39;
    Export in binary format. 
    
    Returns
    -------
    bytes : binary representation of the ES.ESObservation.Observation

    &#39;&#39;&#39;
    byt = bytes()
    code_el = ES.codeb[self.classES] 
    byt += struct.pack(&#39;&lt;B&#39;, (code_el &lt;&lt; 5) | self.mAtt[ES.obs_reference])
    if self.setProperty != None: 
        byt += self.setProperty.to_bytes(self.option[&#34;json_prp_name&#34;])
    if self.setLocation != None: 
        byt += self.setLocation.to_bytes(self.option[&#34;json_loc_name&#34;])
    if self.setDatation != None: 
        byt += self.setDatation.to_bytes(self.option[&#34;json_dat_name&#34;])
    if self.setResult != None: 
        propList = [self.setProperty.valueList[i].pType 
                    for i in range(self.setProperty.nValue)]
        byt += self.setResult.to_bytes(False, self.option[&#34;json_res_index&#34;], 
                                       self.option[&#34;bytes_res_format&#34;], propList)
    return byt</code></pre>
</details>
</dd>
<dt id="ES.ESObservation.Observation.to_dataFrame"><code class="name flex">
<span>def <span class="ident">to_dataFrame</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dataFrame(self):
    if self.setResult.dim &gt; 0 : return self.to_xarray(False).to_dataframe()
    else : return None</code></pre>
</details>
</dd>
<dt id="ES.ESObservation.Observation.to_xarray"><code class="name flex">
<span>def <span class="ident">to_xarray</span></span>(<span>self, dataArray=True, sort=True, complet=False, info=False, numeric=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert <code><a title="ES.ESObservation.Observation" href="#ES.ESObservation.Observation">Observation</a></code> to DataArray or DataSet with the smallest dimension. </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dataArray</code></strong> :&ensp;<code>Boolean</code>, optional</dt>
<dd>DataArray ou DataSet. The default is True.</dd>
<dt><strong><code>sort</code></strong> :&ensp;<code>Boolean</code>, optional</dt>
<dd>Sort along an axis. The default is True.</dd>
<dt><strong><code>complet</code></strong> :&ensp;<code>Boolean</code>, optional</dt>
<dd>Generate all the DataArray.Coords or only one. The default is False.</dd>
<dt><strong><code>info</code></strong> :&ensp;<code>Boolean</code>, optional</dt>
<dd>Generate a specific Coords with Observation characteristics. The default is False.</dd>
<dt><strong><code>numeric</code></strong> :&ensp;<code>Boolean</code>, optional</dt>
<dd>Generate a numeric DataArray.Values. The default is False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>xarray.DataArray or xarray.DataSet.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_xarray(self, dataArray = True, sort = True, complet = False, info = False, numeric = False):
    &#39;&#39;&#39;
    Convert `ES.ESObservation.Observation` to DataArray or DataSet with the smallest dimension. 
    
    Parameters
    ----------
    dataArray : Boolean, optional
        DataArray ou DataSet. The default is True.
    sort : Boolean, optional
        Sort along an axis. The default is True.
    complet : Boolean, optional
        Generate all the DataArray.Coords or only one. The default is False.
    info : Boolean, optional
        Generate a specific Coords with Observation characteristics. The default is False.
    numeric : Boolean, optional
        Generate a numeric DataArray.Values. The default is False.
    Returns
    -------
    xarray.DataArray or xarray.DataSet.
    &#39;&#39;&#39;
    if self.setResult.getMaxIndex() == -1 : return None
    if sort : self.sort()
    xList = self._xlist()
    attrs = self._xAttrs()
    coord = self._xCoord(xList, attrs, dataArray, complet, numeric = False)
    self.setResult.triAxe()
    dims = [ES.axes[ax] for ax in self.setResult.axes]
    if numeric  : xres = xList[&#39;resval&#39;]
    else        : xres = xList[&#39;res&#39;]
    if dataArray and info :
        return xr.DataArray(xres, coord, dims, attrs=attrs[&#39;info&#39;])
    elif dataArray and not info :
        return xr.DataArray(xres, coord, dims)
    return None</code></pre>
</details>
</dd>
<dt id="ES.ESObservation.Observation.voxel"><code class="name flex">
<span>def <span class="ident">voxel</span></span>(<span>self, sort=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Visualize <code><a title="ES.ESValue.ResultValue" href="ESValue.html#ES.ESValue.ResultValue">ResultValue</a></code> in a cube with voxels.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>sort</code></strong> :&ensp;<code>Boolean</code>, optional</dt>
<dd>Sort along axis. The default is False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def voxel(self, sort=False):
    &#39;&#39;&#39;
    Visualize `ES.ESValue.ResultValue` in a cube with voxels.
    
    Parameters
    ----------
    sort : Boolean, optional
        Sort along axis. The default is False.
    Returns
    -------
    None.
    &#39;&#39;&#39;
    if self.setResult.getMaxIndex() == -1 : return        
    obc = copy.deepcopy(self)
    obc.setResult.full()
    obx = obc.to_xarray(numeric = True, complet=True, sort=sort)
    obp = obx&gt;=0
    obp.set_index(loc=&#39;locran&#39;, dat=&#39;datran&#39;, prp=&#39;prpran&#39;)
    ax = plt.figure().add_subplot(projection=&#39;3d&#39;)
    ax.voxels(obp, edgecolor=&#39;k&#39;)
    ax.set_xticks(np.arange(self.setDatation.nValue))
    ax.set_yticks(np.arange(self.setLocation.nValue))
    ax.set_zticks(np.arange(self.setProperty.nValue))
    ax.set(xlabel=&#39;dat (index)&#39;, ylabel=&#39;loc (index)&#39;, zlabel=&#39;prp (index)&#39;)
    plt.show()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ES" href="index.html">ES</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="ES.ESObservation.Observation" href="#ES.ESObservation.Observation">Observation</a></code></h4>
<ul class="">
<li><code><a title="ES.ESObservation.Observation.addAttributes" href="#ES.ESObservation.Observation.addAttributes">addAttributes</a></code></li>
<li><code><a title="ES.ESObservation.Observation.addESObs" href="#ES.ESObservation.Observation.addESObs">addESObs</a></code></li>
<li><code><a title="ES.ESObservation.Observation.addListResultValue" href="#ES.ESObservation.Observation.addListResultValue">addListResultValue</a></code></li>
<li><code><a title="ES.ESObservation.Observation.addListValue" href="#ES.ESObservation.Observation.addListValue">addListValue</a></code></li>
<li><code><a title="ES.ESObservation.Observation.addListValueObservation" href="#ES.ESObservation.Observation.addListValueObservation">addListValueObservation</a></code></li>
<li><code><a title="ES.ESObservation.Observation.addResultValue" href="#ES.ESObservation.Observation.addResultValue">addResultValue</a></code></li>
<li><code><a title="ES.ESObservation.Observation.addValue" href="#ES.ESObservation.Observation.addValue">addValue</a></code></li>
<li><code><a title="ES.ESObservation.Observation.addValueObservation" href="#ES.ESObservation.Observation.addValueObservation">addValueObservation</a></code></li>
<li><code><a title="ES.ESObservation.Observation.addValueSensor" href="#ES.ESObservation.Observation.addValueSensor">addValueSensor</a></code></li>
<li><code><a title="ES.ESObservation.Observation.bounds" href="#ES.ESObservation.Observation.bounds">bounds</a></code></li>
<li><code><a title="ES.ESObservation.Observation.choropleth" href="#ES.ESObservation.Observation.choropleth">choropleth</a></code></li>
<li><code><a title="ES.ESObservation.Observation.complet" href="#ES.ESObservation.Observation.complet">complet</a></code></li>
<li><code><a title="ES.ESObservation.Observation.extend" href="#ES.ESObservation.Observation.extend">extend</a></code></li>
<li><code><a title="ES.ESObservation.Observation.from_bytes" href="#ES.ESObservation.Observation.from_bytes">from_bytes</a></code></li>
<li><code><a title="ES.ESObservation.Observation.full" href="#ES.ESObservation.Observation.full">full</a></code></li>
<li><code><a title="ES.ESObservation.Observation.iloc" href="#ES.ESObservation.Observation.iloc">iloc</a></code></li>
<li><code><a title="ES.ESObservation.Observation.json" href="#ES.ESObservation.Observation.json">json</a></code></li>
<li><code><a title="ES.ESObservation.Observation.jsonFeature" href="#ES.ESObservation.Observation.jsonFeature">jsonFeature</a></code></li>
<li><code><a title="ES.ESObservation.Observation.majList" href="#ES.ESObservation.Observation.majList">majList</a></code></li>
<li><code><a title="ES.ESObservation.Observation.majType" href="#ES.ESObservation.Observation.majType">majType</a></code></li>
<li><code><a title="ES.ESObservation.Observation.nValueObs" href="#ES.ESObservation.Observation.nValueObs">nValueObs</a></code></li>
<li><code><a title="ES.ESObservation.Observation.option" href="#ES.ESObservation.Observation.option">option</a></code></li>
<li><code><a title="ES.ESObservation.Observation.plot" href="#ES.ESObservation.Observation.plot">plot</a></code></li>
<li><code><a title="ES.ESObservation.Observation.score" href="#ES.ESObservation.Observation.score">score</a></code></li>
<li><code><a title="ES.ESObservation.Observation.setDatation" href="#ES.ESObservation.Observation.setDatation">setDatation</a></code></li>
<li><code><a title="ES.ESObservation.Observation.setLocation" href="#ES.ESObservation.Observation.setLocation">setLocation</a></code></li>
<li><code><a title="ES.ESObservation.Observation.setProperty" href="#ES.ESObservation.Observation.setProperty">setProperty</a></code></li>
<li><code><a title="ES.ESObservation.Observation.setResult" href="#ES.ESObservation.Observation.setResult">setResult</a></code></li>
<li><code><a title="ES.ESObservation.Observation.sort" href="#ES.ESObservation.Observation.sort">sort</a></code></li>
<li><code><a title="ES.ESObservation.Observation.to_bytes" href="#ES.ESObservation.Observation.to_bytes">to_bytes</a></code></li>
<li><code><a title="ES.ESObservation.Observation.to_dataFrame" href="#ES.ESObservation.Observation.to_dataFrame">to_dataFrame</a></code></li>
<li><code><a title="ES.ESObservation.Observation.to_xarray" href="#ES.ESObservation.Observation.to_xarray">to_xarray</a></code></li>
<li><code><a title="ES.ESObservation.Observation.voxel" href="#ES.ESObservation.Observation.voxel">voxel</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>