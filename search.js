window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "ES", "modulename": "ES", "type": "module", "doc": "<p><strong><em>Environmental Sensing Package</em></strong></p>\n\n<p>Created on Fri Dec 24 15:21:14 2021</p>\n\n<p>@author: philippe@loco-labs.io</p>\n\n<h1 id=\"why-a-project-for-environmental-data\">Why a project for Environmental Data ?</h1>\n\n<p>The project was born from the following observations:</p>\n\n<ul>\n<li>there is no standard format (apart from the Environmental Sensing Service Bluetooth) \nused by the sensors to transmit the information (binary and textual),</li>\n<li>there is no data exchange format presenting at the same time a temporal, \nspatial and physical component (apart from file formats),</li>\n<li>we spend a lot of energy converting this type of data to make it usable.</li>\n</ul>\n\n<h1 id=\"the-environmental-sensing-project\">The Environmental Sensing project</h1>\n\n<p>The ES project is made of :</p>\n\n<ul>\n<li>A data model that makes it possible to represent elementary observations \n(a simple one-off measurement), complex observations (multi-dimensions), \ndetailed levels of representation (for example, the evolution of a plume of smoke).</li>\n<li>Data formats adapted to interfaces (binary payload for networks, json for requests \nor for NoSQL API, files)</li>\n<li>A library of connectors for different uses (sensors, database, storage, networks, etc.) \nin diff\u00e9rents languages (python, C++)</li>\n<li>Bidirectional interfaces to data processing tools (eg Numpy, Xarray, GIS).</li>\n</ul>\n\n<p>It allows to :</p>\n\n<ul>\n<li>Facilitate the use and sharing of environmental data</li>\n<li>Standardize both data acquisition equipment (sensors) and processing applications,</li>\n<li>Implement a software architecture replacing all coding / decoding operations \n(interfaces) by the use of standard connectors,</li>\n<li>Respect and rely on the main existing standards</li>\n<li>Collectively share and develop a set of open-source connectors responding to \nall situations (platform)</li>\n</ul>\n\n<h1 id=\"documentation\">Documentation</h1>\n\n<p>Documentation is available in other pages :</p>\n\n<ul>\n<li>The concepts of 'observation', 'indexed list' and 'ES value' are describe in \n<a href=\"https://github.com/loco-philippe/Environmental-Sensing/wiki\">this page</a>.</li>\n<li>The non-regression tests are at \n<a href=\"https://github.com/loco-philippe/Environmental-Sensing/tree/main/python/Tests\">this page</a></li>\n<li>Examples are \n<a href=\"https://github.com/loco-philippe/Environmental-Sensing/tree/main/python/Examples\">here</a></li>\n</ul>\n\n<p>Modules contain the following classes:</p>\n\n<ul>\n<li><p>ESObservation : </p>\n\n<ul>\n<li><code>ES.ESObservation</code></li>\n</ul></li>\n<li><p>ESValue : </p>\n\n<ul>\n<li><code>ES.ESValue</code>(<code>ES.ESValue.DatationValue</code>, <code>ES.ESValue.LocationValue</code>, <code>ES.ESValue.PropertyValue</code>,\n<code>ES.ESValue.NamedValue</code>, <code>ES.ESValue.ExternValue</code>, <code>ES.ESValue.ESValue</code>)</li>\n</ul></li>\n<li><p>Ilist : </p>\n\n<ul>\n<li><code>ES.ilist</code></li>\n</ul></li>\n<li><p>Iindex : </p>\n\n<ul>\n<li><code>ES.iindex</code></li>\n</ul></li>\n<li><p>TimeSlot : </p>\n\n<ul>\n<li><code>ES.timeslot</code></li>\n</ul></li>\n<li><p>ESconstante : </p>\n\n<ul>\n<li><code>ES.ESconstante</code>.</li>\n</ul></li>\n</ul>\n"}, {"fullname": "ES.ESObservation", "modulename": "ES.ESObservation", "type": "module", "doc": "<p>Created on Tue Aug  3 23:40:06 2021</p>\n\n<p>@author: Philippe Thomy</p>\n\n<p>An <code>ESObservation.Observation</code> is an object representing a set of information having\nspatial and temporal characteristics associated with measurable or observable\n properties.</p>\n\n<p>The Observation Object is built around three main bricks :</p>\n\n<ul>\n<li>Ilist Object which deal with indexing,</li>\n<li>ESValue Object which integrate the specificities of environmental data,</li>\n<li>Tools dedicated to particular domains (<a href=\"https://shapely.readthedocs.io/en/stable/manual.html\">Shapely</a> \nfor location, TimeSlot for Datation)</li>\n</ul>\n\n<p>The <code>ES.ESObservation</code> module contains the <code>Observation</code> class.</p>\n\n<p>Documentation is available in other pages :</p>\n\n<ul>\n<li>The concept of 'observation' is describe in \n<a href=\"https://github.com/loco-philippe/Environmental-Sensing/wiki/Observation\">this page</a>.</li>\n<li>The concept of 'indexed list' is describe in \n<a href=\"https://github.com/loco-philippe/Environmental-Sensing/wiki/Indexed-list\">this page</a>.</li>\n<li>The non-regression test are at \n<a href=\"https://github.com/loco-philippe/Environmental-Sensing/blob/main/python/Tests/test_observation.py\">this page</a></li>\n<li>The <a href=\"https://github.com/loco-philippe/Environmental-Sensing/tree/main/python/Examples/Observation\">examples</a></li>\n</ul>\n"}, {"fullname": "ES.ESObservation.Observation", "modulename": "ES.ESObservation", "qualname": "Observation", "type": "class", "doc": "<p>An <code>Observation</code> is made up of <code>ES.ilist</code> object which describe the axes of this object.</p>\n\n<p><em>Attributes (for @property see methods)</em> :</p>\n\n<ul>\n<li><strong>option</strong> : Dictionnary with options</li>\n<li><strong>ilist</strong> : Ilist object (data and axes)</li>\n<li><strong>name</strong> : textual description</li>\n<li><strong>mAtt</strong> : namedValue dictionnary (internal parameters)</li>\n<li><strong>parameter</strong> : namedValue dictionnary (external data)</li>\n</ul>\n\n<p>The methods defined in this class are :</p>\n\n<p><em>property (getters)</em></p>\n\n<ul>\n<li><code>Observation.axes</code></li>\n<li><code>Observation.bounds</code></li>\n<li><code>Observation.complet</code></li>\n<li><code>Observation.consistent</code></li>\n<li><code>Observation.dimension</code></li>\n<li><code>Observation.json</code></li>\n<li><code>Observation.jsonFeature</code></li>\n<li><code>Observation.nValueObs</code></li>\n<li><code>Observation.rate</code></li>\n<li><code>Observation.score</code></li>\n<li><code>Observation.setDatation</code></li>\n<li><code>Observation.setLocation</code></li>\n<li><code>Observation.setProperty</code></li>\n<li><code>Observation.setResult</code></li>\n<li><code>Observation.typeObs</code></li>\n</ul>\n\n<p><em>getters</em></p>\n\n<ul>\n<li><code>Observation.vList</code></li>\n<li><code>Observation.vListName</code></li>\n<li><code>Observation.vListSimple</code></li>\n<li><code>Observation.vListValue</code></li>\n</ul>\n\n<p><em>add value</em></p>\n\n<ul>\n<li><code>Observation.addAttributes</code></li>\n<li><code>Observation.addJson</code></li>\n<li><code>Observation.append</code></li>\n<li><code>Observation.appendList</code></li>\n<li><code>Observation.appendObs</code></li>\n</ul>\n\n<p><em>update value</em></p>\n\n<ul>\n<li><code>Observation.majList</code></li>\n<li><code>Observation.majValue</code></li>\n</ul>\n\n<p><em>selecting</em></p>\n\n<ul>\n<li><code>Observation.indexLoc</code></li>\n<li><code>Observation.iLoc</code></li>\n<li><code>Observation.iObsIndex</code></li>\n<li><code>Observation.loc</code></li>\n</ul>\n\n<p><em>management</em></p>\n\n<ul>\n<li><code>Observation.extend</code></li>\n<li><code>Observation.filter</code></li>\n<li><code>Observation.full</code></li>\n<li><code>Observation.sort</code></li>\n</ul>\n\n<p><em>visualization</em></p>\n\n<ul>\n<li><code>Observation.choropleth</code></li>\n<li><code>Observation.voxel</code></li>\n<li><code>Observation.plot</code></li>\n<li><code>Observation.view</code></li>\n</ul>\n\n<p><em>exports - imports</em></p>\n\n<ul>\n<li><code>Observation.from_file</code></li>\n<li><code>Observation.to_csv</code></li>\n<li><code>Observation.to_dataFrame</code></li>\n<li><code>Observation.to_json</code></li>\n<li><code>Observation.to_numpy</code></li>\n<li><code>Observation.to_file</code></li>\n<li><code>Observation.to_xarray</code></li>\n<li><code>Observation.to_bytes</code>              # \u00e0 voir</li>\n<li><code>Observation.from_bytes</code>            # \u00e0 voir</li>\n</ul>\n"}, {"fullname": "ES.ESObservation.Observation.__init__", "modulename": "ES.ESObservation", "qualname": "Observation.__init__", "type": "function", "doc": "<p>Several Observation creation modes :</p>\n\n<ul>\n<li>Observation(dictESValue1, dictESValue2, ...) where dictESValue = {ESValuename : value}</li>\n<li>Observation({ObsDict}) where ObsDict is a dictionnary with the same data as an ObsJSON</li>\n<li>Observation(ObsJSON) where ObsJSON is a string with the JSON format</li>\n<li>Observation(ObsBSON) where ObsBSON is a bytes with the BSON format</li>\n<li>Observation([ESSetDatation, ESSetLocation, ESSetProperty, ESSetResult]) where ESSet is a list of ESValue :\n[ESValue1, ESValue2,...] or [ESValue] or ESValue</li>\n<li>Observation(datation=ESSetDatation, location=ESSetLocation,\n          property=ESSetProperty, result=ESSetResult)</li>\n</ul>\n\n<p><em>Note : the parameters 'idxref' and 'order' are used only when an ESSetResult without Index is in arguments.\n'order' indicates the order for the Index creation and 'idxref' the linked index (0 for Datation, 1 for Location, 2 for Property).</em></p>\n", "signature": "(self, *args, order=[], idxref={}, **kwargs)", "funcdef": "def"}, {"fullname": "ES.ESObservation.Observation.Ilist", "modulename": "ES.ESObservation", "qualname": "Observation.Ilist", "type": "function", "doc": "<p></p>\n", "signature": "(cls, ilist, name='', option=None, parameter=None, mAtt=None)", "funcdef": "def"}, {"fullname": "ES.ESObservation.Observation.axes", "modulename": "ES.ESObservation", "qualname": "Observation.axes", "type": "variable", "doc": "<p><strong>list of integer (@property)</strong> : list of independant axes in the Observation\n(0 for Datation, 1 for Location, 2 for Property)</p>\n"}, {"fullname": "ES.ESObservation.Observation.bounds", "modulename": "ES.ESObservation", "qualname": "Observation.bounds", "type": "variable", "doc": "<p><strong>list of <code>ES.ESValue</code> (@property)</strong> : <code>ES.ESValue</code> bounding box for each axis.</p>\n"}, {"fullname": "ES.ESObservation.Observation.complet", "modulename": "ES.ESObservation", "qualname": "Observation.complet", "type": "variable", "doc": "<p><strong>boolean (@property)</strong> : True if self.ilist is complete (if the number of \nvalues is consistent with the number of index values)</p>\n"}, {"fullname": "ES.ESObservation.Observation.consistent", "modulename": "ES.ESObservation", "qualname": "Observation.consistent", "type": "variable", "doc": "<p><strong>boolean (@property)</strong> : True if Observation is consistent (no duplicate index)</p>\n"}, {"fullname": "ES.ESObservation.Observation.dimension", "modulename": "ES.ESObservation", "qualname": "Observation.dimension", "type": "variable", "doc": "<p><strong>integer (@property)</strong> : number of independant axes in the Observation</p>\n"}, {"fullname": "ES.ESObservation.Observation.json", "modulename": "ES.ESObservation", "qualname": "Observation.json", "type": "variable", "doc": "<p><strong>string (@property)</strong> : JSON Observation (ObsJSON format) whit index\nand whitout informations</p>\n"}, {"fullname": "ES.ESObservation.Observation.jsonFeature", "modulename": "ES.ESObservation", "qualname": "Observation.jsonFeature", "type": "variable", "doc": "<p><strong>string (@property)</strong> : \"FeatureCollection\" with ESSetLocation geometry</p>\n"}, {"fullname": "ES.ESObservation.Observation.nValueObs", "modulename": "ES.ESObservation", "qualname": "Observation.nValueObs", "type": "variable", "doc": "<p><strong>list (@property)</strong> : lenght of axes [datation, location, properety, result].</p>\n"}, {"fullname": "ES.ESObservation.Observation.rate", "modulename": "ES.ESObservation", "qualname": "Observation.rate", "type": "variable", "doc": "<p><strong>float (@property)</strong> : ratio number measure / number measure if complete</p>\n"}, {"fullname": "ES.ESObservation.Observation.score", "modulename": "ES.ESObservation", "qualname": "Observation.score", "type": "variable", "doc": "<p><strong>integer (@property)</strong> : Observation type (calculated from dimension , nValueObs and idxref).\nThe score is a codification of the number of ESValue for each axis.\nE.g., score=122 means one PropertyValue (1), several LocationValue (2),\nseveral DatationValue (2)</p>\n"}, {"fullname": "ES.ESObservation.Observation.setDatation", "modulename": "ES.ESObservation", "qualname": "Observation.setDatation", "type": "variable", "doc": "<p><strong>list (@property)</strong> : list of values in the datation axis</p>\n"}, {"fullname": "ES.ESObservation.Observation.setLocation", "modulename": "ES.ESObservation", "qualname": "Observation.setLocation", "type": "variable", "doc": "<p><strong>list (@property)</strong> : list of values in the location axis</p>\n"}, {"fullname": "ES.ESObservation.Observation.setProperty", "modulename": "ES.ESObservation", "qualname": "Observation.setProperty", "type": "variable", "doc": "<p><strong>list (@property)</strong> : list of values in the property axis</p>\n"}, {"fullname": "ES.ESObservation.Observation.setResult", "modulename": "ES.ESObservation", "qualname": "Observation.setResult", "type": "variable", "doc": "<p><strong>list (@property)</strong> : list of values in the result axis</p>\n"}, {"fullname": "ES.ESObservation.Observation.typeObs", "modulename": "ES.ESObservation", "qualname": "Observation.typeObs", "type": "variable", "doc": "<p><strong>string (@property)</strong> : Observation type (calculated from the score)</p>\n"}, {"fullname": "ES.ESObservation.Observation.addAttributes", "modulename": "ES.ESObservation", "qualname": "Observation.addAttributes", "type": "function", "doc": "<p>Add informations attached to <code>Observation</code></p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>js</strong> : Dict - Keys are Observation keys (dict mAtt) or users keys (dict parameter).</li>\n</ul>\n\n<p><em>Returns</em></p>\n\n<ul>\n<li><strong>None</strong></li>\n</ul>\n", "signature": "(self, js)", "funcdef": "def"}, {"fullname": "ES.ESObservation.Observation.addJson", "modulename": "ES.ESObservation", "qualname": "Observation.addJson", "type": "function", "doc": "<p>Complete an empty <code>Observation</code> with json data.</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>js</strong> : string - ObsJSON data</li>\n</ul>\n\n<p><em>Returns</em></p>\n\n<ul>\n<li><strong>None</strong></li>\n</ul>\n", "signature": "(self, js)", "funcdef": "def"}, {"fullname": "ES.ESObservation.Observation.append", "modulename": "ES.ESObservation", "qualname": "Observation.append", "type": "function", "doc": "<p>Add a new <code>ES.ESValue</code> to Result</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>dat, loc, prp</strong> : compatible Value for an existing or new <code>ES.ESValue</code></li>\n<li><strong>res</strong> : compatible existing or new result <code>ES.ESValue</code></li>\n<li><strong>unique</strong> : boolean (default False), if False, duplicate index is allowed</li>\n<li><strong>equal</strong> : string (default 'full'), if 'full', two ESValue are equal\nif all the attributes are equal, if 'name', two ESValue are equal if only the names are equal.</li>\n<li><strong>fast</strong> : boolean (default False) - Update whith ESValue and whithout reindex, equal=full</li>\n</ul>\n\n<p><em>Returns</em></p>\n\n<ul>\n<li><strong>int</strong> : last index in the result valueList (or 0 if fast).</li>\n</ul>\n", "signature": "(self, dat, loc, prp, res, unique=False, equal='full', fast=False)", "funcdef": "def"}, {"fullname": "ES.ESObservation.Observation.appendList", "modulename": "ES.ESObservation", "qualname": "Observation.appendList", "type": "function", "doc": "<p>Add a list of new <code>ES.ESValue</code> to Result</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>listVal</strong> : list of ES.ESValue compatible type</li>\n<li><strong>listDat, listLoc, listPrp</strong> : list of index or Value to define a <code>ES.ESValue</code></li>\n<li><strong>unique</strong> : boolean (default False), if False, duplicate index is allowed</li>\n<li><strong>equal</strong> : string (default 'full'), if 'full', two ESValue are equal if all the attributes are equal,\nif 'name', two ESValue are equal if only the names are equal.</li>\n</ul>\n\n<p><em>Returns</em></p>\n\n<ul>\n<li><strong>None</strong></li>\n</ul>\n", "signature": "(self, listDat, listLoc, listPrp, listVal, unique=False, equal='full')", "funcdef": "def"}, {"fullname": "ES.ESObservation.Observation.appendObs", "modulename": "ES.ESObservation", "qualname": "Observation.appendObs", "type": "function", "doc": "<p>Add an <code>Observation</code> as a new Result <code>ES.ESValue</code> with bounding box for the Index <code>ES.ESValue</code></p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>obs</strong> : Observation</li>\n</ul>\n\n<p><em>Returns</em></p>\n\n<ul>\n<li><strong>int</strong> : last index in the <code>Observation</code></li>\n</ul>\n", "signature": "(self, obs, unique=False, equal='full')", "funcdef": "def"}, {"fullname": "ES.ESObservation.Observation.choropleth", "modulename": "ES.ESObservation", "qualname": "Observation.choropleth", "type": "function", "doc": "<p>Display <code>Observation</code> on a folium.Map (only with dim=1)</p>\n\n<ul>\n<li><strong>name</strong> : String, optionnal (default 'choropleth') - Name of the choropleth</li>\n</ul>\n\n<p><em>Returns</em></p>\n\n<ul>\n<li><strong>folium.Map</strong></li>\n</ul>\n", "signature": "(self, name='choropleth')", "funcdef": "def"}, {"fullname": "ES.ESObservation.Observation.extend", "modulename": "ES.ESObservation", "qualname": "Observation.extend", "type": "function", "doc": "<p>Copy axis from other <code>Observation</code> to self <code>Observation</code> (if it daesn't exist)</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>other</strong> : object Observation to copy</li>\n</ul>\n\n<p><em>Returns</em></p>\n\n<ul>\n<li><strong>None</strong></li>\n</ul>\n", "signature": "(self, classES, listValue, index)", "funcdef": "def"}, {"fullname": "ES.ESObservation.Observation.filter", "modulename": "ES.ESObservation", "qualname": "Observation.filter", "type": "function", "doc": "<p>Remove <code>ES.ESValue</code> from Result that does not match the indexes filter.\nThe filter is a list of tests of the form : \"indexvalue.method(parameter) is True\"\nwhere keyword \"method : parameter\" are given in the dictionnary. Filters are cumulatives.</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>inplace</strong> : boolean (default False) - If True, apply filter to\nObservation, else return new Observation.</li>\n<li><strong>filterdic</strong> : keyword arguments (keys is a ClassES and value is a dictionnary) .\n              where dict value contains keyword \"method : parameter\"</li>\n</ul>\n\n<p><em>Returns</em></p>\n\n<ul>\n<li><strong>Observation</strong> : new observation if not inplace, else None.</li>\n</ul>\n", "signature": "(self, inplace=False, **filterdic)", "funcdef": "def"}, {"fullname": "ES.ESObservation.Observation.from_bytes", "modulename": "ES.ESObservation", "qualname": "Observation.from_bytes", "type": "function", "doc": "<p>Generate <code>Observation</code> object from byte value.</p>\n\n<p><em>Returns</em> : <code>Observation</code></p>\n", "signature": "(cls, byt)", "funcdef": "def"}, {"fullname": "ES.ESObservation.Observation.from_file", "modulename": "ES.ESObservation", "qualname": "Observation.from_file", "type": "function", "doc": "<p>Generate <code>Observation</code> object from file storage.</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>file</strong> : string - file name (with path)</li>\n</ul>\n\n<p><em>Returns</em> : <code>Observation</code></p>\n", "signature": "(cls, file)", "funcdef": "def"}, {"fullname": "ES.ESObservation.Observation.full", "modulename": "ES.ESObservation", "qualname": "Observation.full", "type": "function", "doc": "<p>Add empty Result <code>ES.ESValue</code> to have a 'complete' <code>Observation</code></p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>inplace</strong> : boolean (default False) - If True, add values to\nObservation, else return new Observation.</li>\n<li><strong>minind</strong> : boolean (default True) - If True, independent axes are\ncompleted with fillvalue, else all axes are completed</li>\n<li><strong>fillvalue</strong> : value used to complete the Observation</li>\n</ul>\n\n<p><em>Returns</em></p>\n\n<ul>\n<li><strong>Observation</strong> : new observation if not inplace, else None.</li>\n</ul>\n", "signature": "(self, minind=True, fillvalue=None, inplace=False)", "funcdef": "def"}, {"fullname": "ES.ESObservation.Observation.iLoc", "modulename": "ES.ESObservation", "qualname": "Observation.iLoc", "type": "function", "doc": "<p>Return the <code>ES.ESValue</code> values for an <code>ES.ilist.Ilist</code> index.</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>idat, iloc, iprp</strong> : <code>ES.ilist.Ilist</code> index value</li>\n<li><strong>json</strong> : Boolean (default True) - Return JSON string if True</li>\n</ul>\n\n<p><em>Returns</em></p>\n\n<ul>\n<li><strong>dict</strong> : dict or JSON of each ES.ESValue (dat, loc, prp, res)</li>\n</ul>\n", "signature": "(self, idat, iloc, iprp, json=True)", "funcdef": "def"}, {"fullname": "ES.ESObservation.Observation.indexLoc", "modulename": "ES.ESObservation", "qualname": "Observation.indexLoc", "type": "function", "doc": "<p>Return the index of a <code>ES.ESValue</code> in a <code>ES.ilist.Ilist</code> index or result</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>esValue</strong> : <code>ES.ESValue</code>,</li>\n<li><strong>name</strong> : index or result name</li>\n<li><strong>string</strong> : Boolean (default True) - Return type (JSON if True, dict if False)</li>\n</ul>\n\n<p><em>Returns</em></p>\n\n<ul>\n<li><strong>dict or string</strong> : {'full' : indFull, 'name' : indName, 'value' : indValue }\n<ul>\n<li>indFull : integer for the first index value with name and value equality</li>\n<li>indName : integer for the first index value with name equality</li>\n<li>indFull : integer for the first index value with value equality</li>\n</ul></li>\n</ul>\n", "signature": "(self, esValue, name, string=True)", "funcdef": "def"}, {"fullname": "ES.ESObservation.Observation.iObsIndex", "modulename": "ES.ESObservation", "qualname": "Observation.iObsIndex", "type": "function", "doc": "<p>Return the <code>ES.ESValue</code> index values for an Observation row.</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>ind</strong> : row Observation (equivalent to Result row)</li>\n<li><strong>json</strong> : Boolean (default True) - Return JSON string if True</li>\n</ul>\n\n<p><em>Returns</em></p>\n\n<ul>\n<li><strong>list</strong> : index of each ES.ESValue [idat, iloc, iprp]</li>\n</ul>\n", "signature": "(self, ind)", "funcdef": "def"}, {"fullname": "ES.ESObservation.Observation.loc", "modulename": "ES.ESObservation", "qualname": "Observation.loc", "type": "function", "doc": "<p>Return the <code>ES.ESValue</code> values for a DatationValue, LocationValue, PropertyValue.</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>valdat, valloc, valprp</strong> : DatationValue, LocationValue, PropertyValue</li>\n</ul>\n\n<p><em>Returns</em></p>\n\n<ul>\n<li><strong>dict</strong> : dict or JSON of each ES.ESValue (dat, loc, prp, res)</li>\n</ul>\n", "signature": "(self, valDat, valLoc, valPrp, json=True)", "funcdef": "def"}, {"fullname": "ES.ESObservation.Observation.majList", "modulename": "ES.ESObservation", "qualname": "Observation.majList", "type": "function", "doc": "<p>Modify an attribute (name or value) in an axis list.</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>axename</strong> : index or result name</li>\n<li><strong>listVal</strong> : new list of values</li>\n<li><strong>name</strong> : boolean (default True) - True for 'name' and False for 'value'</li>\n</ul>\n\n<p><em>Returns</em></p>\n\n<ul>\n<li><strong>None</strong></li>\n</ul>\n", "signature": "(self, axename, listVal, name=False)", "funcdef": "def"}, {"fullname": "ES.ESObservation.Observation.majValue", "modulename": "ES.ESObservation", "qualname": "Observation.majValue", "type": "function", "doc": "<p>Update the value of an existing <code>ES.ESValue</code> by a new <code>ES.ESValue</code></p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>esValue</strong> : ESValue to update</li>\n<li><strong>newEsValue</strong> : new ESValue</li>\n<li><strong>name</strong> : index or result name</li>\n<li><strong>equal</strong> : criteria used to compare ESValue ('full', 'name', 'value')</li>\n</ul>\n\n<p><em>Returns</em></p>\n\n<ul>\n<li><strong>Int</strong> : index in the ESSet valueList.</li>\n</ul>\n", "signature": "(self, esValue, newEsValue, name, equal='full')", "funcdef": "def"}, {"fullname": "ES.ESObservation.Observation.plot", "modulename": "ES.ESObservation", "qualname": "Observation.plot", "type": "function", "doc": "<p>This function visualize an <code>Observation</code> with line or colormesh.</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>switch</strong> : Boolean (default False) - Switch between x and y axis.</li>\n<li><strong>line</strong> : Boolean (default True) - Choice line or colormesh.</li>\n<li><strong>sort</strong> : Boolean (defaut True) - Sort along an axis or not.</li>\n<li><strong>size</strong> : Int (default 5) - Size of the figure to plot.</li>\n<li><strong>marker</strong> : Char (default 'o') - Symbol for each point.</li>\n<li><strong>maxname</strong> : String (default 20) - maximum length for string</li>\n</ul>\n\n<p><em>Returns</em></p>\n\n<ul>\n<li><strong>None</strong></li>\n</ul>\n", "signature": "(\n    self,\n    switch=False,\n    line=True,\n    sort=True,\n    size=5,\n    marker='o',\n    maxname=20\n)", "funcdef": "def"}, {"fullname": "ES.ESObservation.Observation.sort", "modulename": "ES.ESObservation", "qualname": "Observation.sort", "type": "function", "doc": "<p>Modify the order of <code>ES.ESValue</code>.</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>order</strong> : list (default []) - Ordered list to follow (0:dat, 1:loc, 2:prp).</li>\n<li><strong>reindex</strong> : boolean (default True) - calculate new index values.</li>\n</ul>\n\n<p><em>Returns</em></p>\n\n<ul>\n<li><strong>None</strong></li>\n</ul>\n", "signature": "(self, order=[], reindex=True)", "funcdef": "def"}, {"fullname": "ES.ESObservation.Observation.to_bytes", "modulename": "ES.ESObservation", "qualname": "Observation.to_bytes", "type": "function", "doc": "<p>Export in binary format. </p>\n\n<p><em>Returns</em></p>\n\n<ul>\n<li><strong>bytes</strong> : binary representation of the <code>Observation</code></li>\n</ul>\n", "signature": "(\n    self,\n    option={'datation': ['namemini', 'value'], 'location': ['namemini', 'value'], 'property': ['valuemini'], 'result': ['namemini', 'sfloat'], -1: ['namemini', 'value']}\n)", "funcdef": "def"}, {"fullname": "ES.ESObservation.Observation.to_csv", "modulename": "ES.ESObservation", "qualname": "Observation.to_csv", "type": "function", "doc": "<p>Generate csv file to display <code>Observation</code> data.</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>file</strong> : string - file name (with path)</li>\n</ul>\n\n<p><em>Parameters (kwargs)</em></p>\n\n<ul>\n<li><strong>json</strong> : boolean (default True) - Display json for <code>ES.ESValue</code></li>\n<li><strong>name</strong> : boolean (default True) - Display name for <code>ES.ESValue</code></li>\n<li><strong>dat</strong>  : boolean (default True) - Display value for <code>ES.ESValue.DatationValue</code></li>\n<li><strong>loc</strong>  : boolean (default True) - Display value for <code>ES.ESValue.LocationValue</code></li>\n<li><strong>prp</strong>  : boolean (default True) - Display value for <code>ES.ESValue.PropertyValue</code></li>\n<li><strong>res</strong>  : boolean (default True) - Display value for Result <code>ES.ESValue</code></li>\n<li><strong>lenres</strong> : int (default 0) - Number of raws (all if 0)</li>\n</ul>\n\n<p><em>Returns</em></p>\n\n<ul>\n<li><strong>None</strong></li>\n</ul>\n", "signature": "(self, file, **kwargs)", "funcdef": "def"}, {"fullname": "ES.ESObservation.Observation.to_dataFrame", "modulename": "ES.ESObservation", "qualname": "Observation.to_dataFrame", "type": "function", "doc": "<p>Convert <code>Observation</code> to pandas.DataFrame with the smallest dimension.</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>info</strong> : Boolean (default False) - Generate a specific Coords with Observation characteristics.</li>\n<li><strong>numeric</strong> : Boolean (default False) - Generate a numeric DataArray.Values.</li>\n<li><strong>ind</strong> : String (default 'axe') - 'axe' only independant axes, 'all' : all the axes.</li>\n<li><strong>fillvalue</strong> : Object (default '?') used to complete result</li>\n<li><strong>func</strong> : String (default function identity) - Name of the function to apply to the result values</li>\n<li><strong>name</strong> : String (default 'Observation') - Name of the Dataframe</li>\n</ul>\n\n<p><em>Returns</em></p>\n\n<ul>\n<li><strong>pandas.DataFrame</strong></li>\n</ul>\n", "signature": "(\n    self,\n    info=False,\n    numeric=False,\n    ind='axe',\n    fillvalue='?',\n    func=<bound method Es._identity of <ESconstante.Es object at 0x0000020D356CB1F0>>,\n    name='Observation'\n)", "funcdef": "def"}, {"fullname": "ES.ESObservation.Observation.to_file", "modulename": "ES.ESObservation", "qualname": "Observation.to_file", "type": "function", "doc": "<p>Generate obs file to display <code>Observation</code> data.</p>\n\n<p><em>Parameters (kwargs)</em></p>\n\n<ul>\n<li><strong>file</strong> : string - file name (with path)</li>\n<li><strong>kwargs</strong> : see 'to_json' parameters</li>\n</ul>\n\n<p><em>Returns</em></p>\n\n<ul>\n<li><strong>Integer</strong> : file lenght (bytes)</li>\n</ul>\n", "signature": "(self, file, **kwargs)", "funcdef": "def"}, {"fullname": "ES.ESObservation.Observation.to_json", "modulename": "ES.ESObservation", "qualname": "Observation.to_json", "type": "function", "doc": "<p>Export in Bson or Json format.</p>\n\n<p><em>Parameters (optional, default value in option attribute)</em></p>\n\n<ul>\n<li><strong>encoded</strong>   : boolean - choice for return format (string/bytes if True, dict else)</li>\n<li><strong>encode_format</strong>  : string - choice for return format (bson, json, cbor)</li>\n<li><strong>json_res_index</strong> : Boolean - include index for Result</li>\n<li><strong>json_param</strong>     : Boolean - include ESObs Parameter</li>\n<li><strong>json_info</strong>      : Boolean - include ESObs Information with all information</li>\n<li><strong>json_info_type</strong> : Boolean - include in ESObs Information the type of ESObs</li>\n<li><strong>json_info_nval</strong> : Boolean - include in ESObs Information the lenght of ESObs</li>\n<li><strong>json_info_box</strong>  : Boolean - include in ESObs Information the bounding box</li>\n<li><strong>json_info_other</strong>: Boolean - include in ESObs Information the other information</li>\n<li><strong>codif</strong> : dict (default ES.codeb). Numerical value for string in CBOR encoder</li>\n</ul>\n\n<p><em>Returns</em></p>\n\n<ul>\n<li><strong>string or dict</strong> : Json string or dict</li>\n</ul>\n", "signature": "(self, **kwargs)", "funcdef": "def"}, {"fullname": "ES.ESObservation.Observation.to_numpy", "modulename": "ES.ESObservation", "qualname": "Observation.to_numpy", "type": "function", "doc": "<p>Convert <code>Observation</code> to Numpy array.</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>ind</strong> : String (default 'axe') - 'axe' only independant axes, 'all' : all the axes, 'flat' : one dimension</li>\n<li><strong>fillvalue</strong> : Object (default '?') used to complete result</li>\n<li><strong>func</strong> : String (default function identity) - Name of the function to apply to the result values</li>\n</ul>\n\n<p><em>Returns</em></p>\n\n<ul>\n<li><strong>Numpy array</strong></li>\n</ul>\n", "signature": "(self, func=None, ind='axe', fillvalue=None, **kwargs)", "funcdef": "def"}, {"fullname": "ES.ESObservation.Observation.to_xarray", "modulename": "ES.ESObservation", "qualname": "Observation.to_xarray", "type": "function", "doc": "<p>Convert <code>Observation</code> to DataArray.</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>info</strong> : Boolean (default False) - Generate a specific Coords with Observation characteristics.</li>\n<li><strong>ind</strong> : String (default 'axe') - 'axe' only independant axes, 'all' : all the axes, 'flat' : one dimension</li>\n<li><strong>fillvalue</strong> : Object (default '?') used to complete result</li>\n<li><strong>func</strong> : String (default function identity) - Name of the function applied to each Result <code>ES.ESValue</code></li>\n<li><strong>numeric</strong> : Boolean (default False) - Generate a numeric DataArray.Values.</li>\n<li><strong>name</strong> : String (default 'Observation') - Name of the xArray</li>\n<li><strong>maxname</strong> : String (default 20) - maximum length for string</li>\n</ul>\n\n<p><em>Returns</em></p>\n\n<ul>\n<li><strong>xarray.DataArray</strong></li>\n</ul>\n", "signature": "(\n    self,\n    info=False,\n    numeric=False,\n    ind='axe',\n    fillvalue=None,\n    name='Observation',\n    maxname=20,\n    func=None,\n    **kwargs\n)", "funcdef": "def"}, {"fullname": "ES.ESObservation.Observation.view", "modulename": "ES.ESObservation", "qualname": "Observation.view", "type": "function", "doc": "<p>Generate tabular list to display <code>Observation</code> data.</p>\n\n<p><em>Parameters (kwargs)</em></p>\n\n<ul>\n<li><strong>json</strong> : boolean (default True) - Display json for <code>ES.ESValue</code></li>\n<li><strong>name</strong> : boolean (default True) - Display name for <code>ES.ESValue</code></li>\n<li><strong>dat</strong>  : boolean (default True) - Display value for <code>ES.ESValue.DatationValue</code></li>\n<li><strong>loc</strong>  : boolean (default True) - Display value for <code>ES.ESValue.LocationValue</code></li>\n<li><strong>prp</strong>  : boolean (default True) - Display value for <code>ES.ESValue.PropertyValue</code></li>\n<li><strong>lenres</strong> : Integer (default : 0) - Number of raws (all if 0)</li>\n<li><strong>width</strong> : Integer (default 15) - Number of characters displayed for each attribute.</li>\n<li><strong>tabulate params</strong> : default 'tablefmt': 'simple', 'numalign': 'left', 'stralign': 'left',\n       'floatfmt': '.3f' - See tabulate module</li>\n</ul>\n\n<p><em>Returns</em> : None</p>\n", "signature": "(self, **kwargs)", "funcdef": "def"}, {"fullname": "ES.ESObservation.Observation.vList", "modulename": "ES.ESObservation", "qualname": "Observation.vList", "type": "function", "doc": "<p>Generate a list of value for an axis.</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>idxname</strong> : string - Name of the axis (datation, location, property, result)</li>\n<li><strong>func</strong> : String (default function identity) - Name of the function applied to each <code>ES.ESValue</code></li>\n</ul>\n\n<p><em>Returns</em></p>\n\n<ul>\n<li><strong>list</strong> : list of the values</li>\n</ul>\n", "signature": "(\n    self,\n    idxname,\n    func=<bound method Es._identity of <ESconstante.Es object at 0x0000020D356CB1F0>>\n)", "funcdef": "def"}, {"fullname": "ES.ESObservation.Observation.vListName", "modulename": "ES.ESObservation", "qualname": "Observation.vListName", "type": "function", "doc": "<p>Generate a list of value name for an axis.</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>idxname</strong> : string - Name of the axis (datation, location, property, result)</li>\n</ul>\n\n<p><em>Returns</em></p>\n\n<ul>\n<li><strong>list</strong> : list of the value name</li>\n</ul>\n", "signature": "(self, idxname)", "funcdef": "def"}, {"fullname": "ES.ESObservation.Observation.vListSimple", "modulename": "ES.ESObservation", "qualname": "Observation.vListSimple", "type": "function", "doc": "<p>Generate a list of simple value (see <code>ES.ESValue</code> vSimple method) for an axis.</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>idxname</strong> : string - Name of the axis (datation, location, property, result)</li>\n</ul>\n\n<p><em>Returns</em></p>\n\n<ul>\n<li><strong>list</strong> : list of the simple value</li>\n</ul>\n", "signature": "(self, idxname)", "funcdef": "def"}, {"fullname": "ES.ESObservation.Observation.vListValue", "modulename": "ES.ESObservation", "qualname": "Observation.vListValue", "type": "function", "doc": "<p>Generate a list of value (see <code>ES.ESValue</code> getValue method) for an axis.</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>idxname</strong> : string - Name of the axis (datation, location, property, result)</li>\n</ul>\n\n<p><em>Returns</em></p>\n\n<ul>\n<li><strong>list</strong> : list of the values</li>\n</ul>\n", "signature": "(self, idxname)", "funcdef": "def"}, {"fullname": "ES.ESObservation.Observation.voxel", "modulename": "ES.ESObservation", "qualname": "Observation.voxel", "type": "function", "doc": "<p>Visualize Result <code>ES.ESValue</code> in a cube with voxels.</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>sort</strong> : Boolean (default False) - Sort along axis.</li>\n</ul>\n\n<p><em>Returns</em></p>\n\n<ul>\n<li><strong>None</strong></li>\n</ul>\n", "signature": "(self, sort=False)", "funcdef": "def"}, {"fullname": "ES.ESObservation.ObservationError", "modulename": "ES.ESObservation", "qualname": "ObservationError", "type": "class", "doc": "<p>Common base class for all non-exit exceptions.</p>\n", "bases": "builtins.Exception"}, {"fullname": "ES.ESValue", "modulename": "ES.ESValue", "type": "module", "doc": "<p>Created on Mon Aug  2 14:51:23 2021</p>\n\n<p>@author: philippe@loco-labs.io</p>\n\n<p>ESValue is a module dedicated to structured data (such as dates, location or measurable properties) \nand groups common properties and concepts.</p>\n\n<p>ESValue is build around two attributes :</p>\n\n<ul>\n<li>'name' which is a simple String</li>\n<li><p>'value' which corresponds to a more or less complex object :</p>\n\n<ul>\n<li>DatationValue : value is a TimeSlot Object which represent a set of time intervals</li>\n<li>LocationValue : value is a Shapely Geometry which represent a set of polygons</li>\n<li>PropertyValue : value is a simple dictionary which specifies all the characteristics of a property</li>\n<li>NamedValue    : value can be any simple object</li>\n<li>ExternValue   : value can be any other object</li>\n</ul></li>\n</ul>\n\n<p><img src=\"https://loco-philippe.github.io/ES/ESValue_class.png\" width=\"800\"></p>\n\n<p>This module groups the classes of the objects used in the <code>ES.Observation</code> module :</p>\n\n<ul>\n<li><code>DatationValue</code>,</li>\n<li><code>LocationValue</code>,</li>\n<li><code>PropertyValue</code>,</li>\n<li><code>NamedValue</code></li>\n<li><code>ExternValue</code></li>\n</ul>\n\n<p>and the parent class :</p>\n\n<ul>\n<li><code>ESValue</code></li>\n</ul>\n\n<p>Documentation is available in other pages :</p>\n\n<ul>\n<li>The concepts of 'ES value' are describe in \n<a href=\"https://github.com/loco-philippe/Environmental-Sensing/wiki/ESValue\">this page</a>.</li>\n<li>The non-regression tests are at \n<a href=\"https://github.com/loco-philippe/Environmental-Sensing/blob/main/python/Tests/test_esvalue.py\">this page</a></li>\n<li>Examples are \n<a href=\"https://github.com/loco-philippe/Environmental-Sensing/tree/main/python/Examples\">here</a></li>\n<li>The Json Standard for ESValue is define \n<a href=\"https://github.com/loco-philippe/Environmental-Sensing/tree/main/documentation/ESJSON-Standard.pdf\">here</a></li>\n</ul>\n"}, {"fullname": "ES.ESValue.ESValueEncoder", "modulename": "ES.ESValue", "qualname": "ESValueEncoder", "type": "class", "doc": "<p>add a new json encoder for ESValue</p>\n", "bases": "json.encoder.JSONEncoder"}, {"fullname": "ES.ESValue.ESValueEncoder.default", "modulename": "ES.ESValue", "qualname": "ESValueEncoder.default", "type": "function", "doc": "<p>Implement this method in a subclass such that it returns\na serializable object for <code>o</code>, or calls the base implementation\n(to raise a <code>TypeError</code>).</p>\n\n<p>For example, to support arbitrary iterators, you could\nimplement default like this::</p>\n\n<pre><code>def default(self, o):\n    try:\n        iterable = iter(o)\n    except TypeError:\n        pass\n    else:\n        return list(iterable)\n    # Let the base class default method raise the TypeError\n    return JSONEncoder.default(self, o)\n</code></pre>\n", "signature": "(self, o)", "funcdef": "def"}, {"fullname": "ES.ESValue.ESValue", "modulename": "ES.ESValue", "qualname": "ESValue", "type": "class", "doc": "<p>This class is the parent class for each kind of values\n (<code>DatationValue</code>, <code>LocationValue</code>, <code>PropertyValue</code>, <code>NamedValue</code>, <code>ExternValue</code>)</p>\n\n<p><em>Attributes</em> :</p>\n\n<ul>\n<li><strong>name</strong>  : name  of <code>ESValue.ESValue</code> objects</li>\n<li><strong>value</strong> : value of <code>ESValue.ESValue</code> objects</li>\n<li><code>ESValue.bounds</code> (@property) : boundary  of <code>ESValue.ESValue</code> objects</li>\n<li><code>ESValue.simple</code> (@property) : simplified value of <code>ESValue.ESValue</code> objects</li>\n</ul>\n\n<p>The methods defined in this class are :</p>\n\n<p><strong>binary predicates</strong></p>\n\n<ul>\n<li><code>ESValue.contains</code></li>\n<li><code>ESValue.equals</code></li>\n<li><code>ESValue.intersects</code></li>\n<li><code>ESValue.within</code></li>\n<li><code>ESValue.disjoint</code></li>\n<li><code>ESValue.isEqual</code></li>\n<li><code>ESValue.isNotNull</code></li>\n<li><code>ESValue.isName</code></li>\n</ul>\n\n<p><strong>other methods</strong></p>\n\n<ul>\n<li><code>ESValue.from_obj</code> (@classmethod)</li>\n<li><code>ESValue.bounds</code></li>\n<li><code>ESValue.boxUnion</code></li>\n<li><code>ESValue.getValue</code></li>\n<li><code>ESValue.getName</code></li>\n<li><code>ESValue.json</code></li>\n<li><code>ESValue.setName</code></li>\n<li><code>ESValue.setValue</code></li>\n<li><code>ESValue.simple</code></li>\n<li><code>ESValue.to_float</code></li>\n<li><code>ESValue.to_obj</code></li>\n<li><code>ESValue.valClassName</code></li>\n<li><code>ESValue.vName</code></li>\n<li><code>ESValue.vSimple</code></li>\n</ul>\n"}, {"fullname": "ES.ESValue.ESValue.__init__", "modulename": "ES.ESValue", "qualname": "ESValue.__init__", "type": "function", "doc": "<p>Initialize 'name' and 'value' attribute</p>\n", "signature": "(self, val=None, name=None, className=None)", "funcdef": "def"}, {"fullname": "ES.ESValue.ESValue.from_obj", "modulename": "ES.ESValue", "qualname": "ESValue.from_obj", "type": "function", "doc": "<p>Generate an ESValue Object from a bytes, json or dict object\nSeveral configurations for bs parameters (name and type are string) :\n    - {name : value}\n    - name\n    - object\n    - {type : {name: value}}\n    - {type : name}\n    - {type : value}</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>bs</strong> : bytes, string or dict data to convert</li>\n</ul>\n\n<p><em>Returns</em> :  ESValue object</p>\n", "signature": "(bs, classname=None, simple=True)", "funcdef": "def"}, {"fullname": "ES.ESValue.ESValue.equals", "modulename": "ES.ESValue", "qualname": "ESValue.equals", "type": "function", "doc": "<p>check if self value equals other value (return a boolean).</p>\n", "signature": "(self, other)", "funcdef": "def"}, {"fullname": "ES.ESValue.ESValue.disjoint", "modulename": "ES.ESValue", "qualname": "ESValue.disjoint", "type": "function", "doc": "<p>check if self value is disjoint from other value (return a boolean).</p>\n", "signature": "(self, other)", "funcdef": "def"}, {"fullname": "ES.ESValue.ESValue.contains", "modulename": "ES.ESValue", "qualname": "ESValue.contains", "type": "function", "doc": "<p>check if self value contains other value (return a boolean).</p>\n", "signature": "(self, other)", "funcdef": "def"}, {"fullname": "ES.ESValue.ESValue.within", "modulename": "ES.ESValue", "qualname": "ESValue.within", "type": "function", "doc": "<p>check if self value is within other value (return a boolean).</p>\n", "signature": "(self, other)", "funcdef": "def"}, {"fullname": "ES.ESValue.ESValue.intersects", "modulename": "ES.ESValue", "qualname": "ESValue.intersects", "type": "function", "doc": "<p>check if self value intersects other value (return a boolean).</p>\n", "signature": "(self, other)", "funcdef": "def"}, {"fullname": "ES.ESValue.ESValue.isNotNull", "modulename": "ES.ESValue", "qualname": "ESValue.isNotNull", "type": "function", "doc": "<p>return boolean. True if the 'ESValue' is not a NullValue</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "ES.ESValue.ESValue.isEqual", "modulename": "ES.ESValue", "qualname": "ESValue.isEqual", "type": "function", "doc": "<p>Compare two <code>ESValue</code></p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>other</strong> : ESValue</li>\n<li><strong>name</strong> : boolean (default True) - Include Name in comparison</li>\n<li><strong>value</strong> : boolean (default True) - Include Value in comparison</li>\n</ul>\n\n<p><em>Returns</em></p>\n\n<ul>\n<li><strong>boolean</strong> : Result of the comparison</li>\n</ul>\n", "signature": "(self, other, name=True, value=True)", "funcdef": "def"}, {"fullname": "ES.ESValue.ESValue.isName", "modulename": "ES.ESValue", "qualname": "ESValue.isName", "type": "function", "doc": "<p>check if a pattern (regex) is presenty in the ESValue name.</p>\n", "signature": "(self, pattern)", "funcdef": "def"}, {"fullname": "ES.ESValue.ESValue.bounds", "modulename": "ES.ESValue", "qualname": "ESValue.bounds", "type": "variable", "doc": "<p>list or tuple (@property)</p>\n\n<ul>\n<li>DatationValue : boundingBox (tmin, tmax)</li>\n<li>LocationValue : boundingBox (minx, miny, maxx, maxy)</li>\n<li>PropertyValue : boundingBox (list of type property)</li>\n<li>Other ESValue : ()</li>\n</ul>\n"}, {"fullname": "ES.ESValue.ESValue.boxUnion", "modulename": "ES.ESValue", "qualname": "ESValue.boxUnion", "type": "function", "doc": "<p>return a new <code>ESValue</code> with :</p>\n\n<ul>\n<li>name : parameters</li>\n<li>value : union between box(self) and box(other)</li>\n</ul>\n", "signature": "(self, other, name='')", "funcdef": "def"}, {"fullname": "ES.ESValue.ESValue.getValue", "modulename": "ES.ESValue", "qualname": "ESValue.getValue", "type": "function", "doc": "<p>return self.value object</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "ES.ESValue.ESValue.getName", "modulename": "ES.ESValue", "qualname": "ESValue.getName", "type": "function", "doc": "<p>return self.name object</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "ES.ESValue.ESValue.json", "modulename": "ES.ESValue", "qualname": "ESValue.json", "type": "function", "doc": "<p>Export in json/cbor format (string or dict).</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>untyped</strong> : boolean (default False) - include dtype in the json if True</li>\n<li><strong>encoded</strong> : boolean (default True) - choice for return format (string/bytes if True, dict else)</li>\n<li><strong>encode_format</strong>    : string (default 'json')- choice for return format (json, cbor)</li>\n<li><strong>simpleval</strong> : boolean (default False) - if True, only value is included</li>\n</ul>\n\n<p><em>Returns</em> :  string or dict</p>\n", "signature": "(self, **kwargs)", "funcdef": "def"}, {"fullname": "ES.ESValue.ESValue.setName", "modulename": "ES.ESValue", "qualname": "ESValue.setName", "type": "function", "doc": "<p>Set the Name of the <code>ESValue</code></p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>nam</strong> : string - value to set</li>\n</ul>\n\n<p><em>Returns</em> : None</p>\n", "signature": "(self, nam)", "funcdef": "def"}, {"fullname": "ES.ESValue.ESValue.setValue", "modulename": "ES.ESValue", "qualname": "ESValue.setValue", "type": "function", "doc": "<p>Set a new Value</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>val</strong> : compatible ESValue - New ESValue</li>\n</ul>\n\n<p><em>Returns</em> : None</p>\n", "signature": "(self, val)", "funcdef": "def"}, {"fullname": "ES.ESValue.ESValue.simple", "modulename": "ES.ESValue", "qualname": "ESValue.simple", "type": "variable", "doc": "<p>return vSimple object (@property)</p>\n"}, {"fullname": "ES.ESValue.ESValue.to_float", "modulename": "ES.ESValue", "qualname": "ESValue.to_float", "type": "function", "doc": "<p>return a converted float value or nan</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "ES.ESValue.ESValue.to_obj", "modulename": "ES.ESValue", "qualname": "ESValue.to_obj", "type": "function", "doc": "<p>Export in json/cbor format (string or dict).</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>untyped</strong> : boolean (default False) - include dtype in the json if True</li>\n<li><strong>encoded</strong> : boolean (default True) - choice for return format (string/bytes if True, dict else)</li>\n<li><strong>encode_format</strong> : string (default 'json')- choice for return format (json, cbor)</li>\n<li><strong>simpleval</strong> : boolean (default False)- if True only value</li>\n</ul>\n\n<p><em>Returns</em> :  string or dict</p>\n", "signature": "(self, **kwargs)", "funcdef": "def"}, {"fullname": "ES.ESValue.ESValue.vSimple", "modulename": "ES.ESValue", "qualname": "ESValue.vSimple", "type": "function", "doc": "<p>Return the vSimple of the <code>ESValue</code> (string or object)</p>\n", "signature": "(self, string=False)", "funcdef": "def"}, {"fullname": "ES.ESValue.ESValue.valClassName", "modulename": "ES.ESValue", "qualname": "ESValue.valClassName", "type": "function", "doc": "<p>return the calculate ESValue Class of val (string)</p>\n", "signature": "(val)", "funcdef": "def"}, {"fullname": "ES.ESValue.ESValue.vName", "modulename": "ES.ESValue", "qualname": "ESValue.vName", "type": "function", "doc": "<p>Return the Name of the <code>ESValue</code></p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>default</strong> : string (default nullName) - Return value if nullName</li>\n</ul>\n\n<p><em>Returns</em></p>\n\n<ul>\n<li><strong>str</strong> : Name of the ESValue</li>\n</ul>\n", "signature": "(self, default='')", "funcdef": "def"}, {"fullname": "ES.ESValue.DatationValue", "modulename": "ES.ESValue", "qualname": "DatationValue", "type": "class", "doc": "<p>This class represent Time (instant, interval or set of intervals).</p>\n\n<p><em>Attributes (for @property see methods)</em> :</p>\n\n<ul>\n<li><strong>value</strong> : TimeSlot object (instant, interval or list of interval)</li>\n<li><strong>name</strong> : String</li>\n</ul>\n\n<p>The methods defined in this class are :</p>\n\n<p><em>constructor (@classmethod)</em></p>\n\n<ul>\n<li><code>DatationValue.Simple</code>  (instant)</li>\n<li><code>DatationValue.Box</code>     (interval)</li>\n<li><code>DatationValue.from_obj</code>(see  <code>ESValue.from_obj</code>)</li>\n</ul>\n\n<p><em>getters</em></p>\n\n<ul>\n<li><code>DatationValue.getInstant</code></li>\n<li><code>DatationValue.getInterval</code></li>\n<li><code>DatationValue.vSimple</code></li>\n<li><code>DatationValue.vInterval</code></li>\n<li><code>DatationValue.link</code></li>\n</ul>\n", "bases": "ESValue"}, {"fullname": "ES.ESValue.DatationValue.__init__", "modulename": "ES.ESValue", "qualname": "DatationValue.__init__", "type": "function", "doc": "<p>DatationValue constructor.</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>val</strong> :  compatible Timeslot Value (default nullDate)</li>\n<li><strong>name</strong> :  string (default nullName)</li>\n</ul>\n", "signature": "(\n    self,\n    val=datetime.datetime(1, 1, 1, 0, 0, tzinfo=datetime.timezone.utc),\n    name=''\n)", "funcdef": "def"}, {"fullname": "ES.ESValue.DatationValue.Simple", "modulename": "ES.ESValue", "qualname": "DatationValue.Simple", "type": "function", "doc": "<p>DatationValue built with a time value (instant)</p>\n", "signature": "(cls, instant)", "funcdef": "def"}, {"fullname": "ES.ESValue.DatationValue.Box", "modulename": "ES.ESValue", "qualname": "DatationValue.Box", "type": "function", "doc": "<p>DatationValue built from a tuple or list box coordinates (tmin, tmax)</p>\n", "signature": "(cls, bounds)", "funcdef": "def"}, {"fullname": "ES.ESValue.DatationValue.from_obj", "modulename": "ES.ESValue", "qualname": "DatationValue.from_obj", "type": "function", "doc": "<p>ESValue function (see ESValue.from_obj)</p>\n", "signature": "(cls, bs)", "funcdef": "def"}, {"fullname": "ES.ESValue.DatationValue.getInstant", "modulename": "ES.ESValue", "qualname": "DatationValue.getInstant", "type": "function", "doc": "<p>return datetime if 'instant', none else</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "ES.ESValue.DatationValue.getInterval", "modulename": "ES.ESValue", "qualname": "DatationValue.getInterval", "type": "function", "doc": "<p>return [datetime t1, datetime t2] if 'interval', none else</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "ES.ESValue.DatationValue.link", "modulename": "ES.ESValue", "qualname": "DatationValue.link", "type": "function", "doc": "<p>return the link (string) between self.value and other.value :</p>\n\n<ul>\n<li>equals     : if self and other are the same</li>\n<li>disjoint   : if self's intervals and other's intervals are all disjoint</li>\n<li>within     : if all self's intervals are included in other's intervals</li>\n<li>contains   : if all other's intervals are included in self's intervals</li>\n<li>intersects : in the others cases</li>\n</ul>\n", "signature": "(self, other)", "funcdef": "def"}, {"fullname": "ES.ESValue.DatationValue.nullValue", "modulename": "ES.ESValue", "qualname": "DatationValue.nullValue", "type": "function", "doc": "<p>return nullDate value</p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "ES.ESValue.DatationValue.vInterval", "modulename": "ES.ESValue", "qualname": "DatationValue.vInterval", "type": "function", "doc": "<p>return [t1, t2] with t1, t2 - Mini, maxi of the TimeSlot (timestamp or datetime).</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>encode_format</strong>    : string (default 'json')- choice for return format (json, cbor)</li>\n</ul>\n\n<p><em>Returns</em></p>\n\n<ul>\n<li><strong>JSON with timestamp or list with datetime</strong></li>\n</ul>\n", "signature": "(self, encoded=True, encode_format='json')", "funcdef": "def"}, {"fullname": "ES.ESValue.DatationValue.vSimple", "modulename": "ES.ESValue", "qualname": "DatationValue.vSimple", "type": "function", "doc": "<p>return a datetime : middle of the TimeSlot.</p>\n", "signature": "(self, string=False, **kwargs)", "funcdef": "def"}, {"fullname": "ES.ESValue.LocationValue", "modulename": "ES.ESValue", "qualname": "LocationValue", "type": "class", "doc": "<p>This class represent the Location of an Observation (point, polygon).</p>\n\n<p><em>Attributes (for @property see methods)</em> :</p>\n\n<ul>\n<li><strong>value</strong> : Shapely object (point, polygon)</li>\n<li><strong>name</strong> : String</li>\n</ul>\n\n<p>The methods defined in this class are :</p>\n\n<p><em>constructor (@classmethod)</em></p>\n\n<ul>\n<li><code>LocationValue.Simple</code>   (point)</li>\n<li><code>LocationValue.Box</code></li>\n<li><code>LocationValue.from_obj</code> (see  <code>ESValue.from_obj</code>)</li>\n</ul>\n\n<p><em>getters (@property)</em></p>\n\n<ul>\n<li><code>LocationValue.coords</code></li>\n<li><code>LocationValue.coorInv</code></li>\n</ul>\n\n<p><em>getters</em></p>\n\n<ul>\n<li><code>LocationValue.getPoint</code></li>\n<li><code>LocationValue.vSimple</code></li>\n<li><code>LocationValue.vPointInv</code></li>\n<li><code>LocationValue.vPointX</code></li>\n<li><code>LocationValue.vPointY</code></li>\n<li><code>LocationValue.vCodePlus</code></li>\n<li><code>LocationValue.link</code></li>\n</ul>\n", "bases": "ESValue"}, {"fullname": "ES.ESValue.LocationValue.__init__", "modulename": "ES.ESValue", "qualname": "LocationValue.__init__", "type": "function", "doc": "<p>LocationValue constructor.</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>val</strong> :  compatible shapely.geometry.Point (or Polygon) Value (default nullCoor)</li>\n<li><strong>name</strong> :  string (default nullName)</li>\n</ul>\n", "signature": "(self, val=[-1, -1], name='')", "funcdef": "def"}, {"fullname": "ES.ESValue.LocationValue.Simple", "modulename": "ES.ESValue", "qualname": "LocationValue.Simple", "type": "function", "doc": "<p>return LocationValue built with tuple or list coordinates (x,y)</p>\n", "signature": "(cls, coord)", "funcdef": "def"}, {"fullname": "ES.ESValue.LocationValue.Box", "modulename": "ES.ESValue", "qualname": "LocationValue.Box", "type": "function", "doc": "<p>return LocationValue built with tuple or list box coordinates (minx, miny, maxx, maxy)</p>\n", "signature": "(cls, bounds, ccw=True)", "funcdef": "def"}, {"fullname": "ES.ESValue.LocationValue.from_obj", "modulename": "ES.ESValue", "qualname": "LocationValue.from_obj", "type": "function", "doc": "<p>ESValue function (see ESValue.from_obj)</p>\n", "signature": "(cls, bs)", "funcdef": "def"}, {"fullname": "ES.ESValue.LocationValue.coords", "modulename": "ES.ESValue", "qualname": "LocationValue.coords", "type": "variable", "doc": "<p>return geoJson coordinates (list)</p>\n"}, {"fullname": "ES.ESValue.LocationValue.coorInv", "modulename": "ES.ESValue", "qualname": "LocationValue.coorInv", "type": "variable", "doc": "<p>list (@property) : vSimple inverse coordinates [vSimple[1], vSimple[0]]</p>\n"}, {"fullname": "ES.ESValue.LocationValue.getPoint", "modulename": "ES.ESValue", "qualname": "LocationValue.getPoint", "type": "function", "doc": "<p>return a list with point coordinates [x, y] if the shape is a point, else none</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "ES.ESValue.LocationValue.link", "modulename": "ES.ESValue", "qualname": "LocationValue.link", "type": "function", "doc": "<p>return the link (string) between self.value and other.value :</p>\n\n<ul>\n<li>equals     : if self and other are the same</li>\n<li>disjoint   : if self's shape and other's shape are disjoint</li>\n<li>within     : if other's shape contains self's shape</li>\n<li>contains   : if self's shape contains other's shape</li>\n<li>intersects : in the others cases</li>\n</ul>\n", "signature": "(self, other)", "funcdef": "def"}, {"fullname": "ES.ESValue.LocationValue.nullValue", "modulename": "ES.ESValue", "qualname": "LocationValue.nullValue", "type": "function", "doc": "<p>return nullPosition value</p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "ES.ESValue.LocationValue.vCodePlus", "modulename": "ES.ESValue", "qualname": "LocationValue.vCodePlus", "type": "function", "doc": "<p>return CodePlus value (string) of the point property value</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "ES.ESValue.LocationValue.vSimple", "modulename": "ES.ESValue", "qualname": "LocationValue.vSimple", "type": "function", "doc": "<p>return simple value (centroid coordinates for the shape : \n[x, y]) in a string format or in a object format</p>\n", "signature": "(self, string=False)", "funcdef": "def"}, {"fullname": "ES.ESValue.LocationValue.vPointInv", "modulename": "ES.ESValue", "qualname": "LocationValue.vPointInv", "type": "function", "doc": "<p>return point (property) with inversed vSimple coordinates in a string format or\nin a list format [y, x]</p>\n", "signature": "(self, string=False)", "funcdef": "def"}, {"fullname": "ES.ESValue.LocationValue.vPointX", "modulename": "ES.ESValue", "qualname": "LocationValue.vPointX", "type": "function", "doc": "<p>return point (property) coordinates x</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "ES.ESValue.LocationValue.vPointY", "modulename": "ES.ESValue", "qualname": "LocationValue.vPointY", "type": "function", "doc": "<p>return point (property) coordinates y</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "ES.ESValue.PropertyValue", "modulename": "ES.ESValue", "qualname": "PropertyValue", "type": "class", "doc": "<p>This class represents the Property of an Observation.</p>\n\n<p><em>Attributes (for @property see methods)</em> :</p>\n\n<ul>\n<li><strong>value</strong> : dict</li>\n<li><strong>name</strong> : String</li>\n</ul>\n\n<p>The methods defined in this class are :</p>\n\n<p><em>constructor (@classmethod)</em></p>\n\n<ul>\n<li><code>PropertyValue.Simple</code>   (property type)</li>\n<li><code>PropertyValue.Box</code>      (set of property type)</li>\n<li><code>PropertyValue.from_obj</code> (see  <code>ESValue.from_obj</code>)</li>\n</ul>\n\n<p><em>getters</em></p>\n\n<ul>\n<li><code>PropertyValue.vSimple</code></li>\n<li><code>PropertyValue.link</code></li>\n</ul>\n", "bases": "ESValue"}, {"fullname": "ES.ESValue.PropertyValue.__init__", "modulename": "ES.ESValue", "qualname": "PropertyValue.__init__", "type": "function", "doc": "<p>PropertyValue constructor.</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>val</strong> :  property dict or json string (default nullPrp)</li>\n<li><strong>name</strong> :  string (default nullName)</li>\n<li><strong>prp_dict</strong> : boolean(default False) - if True type property has to be in the type dictionary</li>\n</ul>\n", "signature": "(self, val={'prp': '-'}, name='', prp_dict=False)", "funcdef": "def"}, {"fullname": "ES.ESValue.PropertyValue.Simple", "modulename": "ES.ESValue", "qualname": "PropertyValue.Simple", "type": "function", "doc": "<p>PropertyValue built with a value (property type)</p>\n", "signature": "(cls, prp, name='simple', prp_dict=False)", "funcdef": "def"}, {"fullname": "ES.ESValue.PropertyValue.Box", "modulename": "ES.ESValue", "qualname": "PropertyValue.Box", "type": "function", "doc": "<p>PropertyValue built with a value (property type)</p>\n", "signature": "(cls, prp, name='box', prp_dict=False)", "funcdef": "def"}, {"fullname": "ES.ESValue.PropertyValue.from_obj", "modulename": "ES.ESValue", "qualname": "PropertyValue.from_obj", "type": "function", "doc": "<p>ESValue function (see ESValue.from_obj)</p>\n", "signature": "(cls, bs)", "funcdef": "def"}, {"fullname": "ES.ESValue.PropertyValue.link", "modulename": "ES.ESValue", "qualname": "PropertyValue.link", "type": "function", "doc": "<p>return the link (string) between self.value and other.value :</p>\n\n<ul>\n<li>equals     : if self and other are the same</li>\n<li>disjoint   : if the self's key/val are all different from other's key/val</li>\n<li>within     : if all self's key/val are included in other's key/val</li>\n<li>contains   : if all other's key/val are included in self's key/val</li>\n<li>intersects : in the others cases</li>\n</ul>\n", "signature": "(self, other)", "funcdef": "def"}, {"fullname": "ES.ESValue.PropertyValue.nullValue", "modulename": "ES.ESValue", "qualname": "PropertyValue.nullValue", "type": "function", "doc": "<p>return nullPrp value</p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "ES.ESValue.PropertyValue.vSimple", "modulename": "ES.ESValue", "qualname": "PropertyValue.vSimple", "type": "function", "doc": "<p>return simple value (type for the property) in a string format or in a object format</p>\n", "signature": "(self, string=False)", "funcdef": "def"}, {"fullname": "ES.ESValue.NamedValue", "modulename": "ES.ESValue", "qualname": "NamedValue", "type": "class", "doc": "<p>This class represent a simple value with an associated string.</p>\n\n<p><em>Attributes (for @property see methods)</em> :</p>\n\n<ul>\n<li><strong>value</strong> : any json object</li>\n<li><strong>name</strong> : String</li>\n</ul>\n\n<p>The methods defined in this class are :</p>\n\n<p><em>constructor</em></p>\n\n<ul>\n<li><code>NamedValue.from_obj</code> (see  <code>ESValue.from_obj</code>)</li>\n</ul>\n\n<p><em>getters</em></p>\n\n<ul>\n<li><code>NamedValue.vSimple</code></li>\n</ul>\n", "bases": "ESValue"}, {"fullname": "ES.ESValue.NamedValue.__init__", "modulename": "ES.ESValue", "qualname": "NamedValue.__init__", "type": "function", "doc": "<p>NamedValue constructor.</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>val</strong> :  any simple object (default nullVal)</li>\n<li><strong>name</strong> : string (default nullName)</li>\n</ul>\n", "signature": "(self, val=nan, name='')", "funcdef": "def"}, {"fullname": "ES.ESValue.NamedValue.from_obj", "modulename": "ES.ESValue", "qualname": "NamedValue.from_obj", "type": "function", "doc": "<p>ESValue function (see ESValue.from_obj)</p>\n", "signature": "(cls, bs)", "funcdef": "def"}, {"fullname": "ES.ESValue.NamedValue.nullValue", "modulename": "ES.ESValue", "qualname": "NamedValue.nullValue", "type": "function", "doc": "<p>return nullVal value</p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "ES.ESValue.NamedValue.vSimple", "modulename": "ES.ESValue", "qualname": "NamedValue.vSimple", "type": "function", "doc": "<p>return float value in string or object format</p>\n", "signature": "(self, string=False)", "funcdef": "def"}, {"fullname": "ES.ESValue.ExternValue", "modulename": "ES.ESValue", "qualname": "ExternValue", "type": "class", "doc": "<p>This class represent a complex (extern) value with an associated string.</p>\n\n<p><em>Attributes (for @property see methods)</em> :</p>\n\n<ul>\n<li><strong>value</strong> : any object</li>\n<li><strong>name</strong> : String</li>\n</ul>\n\n<p>The methods defined in this class are :</p>\n\n<p><em>constructor</em></p>\n\n<ul>\n<li><code>ExternValue.from_obj</code> (see  <code>ESValue.from_obj</code>)</li>\n</ul>\n\n<p><em>getters</em></p>\n\n<ul>\n<li><code>ExternValue.vSimple</code></li>\n</ul>\n", "bases": "ESValue"}, {"fullname": "ES.ESValue.ExternValue.__init__", "modulename": "ES.ESValue", "qualname": "ExternValue.__init__", "type": "function", "doc": "<p>ExternValue constructor.</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>val</strong> :  any simple object (default nullVal)</li>\n<li><strong>name</strong> : string (default nullName)</li>\n</ul>\n", "signature": "(self, val=None, name='', className=None)", "funcdef": "def"}, {"fullname": "ES.ESValue.ExternValue.from_obj", "modulename": "ES.ESValue", "qualname": "ExternValue.from_obj", "type": "function", "doc": "<p>ESValue function (see ESValue.from_obj)</p>\n", "signature": "(cls, bs)", "funcdef": "def"}, {"fullname": "ES.ESValue.ExternValue.nullValue", "modulename": "ES.ESValue", "qualname": "ExternValue.nullValue", "type": "function", "doc": "<p>return nullVal value</p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "ES.ESValue.ExternValue.vSimple", "modulename": "ES.ESValue", "qualname": "ExternValue.vSimple", "type": "function", "doc": "<p>return conversion from value to float</p>\n", "signature": "(self, string=False)", "funcdef": "def"}, {"fullname": "ES.ESValue.ESValueError", "modulename": "ES.ESValue", "qualname": "ESValueError", "type": "class", "doc": "<p>ESValue Exception</p>\n", "bases": "builtins.Exception"}, {"fullname": "ES.ESconstante", "modulename": "ES.ESconstante", "type": "module", "doc": "<p>Created on Sun Aug  1 13:35:28 2021</p>\n\n<p>@author: philippe@loco-labs.io</p>\n\n<p>This module describes the constants and default values used in other modules.</p>\n"}, {"fullname": "ES.ESconstante.Es", "modulename": "ES.ESconstante", "qualname": "Es", "type": "class", "doc": "<p>initialization of constant data.</p>\n"}, {"fullname": "ES.ESconstante.Es.__init__", "modulename": "ES.ESconstante", "qualname": "Es.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, defnone=True)", "funcdef": "def"}, {"fullname": "ES.ESconstante.ES", "modulename": "ES.ESconstante", "qualname": "ES", "type": "variable", "doc": "<p></p>\n", "default_value": " = <ES.ESconstante.Es object>"}, {"fullname": "ES.iindex", "modulename": "ES.iindex", "type": "module", "doc": "<p>Created on Thu May 26 20:30:00 2022</p>\n\n<p>@author: Philippe Thomy</p>\n\n<p>The <code>ES.iindex</code> module contains the <code>Iindex</code> class.</p>\n\n<p>Documentation is available in other pages :</p>\n\n<ul>\n<li>The Json Standard for Iindex is define \n<a href=\"https://github.com/loco-philippe/Environmental-Sensing/tree/main/documentation/IlistJSON-Standard.pdf\">here</a></li>\n<li>The concept of 'indexed list' is describe in \n<a href=\"https://github.com/loco-philippe/Environmental-Sensing/wiki/Indexed-list\">this page</a>.</li>\n<li>The non-regression test are at \n<a href=\"https://github.com/loco-philippe/Environmental-Sensing/blob/main/python/Tests/test_iindex.py\">this page</a></li>\n<li>The <a href=\"https://github.com/loco-philippe/Environmental-Sensing/tree/main/python/Example/Iindex\">examples</a>\nare :\n<ul>\n<li><a href=\"https://github.com/loco-philippe/Environmental-Sensing/blob/main/python/Example/Iindex/Iindex_creation.ipynb\">creation</a></li>\n<li><a href=\"https://github.com/loco-philippe/Environmental-Sensing/blob/main/python/Example/Iindex/Iindex_value.ipynb\">value</a></li>\n<li><a href=\"https://github.com/loco-philippe/Environmental-Sensing/blob/main/python/Example/Iindex/Iindex_update.ipynb\">update</a></li>\n<li><a href=\"https://github.com/loco-philippe/Environmental-Sensing/blob/main/python/Example/Iindex/Iindex_structure.ipynb\">structure</a></li>\n<li><a href=\"https://github.com/loco-philippe/Environmental-Sensing/blob/main/python/Example/Iindex/Iindex_structure-analysis.ipynb\">structure-analysis</a></li>\n</ul></li>\n</ul>\n\n<hr />\n"}, {"fullname": "ES.iindex.Iindex", "modulename": "ES.iindex", "qualname": "Iindex", "type": "class", "doc": "<p>An <code>Iindex</code> is a representation of an index list .</p>\n\n<p><em>Attributes (for dynamic attributes see @property methods)</em> :</p>\n\n<ul>\n<li><strong>name</strong> : name of the Iindex</li>\n<li><strong>codec</strong> : list of values for each key</li>\n<li><strong>keys</strong> : list of code values</li>\n</ul>\n\n<p>The methods defined in this class are :</p>\n\n<p><em>constructor (@classmethod)</em></p>\n\n<ul>\n<li><code>Iindex.Idic</code></li>\n<li><code>Iindex.Iext</code></li>\n<li><code>Iindex.Iobj</code></li>\n<li><code>Iindex.from_parent</code></li>\n<li><code>Iindex.from_obj</code></li>\n</ul>\n\n<p><em>dynamic value (getters @property)</em></p>\n\n<ul>\n<li><code>Iindex.values</code></li>\n<li><code>Iindex.val</code></li>\n<li><code>Iindex.cod</code></li>\n<li><code>Iindex.infos</code></li>\n</ul>\n\n<p><em>add - update methods</em></p>\n\n<ul>\n<li><code>Iindex.append</code>    </li>\n<li><code>Iindex.setcodecvalue</code>   </li>\n<li><code>Iindex.setname</code></li>\n<li><code>Iindex.setkeys</code></li>\n<li><code>Iindex.setlistvalue</code></li>\n<li><code>Iindex.setvalue</code></li>\n</ul>\n\n<p><em>transform methods</em></p>\n\n<ul>\n<li><code>Iindex.coupling</code></li>\n<li><code>Iindex.extendkeys</code></li>\n<li><code>Iindex.full</code></li>\n<li><code>Iindex.reindex</code></li>\n<li><code>Iindex.reorder</code></li>\n<li><code>Iindex.sort</code></li>\n<li><code>Iindex.tocoupled</code></li>\n<li><code>Iindex.tostdcodec</code></li>\n</ul>\n\n<p><em>getters methods</em></p>\n\n<ul>\n<li><code>Iindex.couplinginfos</code></li>\n<li><code>Iindex.derkeys</code></li>\n<li><code>Iindex.getduplicates</code></li>\n<li><code>Iindex.iscrossed</code></li>\n<li><code>Iindex.iscoupled</code></li>\n<li><code>Iindex.isderived</code></li>\n<li><code>Iindex.islinked</code></li>\n<li><code>Iindex.isvalue</code></li>\n<li><code>Iindex.keysfromderkeys</code></li>\n<li><code>Iindex.keytoval</code></li>\n<li><code>Iindex.recordfromvalue</code>   </li>\n<li><code>Iindex.valtokey</code>   </li>\n</ul>\n\n<p><em>export methods</em></p>\n\n<ul>\n<li><code>Iindex.to_obj</code></li>\n<li><code>Iindex.to_numpy</code>   </li>\n<li><code>Iindex.vlist</code></li>\n<li><code>Iindex.vSimple</code></li>\n</ul>\n"}, {"fullname": "ES.iindex.Iindex.__init__", "modulename": "ES.iindex", "qualname": "Iindex.__init__", "type": "function", "doc": "<p>Iindex constructor.</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>codec</strong> :  list (default None) - external different values of index (see data model)</li>\n<li><strong>keys</strong> :  list (default None)  - key value of index (see data model)</li>\n<li><strong>name</strong> : string (default None) - name of index (see data model)</li>\n<li><strong>typevalue</strong> : string (default ES.def_clsName) - typevalue to apply to codec</li>\n<li><strong>lendefault</strong> : integer (default 0) - default len of the generic keys \nif no keys is defined</li>\n</ul>\n", "signature": "(self, codec=None, name=None, keys=None, typevalue=None, lendefault=0)", "funcdef": "def"}, {"fullname": "ES.iindex.Iindex.Iext", "modulename": "ES.iindex", "qualname": "Iindex.Iext", "type": "function", "doc": "<p>Iindex constructor (external list).</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>values</strong> :  list (default None) - external values of index (see data model)</li>\n<li><strong>name</strong> : string (default None) - name of index (see data model)</li>\n<li><strong>typevalue</strong> : string (default ES.def_clsName) - typevalue to apply to codec</li>\n<li><strong>fullcodec</strong> : boolean (default False) - full codec if True</li>\n</ul>\n", "signature": "(cls, values=None, name=None, typevalue=None, fullcodec=False)", "funcdef": "def"}, {"fullname": "ES.iindex.Iindex.Idic", "modulename": "ES.iindex", "qualname": "Iindex.Idic", "type": "function", "doc": "<p>Iindex constructor (external dictionnary).</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>dicvalues</strong> : {name : values}  (see data model)</li>\n<li><strong>fullcodec</strong> : boolean (default False) - full codec if True</li>\n<li><strong>typevalue</strong> : string (default ES.def_clsName) - typevalue to apply to codec</li>\n</ul>\n", "signature": "(cls, dicvalues=None, typevalue=None, fullcodec=False)", "funcdef": "def"}, {"fullname": "ES.iindex.Iindex.from_parent", "modulename": "ES.iindex", "qualname": "Iindex.from_parent", "type": "function", "doc": "<p>Generate an Iindex Object from specific codec and parent keys.</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>codec</strong> : list of objects </li>\n<li><strong>name</strong> : string (default None) - name of index (see data model)</li>\n<li><strong>parent</strong> : Iindex, parent of the new Iindex</li>\n<li><strong>typevalue</strong> : string (default ES.def_clsName) - typevalue to apply to codec</li>\n</ul>\n\n<p><em>Returns</em> : Iindex</p>\n", "signature": "(cls, codec, parent, name=None, typevalue=None)", "funcdef": "def"}, {"fullname": "ES.iindex.Iindex.Iobj", "modulename": "ES.iindex", "qualname": "Iindex.Iobj", "type": "function", "doc": "<p>Generate an Iindex Object from a bytes, json or dict value and from \na keys list (derived Iindex)</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>bs</strong> : bytes, string or dict data to convert</li>\n<li><strong>typevalue</strong> : string (default ES.def_clsName) - typevalue to apply to codec</li>\n<li><strong>extkeys</strong> : list (default None) of int, string or dict data to convert in keys</li>\n</ul>\n\n<p><em>Returns</em> : tuple(code, Iindex)</p>\n", "signature": "(cls, bs, extkeys=None, typevalue=None)", "funcdef": "def"}, {"fullname": "ES.iindex.Iindex.from_obj", "modulename": "ES.iindex", "qualname": "Iindex.from_obj", "type": "function", "doc": "<p>Generate an Iindex Object from a bytes, json or dict value and from \na keys list (derived Iindex)</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>bs</strong> : bytes, string or dict data to convert</li>\n<li><strong>typevalue</strong> : string (default ES.def_clsName) - typevalue to apply to codec</li>\n<li><strong>extkeys</strong> : list (default None) of int, string or dict data to convert in keys</li>\n</ul>\n\n<p><em>Returns</em> : tuple(code, Iindex)</p>\n", "signature": "(cls, bs, extkeys=None, typevalue=None)", "funcdef": "def"}, {"fullname": "ES.iindex.Iindex.values", "modulename": "ES.iindex", "qualname": "Iindex.values", "type": "variable", "doc": "<p>return values (see data model)</p>\n"}, {"fullname": "ES.iindex.Iindex.val", "modulename": "ES.iindex", "qualname": "Iindex.val", "type": "variable", "doc": "<p>return values conversion to string</p>\n"}, {"fullname": "ES.iindex.Iindex.cod", "modulename": "ES.iindex", "qualname": "Iindex.cod", "type": "variable", "doc": "<p>return codec conversion to string</p>\n"}, {"fullname": "ES.iindex.Iindex.infos", "modulename": "ES.iindex", "qualname": "Iindex.infos", "type": "variable", "doc": "<p>return dict with lencodec, typecodec, rate, disttomin, disttomax</p>\n"}, {"fullname": "ES.iindex.Iindex.append", "modulename": "ES.iindex", "qualname": "Iindex.append", "type": "function", "doc": "<p>add a new value</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>value</strong> : new object value</li>\n<li><strong>typevalue</strong> : string (default ES.def_clsName) - typevalue to apply to value</li>\n<li><strong>unique</strong> :  boolean (default True) - If False, duplication codec if value is present</li>\n</ul>\n\n<p><em>Returns</em> : key of value</p>\n", "signature": "(self, value, typevalue=None, unique=True)", "funcdef": "def"}, {"fullname": "ES.iindex.Iindex.merging", "modulename": "ES.iindex", "qualname": "Iindex.merging", "type": "function", "doc": "<p>Create a new Iindex with values are tuples of listidx Iindex values</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>listidx</strong> : list of Iindex to be merged.</li>\n<li><strong>name</strong> : string (default : None) - Name of the new Iindex</li>\n</ul>\n\n<p><em>Returns</em> : new Iindex</p>\n", "signature": "(listidx, name=None)", "funcdef": "def"}, {"fullname": "ES.iindex.Iindex.coupling", "modulename": "ES.iindex", "qualname": "Iindex.coupling", "type": "function", "doc": "<p>Transform indexes in coupled or derived indexes (codec extension).\nIf derived option is True, self.codec is extended and idx codec not,\nelse, both are coupled and both codec are extended.</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>idx</strong> : single Iindex or list of Iindex to be coupled or derived.</li>\n<li><strong>derived</strong> : boolean (default : True)</li>\n</ul>\n\n<p><em>Returns</em> : tuple with duplicate records (errors)</p>\n", "signature": "(self, idx, derived=True)", "funcdef": "def"}, {"fullname": "ES.iindex.Iindex.couplinginfos", "modulename": "ES.iindex", "qualname": "Iindex.couplinginfos", "type": "function", "doc": "<p>return a dict with the coupling info between other (lencoupling, rate, \ndisttomin, disttomax, distmin, distmax, diff, typecoupl)</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>other</strong> : other index to compare</li>\n<li><strong>default</strong> : comparison with default codec </li>\n</ul>\n\n<p><em>Returns</em> : dict</p>\n", "signature": "(self, other, default=False)", "funcdef": "def"}, {"fullname": "ES.iindex.Iindex.derkeys", "modulename": "ES.iindex", "qualname": "Iindex.derkeys", "type": "function", "doc": "<p>return keys derived from parent keys</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>parent</strong> : Iindex - parent</li>\n</ul>\n\n<p><em>Returns</em> : list of keys</p>\n", "signature": "(self, parent)", "funcdef": "def"}, {"fullname": "ES.iindex.Iindex.extendkeys", "modulename": "ES.iindex", "qualname": "Iindex.extendkeys", "type": "function", "doc": "<p>add keys to the Iindex</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>keys</strong> : list of int (value lower or equal than actual keys)</li>\n</ul>\n\n<p><em>Returns</em> : None</p>\n", "signature": "(self, keys)", "funcdef": "def"}, {"fullname": "ES.iindex.Iindex.full", "modulename": "ES.iindex", "qualname": "Iindex.full", "type": "function", "doc": "<p>tranform a list of indexes in crossed indexes (value extension).</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>listidx</strong> : list of Iindex to transform</li>\n</ul>\n\n<p><em>Returns</em> : tuple of records added</p>\n", "signature": "(listidx)", "funcdef": "def"}, {"fullname": "ES.iindex.Iindex.getduplicates", "modulename": "ES.iindex", "qualname": "Iindex.getduplicates", "type": "function", "doc": "<p>return tuple of items with duplicate codec</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "ES.iindex.Iindex.iscrossed", "modulename": "ES.iindex", "qualname": "Iindex.iscrossed", "type": "function", "doc": "<p>return True if self is crossed to other</p>\n", "signature": "(self, other)", "funcdef": "def"}, {"fullname": "ES.iindex.Iindex.iscoupled", "modulename": "ES.iindex", "qualname": "Iindex.iscoupled", "type": "function", "doc": "<p>return True if self is coupled to other</p>\n", "signature": "(self, other)", "funcdef": "def"}, {"fullname": "ES.iindex.Iindex.isderived", "modulename": "ES.iindex", "qualname": "Iindex.isderived", "type": "function", "doc": "<p>return True if self is derived from other</p>\n", "signature": "(self, other)", "funcdef": "def"}, {"fullname": "ES.iindex.Iindex.islinked", "modulename": "ES.iindex", "qualname": "Iindex.islinked", "type": "function", "doc": "<p>return True if self is linked to other</p>\n", "signature": "(self, other)", "funcdef": "def"}, {"fullname": "ES.iindex.Iindex.isvalue", "modulename": "ES.iindex", "qualname": "Iindex.isvalue", "type": "function", "doc": "<p>return True if value is in index values</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>value</strong> : value to check</li>\n<li><strong>extern</strong> : if True, compare value to external representation of self.value, \nelse, internal</li>\n</ul>\n", "signature": "(self, value, extern=True)", "funcdef": "def"}, {"fullname": "ES.iindex.Iindex.json", "modulename": "ES.iindex", "qualname": "Iindex.json", "type": "function", "doc": "<p>Return a formatted object (string, bytes or dict) for the Iindex</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>keys</strong> : list (default None) - list: List of keys to include - None: no list - else: Iindex keys</li>\n<li><strong>typevalue</strong> : string (default None) - type to convert values</li>\n<li><strong>fullcodec</strong> : boolean (default False) - if True, use a full codec</li>\n<li><strong>simpleval</strong> : boolean (default False) - if True, only codec is included</li>\n<li><strong>parent</strong> : integer (default None) - index number of the parent in indexset</li>\n</ul>\n\n<p><em>Parameters (kwargs)</em></p>\n\n<ul>\n<li><strong>encoded</strong> : boolean (default False) - choice for return format (string/bytes if True, dict else)</li>\n<li><strong>encode_format</strong>  : string (default 'json')- choice for return format (json, cbor)</li>\n<li><strong>codif</strong> : dict (default ES.codeb). Numerical value for string in CBOR encoder</li>\n<li><strong>untyped</strong> : boolean (default True) - include dtype in the json if True</li>\n</ul>\n\n<p><em>Returns</em> : string, bytes or dict</p>\n", "signature": "(\n    self,\n    keys=None,\n    typevalue=None,\n    fullcodec=False,\n    simpleval=False,\n    parent=-2,\n    **kwargs\n)", "funcdef": "def"}, {"fullname": "ES.iindex.Iindex.keytoval", "modulename": "ES.iindex", "qualname": "Iindex.keytoval", "type": "function", "doc": "<p>return the value of a key</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>key</strong> : key to convert into values</li>\n<li><strong>extern</strong> : if True, return string representation else, internal value</li>\n</ul>\n\n<p><em>Returns</em></p>\n\n<ul>\n<li><strong>int</strong> : first key finded (None else)</li>\n</ul>\n", "signature": "(self, key, extern=True)", "funcdef": "def"}, {"fullname": "ES.iindex.Iindex.keysfromderkeys", "modulename": "ES.iindex", "qualname": "Iindex.keysfromderkeys", "type": "function", "doc": "<p>return keys from parent keys and derkeys</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>parentkeys</strong> : list of keys from parent</li>\n<li><strong>derkeys</strong> : list of derived keys</li>\n</ul>\n\n<p><em>Returns</em> : list of keys</p>\n", "signature": "(parentkeys, derkeys)", "funcdef": "def"}, {"fullname": "ES.iindex.Iindex.recordfromvalue", "modulename": "ES.iindex", "qualname": "Iindex.recordfromvalue", "type": "function", "doc": "<p>return a list of record number with value</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>value</strong> : value to check</li>\n<li><strong>extern</strong> : if True, compare value to external representation of self.value, \nelse, internal</li>\n</ul>\n\n<p><em>Returns</em></p>\n\n<ul>\n<li><strong>list of int</strong> : list of keys finded (None else)</li>\n</ul>\n", "signature": "(self, value, extern=True)", "funcdef": "def"}, {"fullname": "ES.iindex.Iindex.reindex", "modulename": "ES.iindex", "qualname": "Iindex.reindex", "type": "function", "doc": "<p>apply a reordered codec. If None, a new default codec is apply. </p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>codec</strong> : list (default None) - reordered codec to apply. </li>\n</ul>\n\n<p><em>Returns</em> : self</p>\n", "signature": "(self, codec=None)", "funcdef": "def"}, {"fullname": "ES.iindex.Iindex.reorder", "modulename": "ES.iindex", "qualname": "Iindex.reorder", "type": "function", "doc": "<p>Change the Iindex order with a new order define by sort and reset the codec.</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>sort</strong> : int list (default None)- new record order to apply. If None, no change.</li>\n<li><strong>inplace</strong> : boolean (default True) - if True, new order is apply to self,\nif False a new Iindex is created.</li>\n</ul>\n\n<p><em>Returns</em></p>\n\n<ul>\n<li><strong>Iindex</strong> : self if inplace, new Iindex if not inplace</li>\n</ul>\n", "signature": "(self, sort=None, inplace=True)", "funcdef": "def"}, {"fullname": "ES.iindex.Iindex.setcodecvalue", "modulename": "ES.iindex", "qualname": "Iindex.setcodecvalue", "type": "function", "doc": "<p>update all the oldvalue by newvalue</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>oldvalue</strong> : list of values to replace </li>\n<li><strong>newvalue</strong> : list of new value to apply</li>\n<li><strong>dtype</strong> : str (default None) - cast to apply to the new value </li>\n<li><strong>extern</strong> : if True, the newvalue has external representation, else internal</li>\n</ul>\n\n<p><em>Returns</em> : int - last codec rank updated (-1 if None)</p>\n", "signature": "(self, oldvalue, newvalue, extern=True, dtype=None)", "funcdef": "def"}, {"fullname": "ES.iindex.Iindex.setkeys", "modulename": "ES.iindex", "qualname": "Iindex.setkeys", "type": "function", "doc": "<p>apply new keys (replace codec with extended codec from parent keys)</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>keys</strong> : list of keys to apply</li>\n<li><strong>inplace</strong> : if True, update self data, else create a new Iindex</li>\n</ul>\n\n<p><em>Returns</em> : self or new Iindex</p>\n", "signature": "(self, keys, inplace=True)", "funcdef": "def"}, {"fullname": "ES.iindex.Iindex.setname", "modulename": "ES.iindex", "qualname": "Iindex.setname", "type": "function", "doc": "<p>update the Iindex name </p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>name</strong> : str to set into name</li>\n</ul>\n\n<p><em>Returns</em> : boolean - True if update</p>\n", "signature": "(self, name)", "funcdef": "def"}, {"fullname": "ES.iindex.Iindex.setvalue", "modulename": "ES.iindex", "qualname": "Iindex.setvalue", "type": "function", "doc": "<p>update a value at the rank ind (and update codec and keys) </p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>ind</strong> : rank of the value </li>\n<li><strong>value</strong> : new value </li>\n<li><strong>extern</strong> : if True, the value has external representation, else internal</li>\n<li><strong>dtype</strong> : str (default None) - cast to apply to the new value </li>\n</ul>\n\n<p><em>Returns</em> : None</p>\n", "signature": "(self, ind, value, extern=True, dtype=None)", "funcdef": "def"}, {"fullname": "ES.iindex.Iindex.setlistvalue", "modulename": "ES.iindex", "qualname": "Iindex.setlistvalue", "type": "function", "doc": "<p>update the values (and update codec and keys) </p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>listvalue</strong> : list - list of new values</li>\n<li><strong>typevalue</strong> : str (default None) - class to apply to the new value </li>\n<li><strong>extern</strong> : if True, the value has external representation, else internal</li>\n</ul>\n\n<p><em>Returns</em> : None</p>\n", "signature": "(self, listvalue, extern=True, typevalue=None)", "funcdef": "def"}, {"fullname": "ES.iindex.Iindex.sort", "modulename": "ES.iindex", "qualname": "Iindex.sort", "type": "function", "doc": "<p>Define sorted index with ordered codec.</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>reverse</strong> : boolean (defaut False) - codec is sorted with reverse order</li>\n<li><strong>inplace</strong> : boolean (default True) - if True, new order is apply to self,\nif False a new Iindex is created.</li>\n<li><strong>func</strong>    : function (default str) - key used in the sorted function</li>\n</ul>\n\n<p><em>Return</em></p>\n\n<ul>\n<li><strong>Iindex</strong> : self if inplace, new Iindex if not inplace</li>\n</ul>\n", "signature": "(self, reverse=False, inplace=True, func=<class 'str'>)", "funcdef": "def"}, {"fullname": "ES.iindex.Iindex.tocoupled", "modulename": "ES.iindex", "qualname": "Iindex.tocoupled", "type": "function", "doc": "<p>Transform a derived index in a coupled index (keys extension) and add \nnew values to have the same length as other.</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>other</strong> : index to be coupled.</li>\n<li><strong>coupling</strong> : boolean (default True) - reindex if False</li>\n</ul>\n\n<p><em>Returns</em> : None</p>\n", "signature": "(self, other, coupling=True)", "funcdef": "def"}, {"fullname": "ES.iindex.Iindex.tostdcodec", "modulename": "ES.iindex", "qualname": "Iindex.tostdcodec", "type": "function", "doc": "<p>Transform codec in full or in default codec.</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>inplace</strong> : boolean (default True) - if True, new order is apply to self,</li>\n<li><strong>full</strong> : boolean (default True) - if True reindex with fullcodec</li>\n</ul>\n\n<p><em>Return</em></p>\n\n<ul>\n<li><strong>Iindex</strong> : self if inplace, new Iindex if not inplace</li>\n</ul>\n", "signature": "(self, inplace=False, full=True)", "funcdef": "def"}, {"fullname": "ES.iindex.Iindex.to_numpy", "modulename": "ES.iindex", "qualname": "Iindex.to_numpy", "type": "function", "doc": "<p>Transform Iindex in a Numpy array.</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>func</strong> : function (default None) - function to apply for each value of the Iindex. \nIf func is the 'index' string, values are replaced by raw values.</li>\n<li><strong>kwargs</strong> : parameters to apply to the func function</li>\n</ul>\n\n<p><em>Returns</em> : Numpy Array</p>\n", "signature": "(self, func=None, codec=False, **kwargs)", "funcdef": "def"}, {"fullname": "ES.iindex.Iindex.to_obj", "modulename": "ES.iindex", "qualname": "Iindex.to_obj", "type": "function", "doc": "<p>Return a formatted object (string, bytes or dict) for the Iindex</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>keys</strong> : list (default None) - list: List of keys to include - None: no list - else: Iindex keys</li>\n<li><strong>typevalue</strong> : string (default None) - type to convert values</li>\n<li><strong>fullcodec</strong> : boolean (default False) - if True, use a full codec</li>\n<li><strong>name</strong> : boolean (default True) - if False, name is not included</li>\n<li><strong>simpleval</strong> : boolean (default False) - if True, only codec is included</li>\n<li><strong>listunic</strong> : boolean (default False) - if False, when len(result)=1 return value not list</li>\n<li><strong>parent</strong> : integer (default None) - index number of the parent in indexset</li>\n</ul>\n\n<p><em>Parameters (kwargs)</em></p>\n\n<ul>\n<li><strong>encoded</strong> : boolean (default False) - choice for return format (string/bytes if True, dict else)</li>\n<li><strong>encode_format</strong>  : string (default 'json')- choice for return format (json, cbor)</li>\n<li><strong>codif</strong> : dict (default ES.codeb). Numerical value for string in CBOR encoder</li>\n<li><strong>untyped</strong> : boolean (default False) - include dtype if True</li>\n</ul>\n\n<p><em>Returns</em> : string, bytes or dict</p>\n", "signature": "(\n    self,\n    keys=None,\n    typevalue=None,\n    fullcodec=False,\n    simpleval=False,\n    parent=-2,\n    name=True,\n    listunic=False,\n    **kwargs\n)", "funcdef": "def"}, {"fullname": "ES.iindex.Iindex.valrow", "modulename": "ES.iindex", "qualname": "Iindex.valrow", "type": "function", "doc": "<p>return val for a record</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>row</strong> : record to obtain val</li>\n</ul>\n\n<p><em>Returns</em> : val[row]</p>\n", "signature": "(self, row)", "funcdef": "def"}, {"fullname": "ES.iindex.Iindex.valtokey", "modulename": "ES.iindex", "qualname": "Iindex.valtokey", "type": "function", "doc": "<p>convert a value to a key </p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>value</strong> : value to convert</li>\n<li><strong>extern</strong> : if True, the value has external representation, else internal</li>\n</ul>\n\n<p><em>Returns</em></p>\n\n<ul>\n<li><strong>int</strong> : first key finded (None else)</li>\n</ul>\n", "signature": "(self, value, extern=True)", "funcdef": "def"}, {"fullname": "ES.iindex.Iindex.vlist", "modulename": "ES.iindex", "qualname": "Iindex.vlist", "type": "function", "doc": "<p>Apply a function to values and return the result.</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>func</strong> : function - function to apply to values</li>\n<li><strong>args, kwargs</strong> : parameters for the function</li>\n<li><strong>extern</strong> : if True, the function is apply to external values, else internal</li>\n</ul>\n\n<p><em>Returns</em> : list of func result</p>\n", "signature": "(self, func, *args, extern=True, **kwargs)", "funcdef": "def"}, {"fullname": "ES.iindex.Iindex.vSimple", "modulename": "ES.iindex", "qualname": "Iindex.vSimple", "type": "function", "doc": "<p>Apply a vSimple function to values and return the result.</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>string</strong> : boolean(default False) - if True the values returned are string</li>\n</ul>\n\n<p><em>Returns</em> : list of vSimple values (string or not)</p>\n", "signature": "(self, string=False)", "funcdef": "def"}, {"fullname": "ES.iindex.IindexError", "modulename": "ES.iindex", "qualname": "IindexError", "type": "class", "doc": "<p>Iindex Exception</p>\n", "bases": "builtins.Exception"}, {"fullname": "ES.ilist", "modulename": "ES.ilist", "type": "module", "doc": "<p>Created on Thu May 26 20:30:00 2022</p>\n\n<p>@author: Philippe Thomy</p>\n\n<p>The <code>ES.ilist</code> module contains the <code>Ilist</code> class.</p>\n\n<p>Documentation is available in other pages :</p>\n\n<ul>\n<li>The Json Standard for Ilist is define \n<a href=\"https://github.com/loco-philippe/Environmental-Sensing/tree/main/documentation/IlistJSON-Standard.pdf\">here</a></li>\n<li>The concept of 'indexed list' is describe in \n<a href=\"https://github.com/loco-philippe/Environmental-Sensing/wiki/Indexed-list\">this page</a>.</li>\n<li>The non-regression test are at \n<a href=\"https://github.com/loco-philippe/Environmental-Sensing/blob/main/python/Tests/test_ilist.py\">this page</a></li>\n<li>The <a href=\"https://github.com/loco-philippe/Environmental-Sensing/tree/main/python/Example/Ilist\">examples</a>\nare :\n<ul>\n<li><a href=\"https://github.com/loco-philippe/Environmental-Sensing/blob/main/python/Example/Ilist/Ilist_creation.ipynb\">creation</a></li>\n<li><a href=\"https://github.com/loco-philippe/Environmental-Sensing/blob/main/python/Example/Ilist/Ilist_variable.ipynb\">variable</a></li>\n<li><a href=\"https://github.com/loco-philippe/Environmental-Sensing/blob/main/python/Example/Ilist/Ilist_update.ipynb\">update</a></li>\n<li><a href=\"https://github.com/loco-philippe/Environmental-Sensing/blob/main/python/Example/Ilist/Ilist_structure.ipynb\">structure</a></li>\n<li><a href=\"https://github.com/loco-philippe/Environmental-Sensing/blob/main/python/Example/Ilist/Ilist_structure-analysis.ipynb\">structure-analysis</a></li>\n</ul></li>\n</ul>\n\n<hr />\n"}, {"fullname": "ES.ilist.Ilist", "modulename": "ES.ilist", "qualname": "Ilist", "type": "class", "doc": "<p>An <code>Ilist</code> is a representation of an indexed list.</p>\n\n<p><em>Attributes (for @property see methods)</em> :</p>\n\n<ul>\n<li><strong>lindex</strong> : list of Iindex</li>\n<li><strong>lvarname</strong> : variable name (list of string)</li>\n</ul>\n\n<p>The methods defined in this class are :</p>\n\n<p><em>constructor (@classmethod))</em></p>\n\n<ul>\n<li><code>Ilist.Idic</code></li>\n<li><code>Ilist.Iext</code></li>\n<li><code>Ilist.from_csv</code></li>\n<li><code>Ilist.from_obj</code></li>\n<li><code>Ilist.from_file</code></li>\n</ul>\n\n<p><em>dynamic value (getters @property)</em></p>\n\n<ul>\n<li><code>Ilist.extidx</code></li>\n<li><code>Ilist.extidxext</code></li>\n<li><code>Ilist.idxname</code></li>\n<li><code>Ilist.idxref</code></li>\n<li><code>Ilist.idxlen</code></li>\n<li><code>Ilist.iidx</code></li>\n<li><code>Ilist.keys</code></li>\n<li><code>Ilist.lenindex</code></li>\n<li><code>Ilist.lenidx</code></li>\n<li><code>Ilist.lidx</code></li>\n<li><code>Ilist.lidxrow</code></li>\n<li><code>Ilist.lvar</code></li>\n<li><code>Ilist.lvarrow</code></li>\n<li><code>Ilist.lname</code></li>\n<li><code>Ilist.lunicname</code></li>\n<li><code>Ilist.lunicrow</code></li>\n<li><code>Ilist.setidx</code></li>\n<li><code>Ilist.tiidx</code></li>\n<li><code>Ilist.textidx</code></li>\n<li><code>Ilist.textidxext</code></li>\n</ul>\n\n<p><em>global value (getters @property)</em></p>\n\n<ul>\n<li><code>Ilist.complete</code></li>\n<li><code>Ilist.consistent</code></li>\n<li><code>Ilist.dimension</code></li>\n<li><code>Ilist.lencomplete</code></li>\n<li><code>Ilist.primary</code></li>\n<li><code>Ilist.zip</code></li>\n</ul>\n\n<p><em>selecting - infos methods</em></p>\n\n<ul>\n<li><code>Ilist.couplingmatrix</code></li>\n<li><code>Ilist.idxrecord</code></li>\n<li><code>Ilist.indexinfos</code></li>\n<li><code>Ilist.indicator</code></li>\n<li><code>Ilist.iscanonorder</code></li>\n<li><code>Ilist.isinrecord</code></li>\n<li><code>Ilist.keytoval</code></li>\n<li><code>Ilist.loc</code></li>\n<li><code>Ilist.record</code></li>\n<li><code>Ilist.recidx</code></li>\n<li><code>Ilist.recvar</code></li>\n<li><code>Ilist.valtokey</code></li>\n</ul>\n\n<p><em>add - update methods</em></p>\n\n<ul>\n<li><code>Ilist.addindex</code></li>\n<li><code>Ilist.append</code></li>\n<li><code>Ilist.delindex</code></li>\n<li><code>Ilist.delrecord</code></li>\n<li><code>Ilist.renameindex</code></li>\n<li><code>Ilist.setvar</code></li>\n<li><code>Ilist.setname</code></li>\n<li><code>Ilist.updateindex</code>    </li>\n</ul>\n\n<p><em>structure management - methods</em></p>\n\n<ul>\n<li><code>Ilist.applyfilter</code></li>\n<li><code>Ilist.coupling</code></li>\n<li><code>Ilist.full</code></li>\n<li><code>Ilist.getduplicates</code></li>\n<li><code>Ilist.merge</code></li>\n<li><code>Ilist.reindex</code></li>\n<li><code>Ilist.reorder</code></li>\n<li><code>Ilist.setfilter</code></li>\n<li><code>Ilist.sort</code></li>\n<li><code>Ilist.swapindex</code></li>\n<li><code>Ilist.setcanonorder</code></li>\n<li><code>Ilist.tostdcodec</code></li>\n</ul>\n\n<p><em>exports methods</em></p>\n\n<ul>\n<li><code>Ilist.json</code></li>\n<li><code>Ilist.to_obj</code></li>\n<li><code>Ilist.to_csv</code></li>\n<li><code>Ilist.to_file</code></li>\n<li><code>Ilist.to_numpy</code></li>\n<li><code>Ilist.to_xarray</code></li>\n<li><code>Ilist.vlist</code></li>\n</ul>\n"}, {"fullname": "ES.ilist.Ilist.__init__", "modulename": "ES.ilist", "qualname": "Ilist.__init__", "type": "function", "doc": "<p>Ilist constructor.</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>listidx</strong> :  list (default None) - list of compatible Iindex data</li>\n<li><strong>var</strong> :  int (default None) - row of the variable</li>\n<li><strong>length</strong> :  int (default None)  - len of each Iindex</li>\n<li><strong>reindex</strong> : boolean (default True) - if True, default codec for each Iindex</li>\n<li><strong>typevalue</strong> : str (default ES.def_clsName) - default value class (None or NamedValue)</li>\n</ul>\n", "signature": "(\n    self,\n    listidx=None,\n    length=None,\n    var=None,\n    reindex=True,\n    typevalue=None\n)", "funcdef": "def"}, {"fullname": "ES.ilist.Ilist.Idic", "modulename": "ES.ilist", "qualname": "Ilist.Idic", "type": "function", "doc": "<p>Ilist constructor (external dictionnary).</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>idxdic</strong> : {name : values}  (see data model)</li>\n<li><strong>typevalue</strong> : str (default ES.def_clsName) - default value class (None or NamedValue)</li>\n<li><strong>fullcodec</strong> : boolean (default False) - full codec if True</li>\n<li><strong>var</strong> :  int (default None) - row of the variable</li>\n</ul>\n", "signature": "(cls, idxdic=None, typevalue=None, fullcodec=False, var=None)", "funcdef": "def"}, {"fullname": "ES.ilist.Ilist.Iext", "modulename": "ES.ilist", "qualname": "Ilist.Iext", "type": "function", "doc": "<p>Ilist constructor (external index).</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>idxval</strong> : list of Iindex or list of values (see data model)</li>\n<li><strong>idxname</strong> : list of string (default None) - list of Iindex name (see data model)</li>\n<li><strong>typevalue</strong> : str (default ES.def_clsName) - default value class (None or NamedValue)</li>\n<li><strong>fullcodec</strong> : boolean (default False) - full codec if True</li>\n<li><strong>var</strong> :  int (default None) - row of the variable</li>\n</ul>\n", "signature": "(\n    cls,\n    idxval=None,\n    idxname=None,\n    typevalue=None,\n    fullcodec=False,\n    var=None\n)", "funcdef": "def"}, {"fullname": "ES.ilist.Ilist.from_csv", "modulename": "ES.ilist", "qualname": "Ilist.from_csv", "type": "function", "doc": "<p>Ilist constructor (from a csv file). Each column represents index values.</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>filename</strong> : string (default 'ilist.csv'), name of the file to read</li>\n<li><strong>var</strong> : integer (default None). column row for variable data</li>\n<li><strong>header</strong> : boolean (default True). If True, the first raw is dedicated to names</li>\n<li><strong>dtype</strong> : list of string (default None) - data type for each column (default str)</li>\n<li><strong>optcsv</strong> : dict (default : quoting) - see csv.reader options</li>\n</ul>\n", "signature": "(\n    cls,\n    filename='ilist.csv',\n    var=None,\n    header=True,\n    optcsv={'quoting': 2},\n    dtype=None\n)", "funcdef": "def"}, {"fullname": "ES.ilist.Ilist.from_file", "modulename": "ES.ilist", "qualname": "Ilist.from_file", "type": "function", "doc": "<p>Generate <code>Ilist</code> object from file storage.</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>file</strong> : string - file name (with path)</li>\n<li><strong>forcestring</strong> : boolean (default False) - if True, forces the UTF-8 data format, else the format is calculated</li>\n</ul>\n\n<p><em>Returns</em> : Ilist object</p>\n", "signature": "(cls, file, forcestring=False)", "funcdef": "def"}, {"fullname": "ES.ilist.Ilist.from_obj", "modulename": "ES.ilist", "qualname": "Ilist.from_obj", "type": "function", "doc": "<p>Generate an Ilist Object from a bytes, string or list value</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>bs</strong> : bytes, string or list data to convert</li>\n<li><strong>reindex</strong> : boolean (default True) - if True, default codec for each Iindex</li>\n</ul>\n", "signature": "(cls, bs=None, reindex=True)", "funcdef": "def"}, {"fullname": "ES.ilist.Ilist.complete", "modulename": "ES.ilist", "qualname": "Ilist.complete", "type": "variable", "doc": "<p>return a boolean (True if Ilist is complete and consistent)</p>\n"}, {"fullname": "ES.ilist.Ilist.consistent", "modulename": "ES.ilist", "qualname": "Ilist.consistent", "type": "variable", "doc": "<p>True if all the record are different</p>\n"}, {"fullname": "ES.ilist.Ilist.dimension", "modulename": "ES.ilist", "qualname": "Ilist.dimension", "type": "variable", "doc": "<p>integer : number of primary Iindex</p>\n"}, {"fullname": "ES.ilist.Ilist.extidx", "modulename": "ES.ilist", "qualname": "Ilist.extidx", "type": "variable", "doc": "<p>idx values (see data model)</p>\n"}, {"fullname": "ES.ilist.Ilist.extidxext", "modulename": "ES.ilist", "qualname": "Ilist.extidxext", "type": "variable", "doc": "<p>idx val (see data model)</p>\n"}, {"fullname": "ES.ilist.Ilist.idxname", "modulename": "ES.ilist", "qualname": "Ilist.idxname", "type": "variable", "doc": "<p>list of idx name</p>\n"}, {"fullname": "ES.ilist.Ilist.idxref", "modulename": "ES.ilist", "qualname": "Ilist.idxref", "type": "variable", "doc": "<p>list of idx parent row (idx row if linked)</p>\n"}, {"fullname": "ES.ilist.Ilist.idxlen", "modulename": "ES.ilist", "qualname": "Ilist.idxlen", "type": "variable", "doc": "<p>list of idx codec length</p>\n"}, {"fullname": "ES.ilist.Ilist.indexlen", "modulename": "ES.ilist", "qualname": "Ilist.indexlen", "type": "variable", "doc": "<p>list of index codec length</p>\n"}, {"fullname": "ES.ilist.Ilist.iidx", "modulename": "ES.ilist", "qualname": "Ilist.iidx", "type": "variable", "doc": "<p>list of keys for each idx</p>\n"}, {"fullname": "ES.ilist.Ilist.keys", "modulename": "ES.ilist", "qualname": "Ilist.keys", "type": "variable", "doc": "<p>list of keys for each index</p>\n"}, {"fullname": "ES.ilist.Ilist.lencomplete", "modulename": "ES.ilist", "qualname": "Ilist.lencomplete", "type": "variable", "doc": "<p>number of values if complete (prod(idxlen primary))</p>\n"}, {"fullname": "ES.ilist.Ilist.lenindex", "modulename": "ES.ilist", "qualname": "Ilist.lenindex", "type": "variable", "doc": "<p>number of indexes</p>\n"}, {"fullname": "ES.ilist.Ilist.lenidx", "modulename": "ES.ilist", "qualname": "Ilist.lenidx", "type": "variable", "doc": "<p>number of idx</p>\n"}, {"fullname": "ES.ilist.Ilist.lidx", "modulename": "ES.ilist", "qualname": "Ilist.lidx", "type": "variable", "doc": "<p>list of idx</p>\n"}, {"fullname": "ES.ilist.Ilist.lvar", "modulename": "ES.ilist", "qualname": "Ilist.lvar", "type": "variable", "doc": "<p>list of var</p>\n"}, {"fullname": "ES.ilist.Ilist.lunicrow", "modulename": "ES.ilist", "qualname": "Ilist.lunicrow", "type": "variable", "doc": "<p>list of unic idx row</p>\n"}, {"fullname": "ES.ilist.Ilist.lvarrow", "modulename": "ES.ilist", "qualname": "Ilist.lvarrow", "type": "variable", "doc": "<p>list of var row</p>\n"}, {"fullname": "ES.ilist.Ilist.lidxrow", "modulename": "ES.ilist", "qualname": "Ilist.lidxrow", "type": "variable", "doc": "<p>list of idx row</p>\n"}, {"fullname": "ES.ilist.Ilist.lunicname", "modulename": "ES.ilist", "qualname": "Ilist.lunicname", "type": "variable", "doc": "<p>list of unique index name</p>\n"}, {"fullname": "ES.ilist.Ilist.lname", "modulename": "ES.ilist", "qualname": "Ilist.lname", "type": "variable", "doc": "<p>list of index name</p>\n"}, {"fullname": "ES.ilist.Ilist.primary", "modulename": "ES.ilist", "qualname": "Ilist.primary", "type": "variable", "doc": "<p>list of primary idx</p>\n"}, {"fullname": "ES.ilist.Ilist.setidx", "modulename": "ES.ilist", "qualname": "Ilist.setidx", "type": "variable", "doc": "<p>list of codec for each idx</p>\n"}, {"fullname": "ES.ilist.Ilist.tiidx", "modulename": "ES.ilist", "qualname": "Ilist.tiidx", "type": "variable", "doc": "<p>list of keys for each record</p>\n"}, {"fullname": "ES.ilist.Ilist.textidx", "modulename": "ES.ilist", "qualname": "Ilist.textidx", "type": "variable", "doc": "<p>list of values for each rec</p>\n"}, {"fullname": "ES.ilist.Ilist.textidxext", "modulename": "ES.ilist", "qualname": "Ilist.textidxext", "type": "variable", "doc": "<p>list of val for each rec</p>\n"}, {"fullname": "ES.ilist.Ilist.zip", "modulename": "ES.ilist", "qualname": "Ilist.zip", "type": "variable", "doc": "<p>return a zip format for textidx : tuple(tuple(rec))</p>\n"}, {"fullname": "ES.ilist.Ilist.addindex", "modulename": "ES.ilist", "qualname": "Ilist.addindex", "type": "function", "doc": "<p>add a new index.</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>index</strong> : Iindex - index to add (can be index representation)</li>\n<li><strong>first</strong> : If True insert index at the first row, else at the end</li>\n<li><strong>merge</strong> : create a new index if merge is False</li>\n<li><strong>update</strong> : if True, update actual values if index name is present (and merge is True)</li>\n</ul>\n\n<p><em>Returns</em> : none</p>\n", "signature": "(self, index, first=False, merge=False, update=False)", "funcdef": "def"}, {"fullname": "ES.ilist.Ilist.append", "modulename": "ES.ilist", "qualname": "Ilist.append", "type": "function", "doc": "<p>add a new record.</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>record</strong> :  list of new index values to add to Ilist</li>\n<li><strong>unique</strong> :  boolean (default False) - Append isn't done if unique is True and record present</li>\n<li><strong>dtype</strong> : list of string (default ES.def_dtype) - data type to convert record or\nstring if dtype is available for all indexes</li>\n</ul>\n\n<p><em>Returns</em> : list - key record</p>\n", "signature": "(self, record, unique=False, dtype=None)", "funcdef": "def"}, {"fullname": "ES.ilist.Ilist.applyfilter", "modulename": "ES.ilist", "qualname": "Ilist.applyfilter", "type": "function", "doc": "<p>delete records with defined filter value.\nFilter is deleted after record filtering.</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>reverse</strong> :  boolean (default False) - delete record with filter's value is reverse</li>\n<li><strong>filtname</strong> : string (default ES.filter) - Name of the filter Iindex added </li>\n<li><strong>delfilter</strong> :  boolean (default True) - If True, delete filter's Iindex</li>\n<li><strong>inplace</strong> : boolean (default True) - if True, filter is apply to self,</li>\n</ul>\n\n<p><em>Returns</em> : self or new Ilist</p>\n", "signature": "(\n    self,\n    reverse=False,\n    filtname='$filter',\n    delfilter=True,\n    inplace=True\n)", "funcdef": "def"}, {"fullname": "ES.ilist.Ilist.couplingmatrix", "modulename": "ES.ilist", "qualname": "Ilist.couplingmatrix", "type": "function", "doc": "<p>return a matrix with coupling infos between each idx.\nOne info can be stored in a file (csv format).</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>default</strong> : comparison with default codec </li>\n<li><strong>file</strong> : string (default None) - name of the file to write the matrix</li>\n<li><strong>att</strong> : string - name of the info to store in the file</li>\n</ul>\n\n<p><em>Returns</em> : array of array of dict</p>\n", "signature": "(self, default=False, file=None, att='rate')", "funcdef": "def"}, {"fullname": "ES.ilist.Ilist.coupling", "modulename": "ES.ilist", "qualname": "Ilist.coupling", "type": "function", "doc": "<p>Transform idx with low rate in coupled or derived indexes (codec extension).</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>mat</strong> : array of array (default None) - coupling matrix </li>\n<li><strong>rate</strong> : integer (default 0.1) - threshold to apply coupling.</li>\n<li><strong>derived</strong> : boolean (default : True).If True, indexes are derived, else coupled.</li>\n</ul>\n\n<p><em>Returns</em> : list - coupling infos for each idx</p>\n", "signature": "(self, mat=None, derived=True, rate=0.1)", "funcdef": "def"}, {"fullname": "ES.ilist.Ilist.delrecord", "modulename": "ES.ilist", "qualname": "Ilist.delrecord", "type": "function", "doc": "<p>remove a record.</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>record</strong> :  list - index values to remove to Ilist</li>\n<li><strong>extern</strong> : if True, compare record values to external representation of self.value, \nelse, internal</li>\n</ul>\n\n<p><em>Returns</em> : row deleted</p>\n", "signature": "(self, record, extern=True)", "funcdef": "def"}, {"fullname": "ES.ilist.Ilist.delindex", "modulename": "ES.ilist", "qualname": "Ilist.delindex", "type": "function", "doc": "<p>remove an index.</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>indexname</strong> : string - name of index to remove</li>\n</ul>\n\n<p><em>Returns</em> : none</p>\n", "signature": "(self, indexname)", "funcdef": "def"}, {"fullname": "ES.ilist.Ilist.full", "modulename": "ES.ilist", "qualname": "Ilist.full", "type": "function", "doc": "<p>tranform a list of indexes in crossed indexes (value extension).</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>indexname</strong> : list of string - name of indexes to transform</li>\n<li><strong>reindex</strong> : boolean (default False) - if True, set default codec before transformation</li>\n<li><strong>fillvalue</strong> : object value used for var extension</li>\n<li><strong>inplace</strong> : boolean (default True) - if True, filter is apply to self,</li>\n<li><strong>complete</strong> : boolean (default True) - if True, Iindex are ordered in canonical order</li>\n</ul>\n\n<p><em>Returns</em> : self or new Ilist</p>\n", "signature": "(\n    self,\n    reindex=False,\n    indexname=None,\n    fillvalue='-',\n    inplace=True,\n    complete=True\n)", "funcdef": "def"}, {"fullname": "ES.ilist.Ilist.getduplicates", "modulename": "ES.ilist", "qualname": "Ilist.getduplicates", "type": "function", "doc": "<p>check duplicate cod in a list of indexes. Result is add in a new index or returned.</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>indexname</strong> : list of string - name of indexes to check</li>\n<li><strong>resindex</strong> : string (default None) - Add a new index with check result</li>\n</ul>\n\n<p><em>Returns</em> : list of int - list of rows with duplicate cod</p>\n", "signature": "(self, indexname=None, resindex=None)", "funcdef": "def"}, {"fullname": "ES.ilist.Ilist.iscanonorder", "modulename": "ES.ilist", "qualname": "Ilist.iscanonorder", "type": "function", "doc": "<p>return True if primary indexes have canonical ordered keys</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "ES.ilist.Ilist.isinrecord", "modulename": "ES.ilist", "qualname": "Ilist.isinrecord", "type": "function", "doc": "<p>Check if record is present in self.</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>record</strong> : list - value for each Iindex</li>\n<li><strong>extern</strong> : if True, compare record values to external representation of self.value, \nelse, internal</li>\n</ul>\n\n<p><em>Returns boolean</em> : True if found</p>\n", "signature": "(self, record, extern=True)", "funcdef": "def"}, {"fullname": "ES.ilist.Ilist.idxrecord", "modulename": "ES.ilist", "qualname": "Ilist.idxrecord", "type": "function", "doc": "<p>return rec array (without variable) from complete record (with variable)</p>\n", "signature": "(self, record)", "funcdef": "def"}, {"fullname": "ES.ilist.Ilist.indexinfos", "modulename": "ES.ilist", "qualname": "Ilist.indexinfos", "type": "function", "doc": "<p>return an array with infos of each index :\n    - num, name, cat, typecoupl, diff, parent, pname, pparent, linkrate\n    - lencodec, min, max, typecodec, rate, disttomin, disttomax (base info)</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>keys</strong> : list (default none) - list of information to return (reduct dict), all if None</li>\n<li><strong>default</strong> : build infos with default codec if new coupling matrix is calculated</li>\n<li><strong>mat</strong> : array of array (default None) - coupling matrix </li>\n<li><strong>base</strong> : boolean (default False) - if True, add Iindex infos</li>\n</ul>\n\n<p><em>Returns</em> : array</p>\n", "signature": "(self, keys=None, mat=None, default=False, base=False)", "funcdef": "def"}, {"fullname": "ES.ilist.Ilist.indicator", "modulename": "ES.ilist", "qualname": "Ilist.indicator", "type": "function", "doc": "<p>generate Ilist indicators: ol (object lightness), ul (unicity level), gain (sizegain)</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>fullsize</strong> : int (default none) - size with fullcodec</li>\n<li><strong>size</strong> : int (default none) - size with existing codec</li>\n<li><strong>indexinfos</strong> : list (default None) - indexinfos data</li>\n</ul>\n\n<p><em>Returns</em> : dict</p>\n", "signature": "(self, fullsize=None, size=None, indexinfos=None)", "funcdef": "def"}, {"fullname": "ES.ilist.Ilist.json", "modulename": "ES.ilist", "qualname": "Ilist.json", "type": "function", "doc": "<p>Return json dict, json string or Cbor binary.</p>\n\n<p><em>Parameters (kwargs)</em></p>\n\n<ul>\n<li><strong>encoded</strong> : boolean (default False) - choice for return format (bynary if True, dict else)</li>\n<li><strong>encode_format</strong> : string (default 'json') - choice for return format (json, bson or cbor)</li>\n<li><strong>json_res_index</strong> : default False - if True add the index to the value</li>\n<li><strong>order</strong> : default [] - list of ordered index</li>\n<li><strong>codif</strong> : dict (default {}). Numerical value for string in CBOR encoder</li>\n</ul>\n\n<p><em>Returns</em> : string or dict</p>\n", "signature": "(self, **kwargs)", "funcdef": "def"}, {"fullname": "ES.ilist.Ilist.keytoval", "modulename": "ES.ilist", "qualname": "Ilist.keytoval", "type": "function", "doc": "<p>convert a keys list (key for each idx) to a values list (value for each idx).</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>listkey</strong> : key for each idx</li>\n<li><strong>extern</strong> : boolean (default True) - if True, compare rec to val else to values </li>\n</ul>\n\n<p><em>Returns</em></p>\n\n<ul>\n<li><strong>list</strong> : value for each index</li>\n</ul>\n", "signature": "(self, listkey, extern=True)", "funcdef": "def"}, {"fullname": "ES.ilist.Ilist.loc", "modulename": "ES.ilist", "qualname": "Ilist.loc", "type": "function", "doc": "<p>Return variable value corresponding to a list of idx values.</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>rec</strong> : list - value for each idx</li>\n<li><strong>extern</strong> : boolean (default True) - if True, compare rec to val else to values </li>\n</ul>\n\n<p><em>Returns</em></p>\n\n<ul>\n<li><strong>object</strong> : variable value or None if not found</li>\n</ul>\n", "signature": "(self, rec, extern=True)", "funcdef": "def"}, {"fullname": "ES.ilist.Ilist.merge", "modulename": "ES.ilist", "qualname": "Ilist.merge", "type": "function", "doc": "<p>Merge method replaces Ilist objects included in variable data into its constituents.</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>name</strong> : str (default 'merge') - name of the new Ilist object</li>\n<li><strong>fillvalue</strong> : object (default nan) - value used for the additional data </li>\n<li><strong>mergeidx</strong> : create a new index if mergeidx is False</li>\n<li><strong>updateidx</strong> : if True (and mergeidx is True), update actual values if index name is present </li>\n</ul>\n\n<p><em>Returns</em></p>\n\n<ul>\n<li><strong>Ilist</strong> : merged Ilist</li>\n</ul>\n", "signature": "(self, name='merge', fillvalue=nan, mergeidx=False, updateidx=False)", "funcdef": "def"}, {"fullname": "ES.ilist.Ilist.merging", "modulename": "ES.ilist", "qualname": "Ilist.merging", "type": "function", "doc": "<p>add a new index in Ilist object build with indexes define in listname</p>\n", "signature": "(self, listname=None)", "funcdef": "def"}, {"fullname": "ES.ilist.Ilist.nindex", "modulename": "ES.ilist", "qualname": "Ilist.nindex", "type": "function", "doc": "<p>index with name equal to attribute name</p>\n", "signature": "(self, name)", "funcdef": "def"}, {"fullname": "ES.ilist.Ilist.record", "modulename": "ES.ilist", "qualname": "Ilist.record", "type": "function", "doc": "<p>return the record at the row</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>row</strong> : int - row of the record</li>\n<li><strong>extern</strong> : boolean (default True) - if True, return val record else value record</li>\n</ul>\n\n<p><em>Returns</em></p>\n\n<ul>\n<li><strong>list</strong> : val record or value record</li>\n</ul>\n", "signature": "(self, row, extern=True)", "funcdef": "def"}, {"fullname": "ES.ilist.Ilist.recidx", "modulename": "ES.ilist", "qualname": "Ilist.recidx", "type": "function", "doc": "<p>return the list of idx val or values at the row</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>row</strong> : int - row of the record</li>\n<li><strong>extern</strong> : boolean (default True) - if True, return val rec else value rec</li>\n</ul>\n\n<p><em>Returns</em></p>\n\n<ul>\n<li><strong>list</strong> : val or value for idx</li>\n</ul>\n", "signature": "(self, row, extern=True)", "funcdef": "def"}, {"fullname": "ES.ilist.Ilist.recvar", "modulename": "ES.ilist", "qualname": "Ilist.recvar", "type": "function", "doc": "<p>return the list of var val or values at the row</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>row</strong> : int - row of the record</li>\n<li><strong>extern</strong> : boolean (default True) - if True, return val rec else value rec</li>\n</ul>\n\n<p><em>Returns</em></p>\n\n<ul>\n<li><strong>list</strong> : val or value for var</li>\n</ul>\n", "signature": "(self, row, extern=True)", "funcdef": "def"}, {"fullname": "ES.ilist.Ilist.reindex", "modulename": "ES.ilist", "qualname": "Ilist.reindex", "type": "function", "doc": "<p>Calculate a new default codec for each index (Return self)</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "ES.ilist.Ilist.renameindex", "modulename": "ES.ilist", "qualname": "Ilist.renameindex", "type": "function", "doc": "<p>replace an index name 'oldname' by a new one 'newname'.</p>\n", "signature": "(self, oldname, newname)", "funcdef": "def"}, {"fullname": "ES.ilist.Ilist.reorder", "modulename": "ES.ilist", "qualname": "Ilist.reorder", "type": "function", "doc": "<p>Reorder records in the order define by 'recorder'</p>\n", "signature": "(self, recorder=None)", "funcdef": "def"}, {"fullname": "ES.ilist.Ilist.setcanonorder", "modulename": "ES.ilist", "qualname": "Ilist.setcanonorder", "type": "function", "doc": "<p>Set the canonical index order : primary - secondary/unique - variable.\nSet the canonical keys order : ordered keys in the first columns</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "ES.ilist.Ilist.setfilter", "modulename": "ES.ilist", "qualname": "Ilist.setfilter", "type": "function", "doc": "<p>Add a filter index with boolean values</p>\n\n<ul>\n<li><strong>filt</strong> : list of boolean - values of the filter idx to add</li>\n<li><strong>first</strong> : boolean (default False) - If True insert index at the first row, else at the end</li>\n<li><strong>filtname</strong> : string (default ES.filter) - Name of the filter Iindex added </li>\n</ul>\n\n<p><em>Returns</em> : none</p>\n", "signature": "(self, filt=None, first=False, filtname='$filter')", "funcdef": "def"}, {"fullname": "ES.ilist.Ilist.setname", "modulename": "ES.ilist", "qualname": "Ilist.setname", "type": "function", "doc": "<p>Update Iindex name by the name in listname</p>\n", "signature": "(self, listname=None)", "funcdef": "def"}, {"fullname": "ES.ilist.Ilist.setvar", "modulename": "ES.ilist", "qualname": "Ilist.setvar", "type": "function", "doc": "<p>Define a var index by the name or the index row</p>\n", "signature": "(self, var=None)", "funcdef": "def"}, {"fullname": "ES.ilist.Ilist.sort", "modulename": "ES.ilist", "qualname": "Ilist.sort", "type": "function", "doc": "<p>Sort data following the index order and apply the ascending or descending \nsort function to values.</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>order</strong> : list (default None)- new order of index to apply. If None or [], \nthe sort function is applied to the existing order of indexes.</li>\n<li><strong>reverse</strong> : boolean (default False)- ascending if True, descending if False</li>\n<li><strong>func</strong>    : function (default str) - parameter key used in the sorted function</li>\n</ul>\n\n<p><em>Returns</em> : None</p>\n", "signature": "(self, order=None, reverse=False, func=<class 'str'>)", "funcdef": "def"}, {"fullname": "ES.ilist.Ilist.swapindex", "modulename": "ES.ilist", "qualname": "Ilist.swapindex", "type": "function", "doc": "<p>Change the order of the index .</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>order</strong> : list of int - new order of index to apply.</li>\n</ul>\n\n<p><em>Returns</em> : none</p>\n", "signature": "(self, order)", "funcdef": "def"}, {"fullname": "ES.ilist.Ilist.tostdcodec", "modulename": "ES.ilist", "qualname": "Ilist.tostdcodec", "type": "function", "doc": "<p>Transform all codec in full or default codec.</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>inplace</strong> : boolean  (default False) - if True apply transformation to self, else to a new Ilist</li>\n<li><strong>full</strong> : boolean (default True)- full codec if True, default if False</li>\n</ul>\n\n<p><em>Return Ilist</em> : self or new Ilist</p>\n", "signature": "(self, inplace=False, full=True)", "funcdef": "def"}, {"fullname": "ES.ilist.Ilist.to_csv", "modulename": "ES.ilist", "qualname": "Ilist.to_csv", "type": "function", "doc": "<p>Generate a csv file with Ilist data (a column for each index)</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>filename</strong> : string (default 'ilist.csv') - name of the file to create</li>\n<li><strong>ifunc</strong> : list of function (default None) - function to apply to indexes\nbefore writting csv file</li>\n<li><strong>order</strong> : list of integer (default None) - ordered list of index in columns</li>\n<li><strong>header</strong> : boolean (default True). If True, the first raw is dedicated to names</li>\n<li><strong>optcsv</strong> : parameter for csv.writer</li>\n<li><strong>kwargs</strong> : parameter for ifunc</li>\n</ul>\n\n<p><em>Returns</em> : size of csv file</p>\n", "signature": "(\n    self,\n    filename='ilist.csv',\n    ifunc=None,\n    header=True,\n    optcsv={'quoting': 2},\n    **kwargs\n)", "funcdef": "def"}, {"fullname": "ES.ilist.Ilist.to_xarray", "modulename": "ES.ilist", "qualname": "Ilist.to_xarray", "type": "function", "doc": "<p>Complete the Ilist and generate a Xarray DataArray with the dimension define by ind.</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>info</strong> : boolean (default False) - if True, add _dict attributes to attrs Xarray</li>\n<li><strong>axes</strong> : list (default none) - list of index to be completed. If [],\nself.axes is used.</li>\n<li><strong>dimmax</strong> : int (default -1) - max Xarray dimension (only if axes=[])</li>\n<li><strong>fillvalue</strong> : object (default '?') - value used for the new extval</li>\n<li><strong>func</strong> : function (default none) - function to apply to extval before export</li>\n<li><strong>ifunc</strong> : list of function (default []) - function to apply to\nextidx before export</li>\n<li><strong>name</strong> : string (default valname) - DataArray name</li>\n<li><strong>kwargs</strong> : parameter for func and ifunc</li>\n</ul>\n\n<p><em>Returns</em> : none</p>\n", "signature": "(\n    self,\n    info=False,\n    axes=None,\n    dimmax=-1,\n    fillvalue='?',\n    lisfunc=None,\n    name='',\n    **kwargs\n)", "funcdef": "def"}, {"fullname": "ES.ilist.Ilist.to_file", "modulename": "ES.ilist", "qualname": "Ilist.to_file", "type": "function", "doc": "<p>Generate file to display <code>Ilist</code> data.</p>\n\n<p><em>Parameters (kwargs)</em></p>\n\n<ul>\n<li><strong>file</strong> : string - file name (with path)</li>\n<li><strong>kwargs</strong> : see 'to_obj' parameters</li>\n</ul>\n\n<p><em>Returns</em> : Integer - file lenght (bytes)</p>\n", "signature": "(self, file, **kwargs)", "funcdef": "def"}, {"fullname": "ES.ilist.Ilist.to_obj", "modulename": "ES.ilist", "qualname": "Ilist.to_obj", "type": "function", "doc": "<p>Return a formatted object (json string, cbor bytes or json dict). </p>\n\n<p><em>Parameters (kwargs)</em></p>\n\n<ul>\n<li><strong>encoded</strong> : boolean (default False) - choice for return format (string/bytes if True, dict else)</li>\n<li><strong>encode_format</strong>  : string (default 'json')- choice for return format (json, cbor)</li>\n<li><strong>codif</strong> : dict (default ES.codeb). Numerical value for string in CBOR encoder</li>\n<li><strong>fullcodec</strong> : boolean (default False) - if True, each index is with a full codec</li>\n<li><strong>defaultcodec</strong> : boolean (default False) - if True, each index is whith a default codec</li>\n<li><strong>name</strong> : boolean (default False) - if False, default index name are not included</li>\n</ul>\n\n<p><em>Returns</em> : string, bytes or dict</p>\n", "signature": "(self, indexinfos=None, **kwargs)", "funcdef": "def"}, {"fullname": "ES.ilist.Ilist.updateindex", "modulename": "ES.ilist", "qualname": "Ilist.updateindex", "type": "function", "doc": "<p>update values of an index.</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>listvalue</strong> : list - index values to replace</li>\n<li><strong>index</strong> : integer - index row to update</li>\n<li><strong>typevalue</strong> : str (default None) - class to apply to the new value </li>\n<li><strong>extern</strong> : if True, the listvalue has external representation, else internal</li>\n</ul>\n\n<p><em>Returns</em> : none</p>\n", "signature": "(self, listvalue, index, extern=True, typevalue=None)", "funcdef": "def"}, {"fullname": "ES.ilist.Ilist.valtokey", "modulename": "ES.ilist", "qualname": "Ilist.valtokey", "type": "function", "doc": "<p>convert a rec list (value or val for each idx) to a key list (key for each idx).</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>rec</strong> : list of value or val for each idx</li>\n<li><strong>extern</strong> : if True, the rec value has external representation, else internal</li>\n</ul>\n\n<p><em>Returns</em></p>\n\n<ul>\n<li><strong>list of int</strong> : rec key for each idx</li>\n</ul>\n", "signature": "(self, rec, extern=True)", "funcdef": "def"}, {"fullname": "ES.ilist.Ilist.vlist", "modulename": "ES.ilist", "qualname": "Ilist.vlist", "type": "function", "doc": "<p>Apply a function to an index and return the result.</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>func</strong> : function (default none) - function to apply to extval or extidx</li>\n<li><strong>args, kwargs</strong> : parameters for the function</li>\n<li><strong>index</strong> : integer - index to update (index=-1 for variable)</li>\n</ul>\n\n<p><em>Returns</em> : list of func result</p>\n", "signature": "(self, *args, func=None, index=-1, **kwargs)", "funcdef": "def"}, {"fullname": "ES.ilist.IlistError", "modulename": "ES.ilist", "qualname": "IlistError", "type": "class", "doc": "<p>Ilist Exception</p>\n", "bases": "builtins.Exception"}, {"fullname": "ES.openlocationcode", "modulename": "ES.openlocationcode", "type": "module", "doc": "<p></p>\n"}, {"fullname": "ES.openlocationcode.isValid", "modulename": "ES.openlocationcode", "qualname": "isValid", "type": "function", "doc": "<p>Determines if a code is valid.\nTo be valid, all characters must be from the Open Location Code character\nset with at most one separator. The separator can be in any even-numbered\nposition up to the eighth digit.</p>\n", "signature": "(code)", "funcdef": "def"}, {"fullname": "ES.openlocationcode.isShort", "modulename": "ES.openlocationcode", "qualname": "isShort", "type": "function", "doc": "<p>Determines if a code is a valid short code.\nA short Open Location Code is a sequence created by removing four or more\ndigits from an Open Location Code. It must include a separator\ncharacter.</p>\n", "signature": "(code)", "funcdef": "def"}, {"fullname": "ES.openlocationcode.isFull", "modulename": "ES.openlocationcode", "qualname": "isFull", "type": "function", "doc": "<p>Determines if a code is a valid full Open Location Code.\nNot all possible combinations of Open Location Code characters decode to\nvalid latitude and longitude values. This checks that a code is valid\nand also that the latitude and longitude values are legal. If the prefix\ncharacter is present, it must be the first character. If the separator\ncharacter is present, it must be after four characters.</p>\n", "signature": "(code)", "funcdef": "def"}, {"fullname": "ES.openlocationcode.encode", "modulename": "ES.openlocationcode", "qualname": "encode", "type": "function", "doc": "<p>Encode a location into an Open Location Code.\nProduces a code of the specified length, or the default length if no length\nis provided.\nThe length determines the accuracy of the code. The default length is\n10 characters, returning a code of approximately 13.5x13.5 meters. Longer\ncodes represent smaller areas, but lengths &gt; 14 are sub-centimetre and so\n11 or 12 are probably the limit of useful codes.\nArgs:\n  latitude: A latitude in signed decimal degrees. Will be clipped to the\n      range -90 to 90.\n  longitude: A longitude in signed decimal degrees. Will be normalised to\n      the range -180 to 180.\n  codeLength: The number of significant digits in the output code, not\n      including any separator characters.</p>\n", "signature": "(latitude, longitude, codeLength=10)", "funcdef": "def"}, {"fullname": "ES.openlocationcode.decode", "modulename": "ES.openlocationcode", "qualname": "decode", "type": "function", "doc": "<p>Decodes an Open Location Code into the location coordinates.\nReturns a CodeArea object that includes the coordinates of the bounding\nbox - the lower left, center and upper right.\nArgs:\n  code: The Open Location Code to decode.\nReturns:\n  A CodeArea object that provides the latitude and longitude of two of the\n  corners of the area, the center, and the length of the original code.</p>\n", "signature": "(code)", "funcdef": "def"}, {"fullname": "ES.openlocationcode.recoverNearest", "modulename": "ES.openlocationcode", "qualname": "recoverNearest", "type": "function", "doc": "<p>Recover the nearest matching code to a specified location.\nGiven a short code of between four and seven characters, this recovers\nthe nearest matching full code to the specified location.\nArgs:\n  code: A valid OLC character sequence.\n  referenceLatitude: The latitude (in signed decimal degrees) to use to\n      find the nearest matching full code.\n  referenceLongitude: The longitude (in signed decimal degrees) to use\n      to find the nearest matching full code.\nReturns:\n  The nearest full Open Location Code to the reference location that matches\n  the short code. If the passed code was not a valid short code, but was a\n  valid full code, it is returned with proper capitalization but otherwise\n  unchanged.</p>\n", "signature": "(code, referenceLatitude, referenceLongitude)", "funcdef": "def"}, {"fullname": "ES.openlocationcode.shorten", "modulename": "ES.openlocationcode", "qualname": "shorten", "type": "function", "doc": "<p>Remove characters from the start of an OLC code.\nThis uses a reference location to determine how many initial characters\ncan be removed from the OLC code. The number of characters that can be\nremoved depends on the distance between the code center and the reference\nlocation.\nThe minimum number of characters that will be removed is four. If more than\nfour characters can be removed, the additional characters will be replaced\nwith the padding character. At most eight characters will be removed.\nThe reference location must be within 50% of the maximum range. This ensures\nthat the shortened code will be able to be recovered using slightly different\nlocations.\nArgs:\n  code: A full, valid code to shorten.\n  latitude: A latitude, in signed decimal degrees, to use as the reference\n      point.\n  longitude: A longitude, in signed decimal degrees, to use as the reference\n      point.\nReturns:\n  Either the original code, if the reference location was not close enough,\n  or the .</p>\n", "signature": "(code, latitude, longitude)", "funcdef": "def"}, {"fullname": "ES.openlocationcode.clipLatitude", "modulename": "ES.openlocationcode", "qualname": "clipLatitude", "type": "function", "doc": "<p>Clip a latitude into the range -90 to 90.\nArgs:\n  latitude: A latitude in signed decimal degrees.</p>\n", "signature": "(latitude)", "funcdef": "def"}, {"fullname": "ES.openlocationcode.computeLatitudePrecision", "modulename": "ES.openlocationcode", "qualname": "computeLatitudePrecision", "type": "function", "doc": "<p>Compute the latitude precision value for a given code length. Lengths &lt;=\n10 have the same precision for latitude and longitude, but lengths &gt; 10\nhave different precisions due to the grid method having fewer columns than\nrows.</p>\n", "signature": "(codeLength)", "funcdef": "def"}, {"fullname": "ES.openlocationcode.normalizeLongitude", "modulename": "ES.openlocationcode", "qualname": "normalizeLongitude", "type": "function", "doc": "<p>Normalize a longitude into the range -180 to 180, not including 180.\nArgs:\n  longitude: A longitude in signed decimal degrees.</p>\n", "signature": "(longitude)", "funcdef": "def"}, {"fullname": "ES.openlocationcode.CodeArea", "modulename": "ES.openlocationcode", "qualname": "CodeArea", "type": "class", "doc": "<p>Coordinates of a decoded Open Location Code.\nThe coordinates include the latitude and longitude of the lower left and\nupper right corners and the center of the bounding box for the area the\ncode represents.\nAttributes:\n  latitude_lo: The latitude of the SW corner in degrees.\n  longitude_lo: The longitude of the SW corner in degrees.\n  latitude_hi: The latitude of the NE corner in degrees.\n  longitude_hi: The longitude of the NE corner in degrees.\n  latitude_center: The latitude of the center in degrees.\n  longitude_center: The longitude of the center in degrees.\n  code_length: The number of significant characters that were in the code.\n      This excludes the separator.</p>\n"}, {"fullname": "ES.openlocationcode.CodeArea.__init__", "modulename": "ES.openlocationcode", "qualname": "CodeArea.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, latitudeLo, longitudeLo, latitudeHi, longitudeHi, codeLength)", "funcdef": "def"}, {"fullname": "ES.openlocationcode.CodeArea.latlng", "modulename": "ES.openlocationcode", "qualname": "CodeArea.latlng", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "ES.timeslot", "modulename": "ES.timeslot", "type": "module", "doc": "<p>Created on Sun Jan  2 18:30:14 2022</p>\n\n<p>@author: Philippe@loco-labs.io</p>\n\n<p>The <code>ES.timeslot</code> module contains the <code>TimeSlot</code> and the <code>TimeInterval</code> classes.</p>\n\n<h1 id=\"what-is-the-timeslot-object\">What is the TimeSlot Object ?</h1>\n\n<p>The TimeSlot Object is a representation of time intervals data and properties. For example,\n i can represent the working day of 2022-march-15 by a TimeSlot which inclde the following intervals:</p>\n\n<ul>\n<li>from 9 a.m. to 12 p.m.</li>\n<li>from 2 p.m. to 4:30 p.m.</li>\n<li>from 5 p.m. to 7:30 p.m.\ni.e. a duration of 8 hours centered around 3 p.m. with bounds at 9 a.m. and 7:30 p.m.</li>\n</ul>\n\n<h1 id=\"main-principles\">Main principles</h1>\n\n<p>The main principles are as follows :</p>\n\n<p><img src=\"./timeslot_data_structure.png\" width=\"800\"></p>\n\n<h2 id=\"data-structure\">Data structure</h2>\n\n<p>A <code>TimeSlot</code> is a list of <code>TimeInterval</code>.</p>\n\n<p>A <code>TimeInterval</code> is defined by to <code>datetime</code> objects (start and end)</p>\n\n<p>Multiple properties are associated with the data :</p>\n\n<ul>\n<li>duration : sum of the lenght of each TimeInterval</li>\n<li>centro\u00efd : instant assicited to the middle of the duration</li>\n<li>bounds : minimum, maximum and middle</li>\n<li>type : instant, interval or slot</li>\n</ul>\n\n<h2 id=\"relationships-and-assembly\">Relationships and assembly</h2>\n\n<p>Two <code>TimeSlot</code> can be compared with five statuses (equals, contains, whitin, disjoint, intersects).</p>\n\n<p>Multiple operations between two objects can be performed :</p>\n\n<ul>\n<li>union between two <code>TimeSlot</code></li>\n<li>intersection between two <code>TimeSlot</code></li>\n<li>complementing a <code>TimeSlot</code> in an interval</li>\n</ul>\n"}, {"fullname": "ES.timeslot.TimeSlotEncoder", "modulename": "ES.timeslot", "qualname": "TimeSlotEncoder", "type": "class", "doc": "<p>add a new json encoder for TimeSlot</p>\n", "bases": "json.encoder.JSONEncoder"}, {"fullname": "ES.timeslot.TimeSlotEncoder.default", "modulename": "ES.timeslot", "qualname": "TimeSlotEncoder.default", "type": "function", "doc": "<p>Implement this method in a subclass such that it returns\na serializable object for <code>o</code>, or calls the base implementation\n(to raise a <code>TypeError</code>).</p>\n\n<p>For example, to support arbitrary iterators, you could\nimplement default like this::</p>\n\n<pre><code>def default(self, o):\n    try:\n        iterable = iter(o)\n    except TypeError:\n        pass\n    else:\n        return list(iterable)\n    # Let the base class default method raise the TypeError\n    return JSONEncoder.default(self, o)\n</code></pre>\n", "signature": "(self, o)", "funcdef": "def"}, {"fullname": "ES.timeslot.TimeSlot", "modulename": "ES.timeslot", "qualname": "TimeSlot", "type": "class", "doc": "<p><em>Attributes (for @property see methods)</em> :</p>\n\n<ul>\n<li><strong>slot</strong> : list of <code>TimeInterval</code></li>\n</ul>\n\n<p>The methods defined in this class are : </p>\n\n<p><em>dynamic value property (getters)</em></p>\n\n<ul>\n<li><code>TimeSlot.Bounds</code></li>\n<li><code>TimeSlot.bounds</code></li>\n<li><code>TimeSlot.Centroid</code></li>\n<li><code>TimeSlot.duration</code></li>\n<li><code>TimeSlot.instant</code></li>\n<li><code>TimeSlot.middle</code></li>\n<li><code>TimeSlot.interval</code></li>\n<li><code>TimeSlot.stype</code></li>\n</ul>\n\n<p><em>instance methods</em></p>\n\n<ul>\n<li><code>TimeSlot.json</code></li>\n<li><code>TimeSlot.link</code></li>\n<li><code>TimeSlot.timetuple</code></li>\n<li><code>TimeSlot.union</code></li>\n</ul>\n"}, {"fullname": "ES.timeslot.TimeSlot.__init__", "modulename": "ES.timeslot", "qualname": "TimeSlot.__init__", "type": "function", "doc": "<p>TimeSlot constructor.</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>val</strong> : date, interval, list of interval (default None) - with several formats \n(tuple, list, string, datetime, TimeSlot, TimeInterval, numpy datetime64, pandas timestamp)</li>\n</ul>\n\n<p><em>Returns</em> : None</p>\n", "signature": "(self, val=None)", "funcdef": "def"}, {"fullname": "ES.timeslot.TimeSlot.Bounds", "modulename": "ES.timeslot", "qualname": "TimeSlot.Bounds", "type": "variable", "doc": "<p>return an interval TimeSlot with the bounds of the TimeSlot object</p>\n"}, {"fullname": "ES.timeslot.TimeSlot.bounds", "modulename": "ES.timeslot", "qualname": "TimeSlot.bounds", "type": "variable", "doc": "<p>return a tuple with the start and end dates with isoformat string</p>\n"}, {"fullname": "ES.timeslot.TimeSlot.cast", "modulename": "ES.timeslot", "qualname": "TimeSlot.cast", "type": "function", "doc": "<p>tranform a value (unique or list) in a list of <code>TimeSlot</code></p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>value</strong> : value to transform</li>\n</ul>\n\n<p><em>Returns</em></p>\n\n<ul>\n<li><strong>list</strong> : list of <code>TimeSlot</code></li>\n</ul>\n", "signature": "(cls, value)", "funcdef": "def"}, {"fullname": "ES.timeslot.TimeSlot.Centroid", "modulename": "ES.timeslot", "qualname": "TimeSlot.Centroid", "type": "variable", "doc": "<p>return a TimeSlot with the date corresponding to the middle of the duration</p>\n"}, {"fullname": "ES.timeslot.TimeSlot.duration", "modulename": "ES.timeslot", "qualname": "TimeSlot.duration", "type": "variable", "doc": "<p>cumulative duration of each interval (timedelta format)</p>\n"}, {"fullname": "ES.timeslot.TimeSlot.form", "modulename": "ES.timeslot", "qualname": "TimeSlot.form", "type": "function", "doc": "<p></p>\n", "signature": "(dtime)", "funcdef": "def"}, {"fullname": "ES.timeslot.TimeSlot.instant", "modulename": "ES.timeslot", "qualname": "TimeSlot.instant", "type": "variable", "doc": "<p>return the date corresponding to the middle of the duration (datetime format)</p>\n"}, {"fullname": "ES.timeslot.TimeSlot.middle", "modulename": "ES.timeslot", "qualname": "TimeSlot.middle", "type": "variable", "doc": "<p>return the date corresponding to the middle of the bounds (datetime format)</p>\n"}, {"fullname": "ES.timeslot.TimeSlot.interval", "modulename": "ES.timeslot", "qualname": "TimeSlot.interval", "type": "variable", "doc": "<p>return a list with the start and end dates (datetime format)</p>\n"}, {"fullname": "ES.timeslot.TimeSlot.stype", "modulename": "ES.timeslot", "qualname": "TimeSlot.stype", "type": "variable", "doc": "<p>return a string with the type of TimeSlot (instant, interval, slot)</p>\n"}, {"fullname": "ES.timeslot.TimeSlot.json", "modulename": "ES.timeslot", "qualname": "TimeSlot.json", "type": "function", "doc": "<p>Return json/bson structure with the list of TimeInterval.</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>encoded</strong> : defaut False - if False return dict, else return json string/bson bytes</li>\n<li><strong>encode_format</strong> : defaut 'json' - return json, bson or cbor format</li>\n</ul>\n\n<p><em>Returns</em> : string or dict</p>\n", "signature": "(self, **kwargs)", "funcdef": "def"}, {"fullname": "ES.timeslot.TimeSlot.link", "modulename": "ES.timeslot", "qualname": "TimeSlot.link", "type": "function", "doc": "<p>Return the status (string) of the link between two TimeSlot (self and other).</p>\n\n<ul>\n<li>equals     : if self and other are the same</li>\n<li>disjoint   : if self's intervals and other's intervals are all disjoint</li>\n<li>within     : if all self's intervals are included in other's intervals</li>\n<li>contains   : if all other's intervals are included in self's intervals</li>\n<li>intersects : in the others cases</li>\n</ul>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>other</strong> : TimeSlot to be compared</li>\n</ul>\n\n<p><em>Returns</em> </p>\n\n<ul>\n<li><strong>tuple</strong> : (string(status), boolean(full or not))</li>\n</ul>\n", "signature": "(self, other)", "funcdef": "def"}, {"fullname": "ES.timeslot.TimeSlot.timetuple", "modulename": "ES.timeslot", "qualname": "TimeSlot.timetuple", "type": "function", "doc": "<p>Return json structure with the list of TimeInterval (timetuple filter).</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>index</strong> : integer, defaut 0 - timetuple format to apply :\n<ul>\n<li>0 : year</li>\n<li>1 : month</li>\n<li>2 : day</li>\n<li>3 : hour</li>\n<li>4 : minute</li>\n<li>5 : seconds</li>\n<li>6 : weekday</li>\n<li>7 : yearday</li>\n<li>8 : isdst (1 when daylight savings time is in effect, 0 when is not)</li>\n</ul></li>\n<li><strong>encoded</strong> : defaut False - if True return string, else return dict</li>\n</ul>\n\n<p><em>Returns</em> : string or dict</p>\n", "signature": "(self, index=0, encoded=False)", "funcdef": "def"}, {"fullname": "ES.timeslot.TimeSlot.union", "modulename": "ES.timeslot", "qualname": "TimeSlot.union", "type": "function", "doc": "<p>Add other's values to self's values in a new TimeSlot (same as __add__)</p>\n", "signature": "(self, other)", "funcdef": "def"}, {"fullname": "ES.timeslot.TimeInterval", "modulename": "ES.timeslot", "qualname": "TimeInterval", "type": "class", "doc": "<p><em>Attributes (for @property see methods)</em> :</p>\n\n<ul>\n<li><strong>start</strong> : datetime Object - start of <code>TimeInterval</code></li>\n<li><strong>end</strong>   : datetime Object - end of <code>TimeInterval</code></li>\n</ul>\n\n<p>The methods defined in this class are : </p>\n\n<p><em>dynamic value property (getters)</em></p>\n\n<ul>\n<li><code>TimeInterval.Bounds</code></li>\n<li><code>TimeInterval.bounds</code></li>\n<li><code>TimeInterval.Centroid</code></li>\n<li><code>TimeInterval.duration</code></li>\n<li><code>TimeInterval.instant</code></li>\n<li><code>TimeInterval.stype</code></li>\n</ul>\n\n<p><em>instance methods</em></p>\n\n<ul>\n<li><code>TimeInterval.json</code></li>\n<li><code>TimeInterval.link</code></li>\n<li><code>TimeInterval.timetuple</code></li>\n<li><code>TimeInterval.union</code></li>\n</ul>\n"}, {"fullname": "ES.timeslot.TimeInterval.__init__", "modulename": "ES.timeslot", "qualname": "TimeInterval.__init__", "type": "function", "doc": "<p>TimeInterval constructor.</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>val</strong> : date, interval (default ES.nullDate) - with several formats \n(list, string, datetime, TimeInterval, numpy datetime64, pandas timestamp)</li>\n</ul>\n\n<p><em>Returns</em> : None</p>\n", "signature": "(\n    self,\n    val=datetime.datetime(1, 1, 1, 0, 0, tzinfo=datetime.timezone.utc)\n)", "funcdef": "def"}, {"fullname": "ES.timeslot.TimeInterval.bounds", "modulename": "ES.timeslot", "qualname": "TimeInterval.bounds", "type": "variable", "doc": "<p>return a tuple with the start and end dates with isoformat string</p>\n"}, {"fullname": "ES.timeslot.TimeInterval.Centroid", "modulename": "ES.timeslot", "qualname": "TimeInterval.Centroid", "type": "variable", "doc": "<p>return a TimeInterval with the date corresponding to the middle of the interval</p>\n"}, {"fullname": "ES.timeslot.TimeInterval.duration", "modulename": "ES.timeslot", "qualname": "TimeInterval.duration", "type": "variable", "doc": "<p>duration between 'end' and 'start' date (timedelta format)</p>\n"}, {"fullname": "ES.timeslot.TimeInterval.instant", "modulename": "ES.timeslot", "qualname": "TimeInterval.instant", "type": "variable", "doc": "<p>return the date corresponding to the middle of the duration (datetime format)</p>\n"}, {"fullname": "ES.timeslot.TimeInterval.stype", "modulename": "ES.timeslot", "qualname": "TimeInterval.stype", "type": "variable", "doc": "<p>return a string with the type of TimeInterval (instant, interval)</p>\n"}, {"fullname": "ES.timeslot.TimeInterval.json", "modulename": "ES.timeslot", "qualname": "TimeInterval.json", "type": "function", "doc": "<p>Return json/bson structure (date if 'instant' or [start, end] if 'interval') \nwith datetime or datetime.isoformat for dates.</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>encoded</strong> : defaut False - if True return dict, else return json string/bson bytes</li>\n<li><strong>encode_format</strong>   : defaut 'json' - return json, bson or cbor format</li>\n</ul>\n\n<p><em>Returns</em> : string or dict</p>\n", "signature": "(self, encoded=False, encode_format='json')", "funcdef": "def"}, {"fullname": "ES.timeslot.TimeInterval.link", "modulename": "ES.timeslot", "qualname": "TimeInterval.link", "type": "function", "doc": "<p>Return the status (string) of the link between two TimeIntervals (self and other).</p>\n\n<ul>\n<li>equals     : if self and other are the same</li>\n<li>disjoint   : if self's interval and other's interval are disjoint</li>\n<li>within     : if other's interval is included in self's interval</li>\n<li>contains   : if self's interval is included in other's interval</li>\n<li>intersects : in the others cases</li>\n</ul>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>other</strong> : TimeInterval to be compared</li>\n</ul>\n\n<p><em>Returns</em> : string</p>\n", "signature": "(self, other)", "funcdef": "def"}, {"fullname": "ES.timeslot.TimeInterval.timetuple", "modulename": "ES.timeslot", "qualname": "TimeInterval.timetuple", "type": "function", "doc": "<p>Return json structure (timetuple filter).</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>index</strong> : integer, defaut 0 - timetuple format to apply :\n<ul>\n<li>0 : year</li>\n<li>1 : month</li>\n<li>2 : day</li>\n<li>3 : hour</li>\n<li>4 : minute</li>\n<li>5 : seconds</li>\n<li>6 : weekday</li>\n<li>7 : yearday</li>\n<li>8 : isdst (1 when daylight savings time is in effect, 0 when is not)</li>\n</ul></li>\n<li><strong>encoded</strong> : defaut False - if True return string, else return dict</li>\n</ul>\n\n<p><em>Returns</em> : string or dict</p>\n", "signature": "(self, index=0, encoded=False)", "funcdef": "def"}, {"fullname": "ES.timeslot.TimeInterval.union", "modulename": "ES.timeslot", "qualname": "TimeInterval.union", "type": "function", "doc": "<p>Add other's values to self's values in a new TimeInterval \nif self and other are not disjoint</p>\n", "signature": "(self, other)", "funcdef": "def"}, {"fullname": "ES.timeslot.TimeSlotError", "modulename": "ES.timeslot", "qualname": "TimeSlotError", "type": "class", "doc": "<p>Common base class for all non-exit exceptions.</p>\n", "bases": "builtins.Exception"}, {"fullname": "ES.util", "modulename": "ES.util", "type": "module", "doc": "<p>Created on Fri Jul 29 12:48:16 2022</p>\n\n<p>@author: a179227</p>\n"}, {"fullname": "ES.util.identity", "modulename": "ES.util", "qualname": "identity", "type": "function", "doc": "<p>return the same value as args or kwargs</p>\n", "signature": "(*args, **kwargs)", "funcdef": "def"}, {"fullname": "ES.util.CborDecoder", "modulename": "ES.util", "qualname": "CborDecoder", "type": "class", "doc": "<p>Cbor extension for integer keys (codification keys)</p>\n", "bases": "json.decoder.JSONDecoder"}, {"fullname": "ES.util.CborDecoder.__init__", "modulename": "ES.util", "qualname": "CborDecoder.__init__", "type": "function", "doc": "<p><code>object_hook</code>, if specified, will be called with the result\nof every JSON object decoded and its return value will be used in\nplace of the given <code>dict</code>.  This can be used to provide custom\ndeserializations (e.g. to support JSON-RPC class hinting).</p>\n\n<p><code>object_pairs_hook</code>, if specified will be called with the result of\nevery JSON object decoded with an ordered list of pairs.  The return\nvalue of <code>object_pairs_hook</code> will be used instead of the <code>dict</code>.\nThis feature can be used to implement custom decoders.\nIf <code>object_hook</code> is also defined, the <code>object_pairs_hook</code> takes\npriority.</p>\n\n<p><code>parse_float</code>, if specified, will be called with the string\nof every JSON float to be decoded. By default this is equivalent to\nfloat(num_str). This can be used to use another datatype or parser\nfor JSON floats (e.g. decimal.Decimal).</p>\n\n<p><code>parse_int</code>, if specified, will be called with the string\nof every JSON int to be decoded. By default this is equivalent to\nint(num_str). This can be used to use another datatype or parser\nfor JSON integers (e.g. float).</p>\n\n<p><code>parse_constant</code>, if specified, will be called with one of the\nfollowing strings: -Infinity, Infinity, NaN.\nThis can be used to raise an exception if invalid JSON numbers\nare encountered.</p>\n\n<p>If <code>strict</code> is false (true is the default), then control\ncharacters will be allowed inside strings.  Control characters in\nthis context are those with character codes in the 0-31 range,\nincluding <code>'\\t'</code> (tab), <code>'\\n'</code>, <code>'\\r'</code> and <code>'\\0'</code>.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "ES.util.CborDecoder.codecbor", "modulename": "ES.util", "qualname": "CborDecoder.codecbor", "type": "function", "doc": "<p></p>\n", "signature": "(self, dic)", "funcdef": "def"}, {"fullname": "ES.util.IindexEncoder", "modulename": "ES.util", "qualname": "IindexEncoder", "type": "class", "doc": "<p>new json encoder for Iindex and Ilist</p>\n", "bases": "json.encoder.JSONEncoder"}, {"fullname": "ES.util.IindexEncoder.default", "modulename": "ES.util", "qualname": "IindexEncoder.default", "type": "function", "doc": "<p>Implement this method in a subclass such that it returns\na serializable object for <code>o</code>, or calls the base implementation\n(to raise a <code>TypeError</code>).</p>\n\n<p>For example, to support arbitrary iterators, you could\nimplement default like this::</p>\n\n<pre><code>def default(self, o):\n    try:\n        iterable = iter(o)\n    except TypeError:\n        pass\n    else:\n        return list(iterable)\n    # Let the base class default method raise the TypeError\n    return JSONEncoder.default(self, o)\n</code></pre>\n", "signature": "(self, o)", "funcdef": "def"}, {"fullname": "ES.util.util", "modulename": "ES.util", "qualname": "util", "type": "class", "doc": "<p>common functions for Iindex and Ilist class</p>\n"}, {"fullname": "ES.util.util.__init__", "modulename": "ES.util", "qualname": "util.__init__", "type": "function", "doc": "<p></p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "ES.util.util.c1", "modulename": "ES.util", "qualname": "util.c1", "type": "variable", "doc": "<p></p>\n", "default_value": " = re.compile('\\\\d+\\\\.?\\\\d*[,\\\\-_ ;:]')"}, {"fullname": "ES.util.util.c2", "modulename": "ES.util", "qualname": "util.c2", "type": "variable", "doc": "<p></p>\n", "default_value": " = re.compile('[,\\\\-_ ;:]\\\\d+\\\\.?\\\\d*')"}, {"fullname": "ES.util.util.cast", "modulename": "ES.util", "qualname": "util.cast", "type": "function", "doc": "<p>convert val in the type defined by the string dtype</p>\n", "signature": "(val, dtype=None, string=True)", "funcdef": "def"}, {"fullname": "ES.util.util.castobj", "modulename": "ES.util", "qualname": "util.castobj", "type": "function", "doc": "<p>convert a list of values in the ESValue defined by the string classvalue</p>\n", "signature": "(lis, classvalue=None)", "funcdef": "def"}, {"fullname": "ES.util.util.castval", "modulename": "ES.util", "qualname": "util.castval", "type": "function", "doc": "<p>convert a value in the ESValue defined by the string classvalue</p>\n", "signature": "(val, classvalue=None)", "funcdef": "def"}, {"fullname": "ES.util.util.couplinginfos", "modulename": "ES.util", "qualname": "util.couplinginfos", "type": "function", "doc": "<p>return a dict with the coupling info between two list</p>\n", "signature": "(l1, l2)", "funcdef": "def"}, {"fullname": "ES.util.util.decodeobj", "modulename": "ES.util", "qualname": "util.decodeobj", "type": "function", "doc": "<p>Generate an Iindex data from a bytes, json or dict value</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>bs</strong> : bytes, string or dict data to convert</li>\n</ul>\n\n<p><em>Returns</em> : tuple - name, typevaluedec, codec, parent, keys</p>\n", "signature": "(bs=None, classname=None)", "funcdef": "def"}, {"fullname": "ES.util.util.decodecodec", "modulename": "ES.util", "qualname": "util.decodecodec", "type": "function", "doc": "<p>Generate a codec list from a json value</p>\n", "signature": "(codecobj, classname='NamedValue')", "funcdef": "def"}, {"fullname": "ES.util.util.decodecontext", "modulename": "ES.util", "qualname": "util.decodecontext", "type": "function", "doc": "<p>Generate a tuple (name, dtype) from a json value</p>\n", "signature": "(context)", "funcdef": "def"}, {"fullname": "ES.util.util.decodekeys", "modulename": "ES.util", "qualname": "util.decodekeys", "type": "function", "doc": "<p>Generate a tuple (parent, keys) from a json value</p>\n", "signature": "(keys)", "funcdef": "def"}, {"fullname": "ES.util.util.encodeobj", "modulename": "ES.util", "qualname": "util.encodeobj", "type": "function", "doc": "<p>Return a formatted object with values, keys and codec.</p>\n\n<ul>\n<li>Format can be json, bson or cbor</li>\n<li>object can be string, bytes or dict</li>\n</ul>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>codeclist</strong> : list of codec ESValue to encode</li>\n<li><strong>keyslist</strong> : list (default = None) - int keys to encode, None if no keys </li>\n<li><strong>name</strong> : string (default = None) - name to encode, None if no name </li>\n<li><strong>fullcodec</strong> : boolean (default False) - if True, use a full codec</li>\n<li><strong>typevalue</strong> : string (default None) - type to convert values</li>\n<li><strong>parent</strong> : int (default ES.nullparent) - Ilist index linked to</li>\n<li><strong>listunic</strong> : boolean (default False) - if False, when len(result)=1 return value not list</li>\n<li><strong>simpleval</strong> : boolean (default False) - if True, only codec is included</li>\n</ul>\n\n<p><em>Parameters (kwargs)</em></p>\n\n<ul>\n<li><strong>encoded</strong> : boolean (default False) - choice for return format (string/bytes if True, dict else)</li>\n<li><strong>encode_format</strong>  : string (default 'json')- choice for return format (json, cbor)</li>\n<li><strong>codif</strong> : dict (default ES.codeb). Numerical value for string in CBOR encoder</li>\n<li><strong>untyped</strong> : boolean (default False) - include dtype in the json if True</li>\n</ul>\n\n<p><em>Returns</em> : string, bytes or dict</p>\n", "signature": "(\n    codeclist,\n    keyslist=None,\n    name=None,\n    fullcodec=False,\n    simpleval=False,\n    typevalue=None,\n    parent=-2,\n    listunic=False,\n    **kwargs\n)", "funcdef": "def"}, {"fullname": "ES.util.util.filter", "modulename": "ES.util", "qualname": "util.filter", "type": "function", "doc": "<p>apply \"func\" to each value of \"lis\" and tests if equals \"res\".\nReturn the list of index with True result.</p>\n", "signature": "(func, lis, res, *args, **kwargs)", "funcdef": "def"}, {"fullname": "ES.util.util.funclist", "modulename": "ES.util", "qualname": "util.funclist", "type": "function", "doc": "<p>return the function func applied to the object value with parameters args and kwargs</p>\n", "signature": "(value, func, *args, **kwargs)", "funcdef": "def"}, {"fullname": "ES.util.util.hash", "modulename": "ES.util", "qualname": "util.hash", "type": "function", "doc": "<p>return sum of hash values in the list</p>\n", "signature": "(listval)", "funcdef": "def"}, {"fullname": "ES.util.util.idxfull", "modulename": "ES.util", "qualname": "util.idxfull", "type": "function", "doc": "<p>return additional keys for each index in the setidx list to have crossed setidx</p>\n", "signature": "(setidx)", "funcdef": "def"}, {"fullname": "ES.util.util.idxlink", "modulename": "ES.util", "qualname": "util.idxlink", "type": "function", "doc": "<p>return a dict for each different tuple (ref value, l2 value)</p>\n", "signature": "(ref, l2)", "funcdef": "def"}, {"fullname": "ES.util.util.json", "modulename": "ES.util", "qualname": "util.json", "type": "function", "doc": "<p></p>\n", "signature": "(val, **option)", "funcdef": "def"}, {"fullname": "ES.util.util.canonorder", "modulename": "ES.util", "qualname": "util.canonorder", "type": "function", "doc": "<p>return a list of crossed keys from a list of number of values</p>\n", "signature": "(lenidx)", "funcdef": "def"}, {"fullname": "ES.util.util.list", "modulename": "ES.util", "qualname": "util.list", "type": "function", "doc": "<p>transform a list of tuples in a list of lists</p>\n", "signature": "(tuplelists)", "funcdef": "def"}, {"fullname": "ES.util.util.mul", "modulename": "ES.util", "qualname": "util.mul", "type": "function", "doc": "<p>return the product of values in a list or tuple</p>\n", "signature": "(values)", "funcdef": "def"}, {"fullname": "ES.util.util.reindex", "modulename": "ES.util", "qualname": "util.reindex", "type": "function", "doc": "<p>new keys with new order of codec</p>\n", "signature": "(oldkeys, oldcodec, newcodec)", "funcdef": "def"}, {"fullname": "ES.util.util.reorder", "modulename": "ES.util", "qualname": "util.reorder", "type": "function", "doc": "<p>return a new values list following the order define by sort</p>\n", "signature": "(values, sort=None)", "funcdef": "def"}, {"fullname": "ES.util.util.resetidx", "modulename": "ES.util", "qualname": "util.resetidx", "type": "function", "doc": "<p>return codec and keys from a list of values</p>\n", "signature": "(values)", "funcdef": "def"}, {"fullname": "ES.util.util.pparent", "modulename": "ES.util", "qualname": "util.pparent", "type": "function", "doc": "<p>return field 'pparent'</p>\n", "signature": "(row, infos)", "funcdef": "def"}, {"fullname": "ES.util.util.str", "modulename": "ES.util", "qualname": "util.str", "type": "function", "doc": "<p>return a list with values in the str format</p>\n", "signature": "(listvalues)", "funcdef": "def"}, {"fullname": "ES.util.util.tokeys", "modulename": "ES.util", "qualname": "util.tokeys", "type": "function", "doc": "<p>return a list of keys from a list of values</p>\n", "signature": "(values, codec=None)", "funcdef": "def"}, {"fullname": "ES.util.util.tovalues", "modulename": "ES.util", "qualname": "util.tovalues", "type": "function", "doc": "<p>return a list of values from a list of keys and a list of codec values</p>\n", "signature": "(keys, codec)", "funcdef": "def"}, {"fullname": "ES.util.util.tonumpy", "modulename": "ES.util", "qualname": "util.tonumpy", "type": "function", "doc": "<p>return a Numpy Array from a list of values converted by func</p>\n", "signature": "(valuelist, func=None, **kwargs)", "funcdef": "def"}, {"fullname": "ES.util.util.tocodec", "modulename": "ES.util", "qualname": "util.tocodec", "type": "function", "doc": "<p>extract a list of unique values</p>\n", "signature": "(values, keys=None)", "funcdef": "def"}, {"fullname": "ES.util.util.transpose", "modulename": "ES.util", "qualname": "util.transpose", "type": "function", "doc": "<p>exchange row/column in a list of list</p>\n", "signature": "(idxlist)", "funcdef": "def"}, {"fullname": "ES.util.util.tuple", "modulename": "ES.util", "qualname": "util.tuple", "type": "function", "doc": "<p>transform a list of list in a list of tuple</p>\n", "signature": "(idx)", "funcdef": "def"}, {"fullname": "ES.util.utilError", "modulename": "ES.util", "qualname": "utilError", "type": "class", "doc": "<p>util Exception</p>\n", "bases": "builtins.Exception"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();