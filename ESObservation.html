<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>ES.ESObservation API documentation</title>
<meta name="description" content="Created on Tue Aug
3 23:40:06 2021 …" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ES.ESObservation</code></h1>
</header>
<section id="section-intro">
<p>Created on Tue Aug
3 23:40:06 2021</p>
<p>@author: Philippe@loco-labs.io</p>
<p>The <code><a title="ES.ESObservation" href="#ES.ESObservation">ES.ESObservation</a></code> module contains the main class
of Environmental Sensing : <code><a title="ES.ESObservation.Observation" href="#ES.ESObservation.Observation">Observation</a></code> class.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
&#34;&#34;&#34;
Created on Tue Aug  3 23:40:06 2021

@author: Philippe@loco-labs.io



The `ES.ESObservation` module contains the main class
of Environmental Sensing : `ES.ESObservation.Observation` class.

&#34;&#34;&#34;
from ESObs import ESSetDatation, ESSetLocation, ESSetProperty, ESSetResult
from ESElement import ESObject, isESObs, isESAtt, isUserAtt
from ESconstante import ES, identity
from ESValue import LocationValue, DatationValue, PropertyValue, \
    ResultValue, gshape
from shapely.geometry import shape
import json, folium, struct
import numpy as np
import xarray as xr
#import geopandas as gp
import matplotlib.pyplot as plt

class Observation(ESObject):
    &#34;&#34;&#34;
    An `ES.ESObservation.Observation` is made up of objects from the `ES.ESObs` class
     which each describe a dimension of this object.
    &#34;&#34;&#34;
    def __init__(self, jso = {}, order = &#39;dlp&#39;):
        ESObject.__init__(self)
        self.option = ES.mOption.copy()
        self.mAtt[ES.obs_reference] = 0
        &#39;&#39;&#39; Attribut décrivant une `Observation` de référence utilisée pour compléter l&#39;Observation actuelle.&#39;&#39;&#39;
        self.score = -1
        &#39;&#39;&#39; Nature de l&#39;assemblage des différents composants. Par exemple 122 
        indique qu&#39;il s&#39;agit d&#39;une mesure unique sur un trajet&#39;&#39;&#39;
        self.complet = False
        &#39;&#39;&#39; True si le nombre de résultats est cohérent avec le nombre d&#39;objets de type Location, Datation et Property.&#39;&#39;&#39;
        self.mAtt[ES.obs_resultTime] = &#34;null&#34;
        self.classES = ES.obs_classES
        self.typeES = ES.obs_typeES
        self.mAtt[ES.type] = &#34;obsError&#34;
        self.mAtt[ES.obs_id] = &#34;null&#34;
        if type(jso) == str :
            try:
                js=json.loads(jso)
            except:
                return
        elif type(jso) == dict :
            js = jso.copy()
        else : return
        if js == {}: return
        if ES.type not in list(js) or js[ES.type] != ES.obs_classES: return
        if ES.obs_id in list(js): self.mAtt[ES.obs_id] = js[ES.obs_id]
        if ES.obs_attributes in list(js): 
            if type(js[ES.obs_attributes]) == dict: js = js[ES.obs_attributes]
            else: return
        self.addAttributes(js)
        if isESObs(ES.dat_classES, js): ESSetDatation(self, js)
        if isESObs(ES.loc_classES, js): ESSetLocation(self, js)
        if isESObs(ES.prp_classES, js): ESSetProperty(self, js)
        if isESObs(ES.res_classES, js): ESSetResult  (self, js)
        self.majType(order)

    def addAttributes(self, js):
        &#39;&#39;&#39;Ajout d&#39;attributs à une Observation&#39;&#39;&#39;
        if type(js) != dict: return
        for k, v in js.items():
            if isESAtt(ES.obs_classES, k) or isUserAtt(k): self.mAtt[k] = v
            if k == ES.parameter: 
                try:  self.parameter = json.dumps(v)
                except:  self.parameter = &#34;null&#34;

    @property
    def bounds(self):
        &#39;&#39;&#39;boîte englobante de l&#39;Observation&#39;&#39;&#39;
        if self.setLocation : return shape(self).bounds
        else : return None

    @property
    def __geo_interface__(self):
        &#39;&#39;&#39;if self.option[&#34;json_loc_point&#34;] : indice = 0
        else : indice = 1&#39;&#39;&#39;
        if self.setLocation : 
            return gshape(self.setLocation.jsonSet(self.option)).__geo_interface__
            #return gshape(self.setLocation.geoInterface(self.option)).__geo_interface__
            &#39;&#39;&#39;return gshape(json.dumps(json.loads(&#39;{&#39; \
                        #+ self.setLocation.json(False, False, False, False)\
                        + self.setLocation.geoInterface(self.option)\
                        #+ &#39;}&#39;)[&#34;coordinates&#34;])).__geo_interface__
                        + &#39;}&#39;)[ES.loc_valName[indice]])).__geo_interface__&#39;&#39;&#39;
        else : return &#34;&#34;

    @property
    def jsonFeature(self):
        if self.setLocation : 
            geo = self.__geo_interface__
            if geo[&#39;type&#39;] == &#34;MultiPolygon&#34;: typ = &#34;Polygon&#34;
            else : typ = &#34;Point&#34;
            lis = list(dict(((&#34;type&#34;, typ), (&#34;coordinates&#34;, geo[&#39;coordinates&#39;][i]))) for i in range(len(geo[&#39;coordinates&#39;])))
            fea = list(dict(((&#34;type&#34;,&#34;Feature&#34;), (&#34;id&#34;, i), (&#34;geometry&#34;, lis[i]))) for i in range(len(geo[&#39;coordinates&#39;])))
            return json.dumps(dict(((&#34;type&#34;,&#34;FeatureCollection&#34;), (&#34;features&#34;,fea))))            
        else: return &#39;&#39;  
            
    @property
    def setLocation(self):  return self.element(ES.loc_classES)
    &#39;&#39;&#39; Objet `setLocation`s&#39;il existe, None sinon.&#39;&#39;&#39;
    @property
    def setDatation(self):  return self.element(ES.dat_classES)
    @property
    def setProperty(self):  return self.element(ES.prp_classES)
    @property
    def setResult(self):  return self.element(ES.res_classES)

    def __copy__(self):
        opt = self.option
        self.option[&#34;json_obs_val&#34;] = True
        cop = Observation(self.json())
        self.option = opt
        cop.option = opt
        return cop

    def __iadd__(self, other):
        other_opt = other.option
        self_opt = self.option
        ndat = nloc = nres = nprp = 0
        idat = 0; iloc = 1; iprp = 2
        other.option[&#34;maj_index&#34;] = True
        other.majType()
        self.option[&#34;maj_index&#34;] = True
        self.majType()
        if other.setResult != None and other.setResult.getMaxIndex() &gt; -1:
            for resVal in other.setResult.valueList:
                ndat = self.addValue(other.setDatation.valueList[resVal.ind[idat]])
                nloc = self.addValue(other.setLocation.valueList[resVal.ind[iloc]])
                nprp = self.addValue(other.setProperty.valueList[resVal.ind[iprp]])
                resv = ResultValue(resVal.value)
                resv.ind = [ndat, nloc, nprp]
                self.addResultValue(resv)
            self.majType()
        other.option = other_opt
        self.option = self_opt
        return self
    
    def __add__(self, other):
        obres = self.__copy__()
        obres.__iadd__(other)
        return obres
    
    def extend(self, obs):
        for p in obs.pComposant :
            if self.element(p.classES) == None : self.addComposant(p)
        self.majType()    
        
    def addResultValue(self, esValue):
        return self.element(ES.res_valueType).addValue(ResultValue, esValue)
    
    def addValue(self, esValue):
        if type(esValue)== PropertyValue:
            if self.element(ES.prp_valueType) == None: esSet = ESSetProperty(self)
            return self.element(ES.prp_valueType).addValue(PropertyValue, esValue)
        elif type(esValue)== LocationValue:
            if self.element(ES.loc_valueType) == None: esSet = ESSetLocation(self)
            return self.element(ES.loc_valueType).addValue(LocationValue, esValue)
        elif type(esValue)== DatationValue:
            if self.element(ES.dat_valueType) == None: esSet = ESSetDatation(self)
            return self.element(ES.dat_valueType).addValue(DatationValue, esValue)
        else: return 0

    def addListResultValue(self, listEsValue):
        if type(listEsValue) != list : return
        if self.element(ES.res_valueType) == None: resSet = ESSetResult(self)
        else: resSet = self.setResult
        for val in listEsValue : resSet.addValue(ResultValue, ResultValue(val))
            #self.addResultValue(ResultValue(val) )

    def majList(self, ValueClass, listVal, info = &#39;name&#39;):
        if ValueClass == DatationValue and self.setDatation != None : 
            if info == &#39;name&#39;: self.setDatation.majListName(listVal)
            else : self.setDatation.majListValue(ValueClass, listVal, info == &#39;base&#39;)
        elif ValueClass == LocationValue and self.setLocation != None : 
            if info == &#39;name&#39;: self.setLocation.majListName(listVal)
            else : self.setLocation.majListValue(ValueClass, listVal, info == &#39;base&#39;)
        elif ValueClass == PropertyValue and self.setProperty != None : 
            if info == &#39;name&#39;: self.setProperty.majListName(listVal)

    def addListValue(self, ValueClass, listEsValue):
        for val in listEsValue : self.addValue(ValueClass(val) )
        
    def addValueObservation(self, val, idat, iloc, iprp):
        if self.element(ES.res_valueType) == None: resSet = ESSetResult(self)
        return self.addResultValue(ResultValue(val, [idat, iloc, iprp]))

    def addListValueObservation(self, val, idat, iloc, iprp):
        for i in range(len(val)) :
            self.addResultValue(ResultValue(val[i], [idat[i], iloc[i], iprp[i]]))

    def addValueSensor(self, val, tim, coor, nprp):
        return self.addValueObservation(val, self.addValue(tim), self.addValue(coor), nprp)

    def json(self): 
        &#39;&#39;&#39; Export de l&#39;Observation sou s la forme dune chaîne de caractères au format JSON&#39;&#39;&#39;
        if self.option[&#34;json_elt_type&#34;]: option_type = 1
        else: option_type = 0
        js =&#34;&#34;
        &#39;&#39;&#39;variable interne retournée&#39;&#39;&#39;
        if self.option[&#34;json_obs_val&#34;]: js = &#34;{&#34;
        js += &#39;&#34;&#39; + ES.type +&#39;&#34;:&#34;&#39; + ES.obs_classES +&#39;&#34;,&#39;
        if self.mAtt[ES.obs_id] != &#34;null&#34;: js += &#39;&#34;&#39; + ES.obs_id + &#39;&#34;:&#34;&#39; + self.mAtt[ES.obs_id] + &#39;&#34;,&#39;
        if self.option[&#34;json_obs_attrib&#34;]: js += &#39;&#34;&#39; + ES.obs_attributes + &#39;&#34;:{&#39;
        js += self.jsonAtt(option_type)
        for cp in self.pComposant:
            js += cp.json(self.option)
            if js[-1] != &#39;,&#39;: js += &#34;,&#34;
        if self.option[&#34;json_param&#34;] and self.parameter != &#34;null&#34;: 
            js += &#39;&#34;&#39; + ES.parameter +&#39;&#34;:&#39; + self.parameter + &#39;,&#39;
        jsInfo = self.jsonInfo(self.option[&#34;json_info_type&#34;], self.option[&#34;json_info_nval&#34;],
                            self.option[&#34;json_info_box&#34;], self.option[&#34;json_info_autre&#34;])
        if jsInfo != &#34;&#34; : js +=  jsInfo + &#39;,&#39;
        if js[-1] == &#39;,&#39;: js = js[:-1]
        if self.option[&#34;json_obs_attrib&#34;]: js += &#34;}&#34;
        if self.option[&#34;json_obs_val&#34;]:    js += &#34;}&#34;
        return js
    
    def to_bytes(self):
        byt = bytes()
        code_el = ES.codeb[self.classES] 
        byt += struct.pack(&#39;&lt;B&#39;, (code_el &lt;&lt; 5) | self.mAtt[ES.obs_reference])
        if self.setProperty != None: 
            byt += self.setProperty.to_bytes(self.option[&#34;json_prp_name&#34;])
        if self.setLocation != None: 
            byt += self.setLocation.to_bytes(self.option[&#34;json_loc_name&#34;])
        if self.setDatation != None: 
            byt += self.setDatation.to_bytes(self.option[&#34;json_dat_name&#34;])
        if self.setResult != None: 
            propList = [self.setProperty.valueList[i].pType 
                        for i in range(self.setProperty.nValue)]
            byt += self.setResult.to_bytes(False, self.option[&#34;json_res_index&#34;], 
                                           self.option[&#34;bytes_res_format&#34;], propList)
        return byt
        
    def from_bytes(self, byt):
        code_ob = (byt[0] &amp; 0b11100000) &gt;&gt; 5
        self.mAtt[ES.obs_reference] = byt[0] &amp; 0b00011111
        if code_ob != ES.codeb[self.classES]: return
        idx = 1
        while idx &lt; byt.__len__() :
            code_el = (byt[idx] &amp; 0b11100000) &gt;&gt; 5
            #forma =  byt[idx] &amp; 0b00001111
            if   code_el == 1: es = ESSetLocation(self)
            elif code_el == 2: es = ESSetDatation(self)
            elif code_el == 3: es = ESSetProperty(self)
            elif code_el &lt; 6:
                es = ESSetResult(self)
                if code_el == 5: 
                    propList = [self.setProperty.valueList[i].pType 
                            for i in range(self.setProperty.nValue)]
                else :
                    n = es.from_bytes(byt[idx:], [])
                    es.majIndex(es.nValue, self.setProperty.nValue, 
                            self.setDatation.nValue, self.setLocation.nValue)
                    propList = [self.setProperty.valueList[es.valueList[i].ind[2]].pType
                            for i in range(es.nValue)]
                    es.__init__()
            else: return
            if code_el &lt; 4 : 
                idx += es.from_bytes(byt[idx:])
            else :
                idx += es.from_bytes(byt[idx:], propList)
    
    def jsonInfoTypes(self, dcinf):
        dcinf[ES.json_type_obs] = self.mAtt[ES.type]
        if self.setLocation != None :
            if self.setLocation.nValue &gt; 1 : 
                dcinf[ES.json_type_loc] = ES.multi + self.setLocation.mAtt[ES.type]
            else :
                dcinf[ES.json_type_loc] = self.setLocation.mAtt[ES.type]
        if self.setDatation != None :
            if self.setDatation.nValue &gt; 1 : 
                dcinf[ES.json_type_dat] = ES.multi + self.setDatation.mAtt[ES.type]
            else :
                dcinf[ES.json_type_dat] = self.setDatation.mAtt[ES.type]
        if self.setProperty != None :
            if self.setProperty.nValue &gt; 1 : 
                dcinf[ES.json_type_prp] = ES.multi + self.setProperty.mAtt[ES.type]
            else :
                dcinf[ES.json_type_prp] = self.setProperty.mAtt[ES.type]
        if self.setResult != None :
            if self.setResult.nValue &gt; 1 : 
                dcinf[ES.json_type_res] = ES.multi + self.setResult.mAtt[ES.type]
            else :
                dcinf[ES.json_type_res] = self.setResult.mAtt[ES.type]

    def jsonInfoNval(self, dcinf):
        if self.setLocation != None : dcinf[ES.json_nval_loc] = self.setLocation.nValue
        if self.setDatation != None : dcinf[ES.json_nval_dat] = self.setDatation.nValue
        if self.setProperty != None : dcinf[ES.json_nval_prp] = self.setProperty.nValue
        if self.setResult   != None : dcinf[ES.json_nval_res] = self.setResult.nValue

    def jsonInfoBox(self, dcinf):
        if self.setLocation != None :
            dcinf[ES.loc_boxMin] = self.setLocation.boxMin.point
            dcinf[ES.loc_boxMax] = self.setLocation.boxMax.point
        if self.setDatation != None :
            dcinf[ES.dat_boxMin] = self.setDatation.boxMin.json(ES.mOption)
            dcinf[ES.dat_boxMax] = self.setDatation.boxMax.json(ES.mOption)

    def jsonInfoAutre(self, dcinf):
        dcinf[ES.obs_complet] = self.complet
        dcinf[ES.obs_score] = self.score
        if self.setResult != None :
            dcinf[ES.res_mRate] = self.setResult.measureRate
            dcinf[ES.res_dim] = self.setResult.dim
            dcinf[ES.res_axes] = self.setResult.axes

    def jsonInfo(self, types, nval, box, autre):
        dcinf = dict()
        if types :  self.jsonInfoTypes(dcinf)
        if nval :   self.jsonInfoNval(dcinf)
        if box :    self.jsonInfoBox(dcinf)
        if autre:   self.jsonInfoAutre(dcinf)
        ldel =[]
        for k,v in dcinf.items() :
            if type(v) == str and (v == &#34;null&#34; or v ==&#39;&#39;)   : ldel.append(k)
            if type(v) == list and v == ES.nullCoor         : ldel.append(k) 
        for k in ldel :         del dcinf[k]
        if len(dcinf) == 0 :    return &#34;&#34;
        else :                  return &#39;&#34;&#39; +ES.information + &#39;&#34;:&#39; + json.dumps(dcinf)

    def nValueObs(self):
        nPrp = nDat = nLoc = nRes = 0
        if self.setResult   != None: nRes = self.setResult.nValue
        if self.setLocation != None: nLoc = self.setLocation.nValue
        if self.setDatation != None: nDat = self.setDatation.nValue
        if self.setProperty != None: nPrp = self.setProperty.nValue
        return [nPrp, nDat, nLoc, nRes]

    def iloc(self, idat, iloc, iprp):
        if not self.complet : return dict()
        dic = dict()
        if self.setDatation != None and idat &lt; self.setDatation.nValue: 
            dic[ES.dat_classES] = self.setDatation.valueList[idat].json(self.option)
        if self.setLocation != None and iloc &lt; self.setLocation.nValue: 
            dic[ES.loc_classES] = self.setLocation.valueList[iloc].json(self.option)
        if self.setProperty != None and iprp &lt; self.setProperty.nValue: 
            dic[ES.prp_classES] = self.setProperty.valueList[iprp].json(self.option)
        if self.setResult != None : 
            for i in range(self.setResult.nValue) : 
                if self.setResult.valueList[i].ind == [idat, iloc, iprp] : 
                    dic[ES.res_classES] = self.setResult.valueList[i].json(self.option)
        return dic
    
    def typeObs(self):
        [nPrp, nDat, nLoc, nRes] = self.nValueObs()
        self.score = min(max(min(nPrp, 2) * 100 + min(nLoc,2) * 10 + min(nDat, 2), -1), 229);
        if self.setResult == None or (self.setResult.error or self.setResult.getMaxIndex() == -1 or \
           self.setResult.nInd[0] &gt; nDat or self.setResult.nInd[1] &gt; nLoc or self.setResult.nInd[2] &gt; nPrp):
               self.mAtt[ES.type] = &#34;obserror&#34;
               return
        if self.score == 22  and self.setResult.dim == 2:       self.score = 23
        if self.score == 122 and self.setResult.dim == 2:       self.score = 123
        if self.score == 202 and self.setResult.dim == 2:       self.score = 203
        if self.score == 212 and self.setResult.dim == 2:       self.score = 213
        if self.score == 220 and self.setResult.dim == 2:       self.score = 223
        if self.score == 221 and self.setResult.dim == 2:       self.score = 224
        if self.score == 222 and self.setResult.dim == 3:       self.score = 228
        if self.score == 222 and self.setResult.dim == 2 and 2 in self.setResult.axes:  self.score = 225
        if self.score == 222 and self.setResult.dim == 2 and 1 in self.setResult.axes:  self.score = 226
        if self.score == 222 and self.setResult.dim == 2 and 0 in self.setResult.axes:  self.score = 227
        self.mAtt[ES.type] = ES.obsCat[self.score]

    @staticmethod
    def sortAlign(npInd, list1, ind1, ind2):
        return [npInd[list(npInd[:,ind1]).index(i),:][ind2]  for i in list1]    
        
    def sort(self, order = [0, 1, 2], cross = True, sort = [[], [], []]):  
        if self.setResult == None or not self.setResult.isIndex() : return
        tr = tri = [[], [], []]
        for i in range(3) : tri[i] = self.sortSet(i, sort[i], False)
        npInd = np.array(self.setResult.vListIndex)
        if cross:
            for ax in self.setResult.axes : 
                if ax &gt; 100 : 
                    tri[order[1]] = self.sortAlign(npInd, tri[order[0]], order[0], order[1])
                    tri[order[2]] = self.sortAlign(npInd, tri[order[0]], order[0], order[2])
                elif ax &gt; 9 :
                    (first, second) = (ax//10, ax%10)
                    if order.index(second) &lt; order.index(first) : (first, second) = (second, first)
                    tri[second] = self.sortAlign(npInd, tri[first], first, second)
        for i in range(3) : tr[i] = self.sortSet(i, tri[i])
        for resVal in self.setResult.valueList :
            for i in range(3) : resVal.ind[i] = tr[i].index(resVal.ind[i])
        resTri = self.setResult.sort()
    
    def sortSet(self, ax, tri = [], update = True):
        if ax == 0 and self.setDatation != None : return self.setDatation.sort(tri, update)
        if ax == 1 and self.setLocation != None : return self.setLocation.sort(tri, update)
        if ax == 2 and self.setProperty != None : return self.setProperty.sort(tri, update)
        return [0]
    
    def majType(self, order = &#39;dlp&#39;):
        [nprp, ndat, nloc, nRes] = self.nValueObs()
        nPrp = max(1, nprp)
        nDat = max(1, ndat)
        nLoc = max(1, nloc)
        if len(order) == 3 : 
            self.complet = nRes == nLoc * nDat * nPrp \
                        or nRes == nDat * nPrp == nDat * nLoc \
                        or nRes == nLoc * nPrp == nLoc * nDat \
                        or nRes == nPrp * nLoc == nPrp * nDat \
                        or nRes == nLoc == nDat == nPrp
        if len(order) == 2 : 
            self.complet = nRes == nDat * nPrp == nDat * nLoc \
                        or nRes == nLoc * nPrp == nLoc * nDat \
                        or nRes == nPrp * nLoc == nPrp * nDat \
                        or nRes == nLoc == nDat == nPrp
        if len(order) == 1 : 
            self.complet = nRes == nLoc == nDat == nPrp
        
        if self.complet: self.setResult.majIndex(nRes, nPrp, nDat, nLoc, order)
        if self.setResult   != None: self.setResult.  analyse()
        if self.setLocation != None: self.setLocation.analyse()
        if self.setDatation != None: self.setDatation.analyse()
        self.typeObs()

    def xlist(self):
        xList = {}
        if self.setLocation != None: 
            xList[&#39;loc&#39;]    = self.setLocation.to_numpy()
            xList[&#39;locstr&#39;] = self.setLocation.to_numpy(func = LocationValue.json)
            xList[&#39;loclon&#39;] = self.setLocation.to_numpy(func = LocationValue.vPointX)
            xList[&#39;loclat&#39;] = self.setLocation.to_numpy(func = LocationValue.vPointY)
            xList[&#39;locnam&#39;] = self.setLocation.to_numpy(func = LocationValue.vName)
            xList[&#39;locran&#39;] = np.arange(len(xList[&#39;loc&#39;]))
        if self.setDatation != None: 
            xList[&#39;dat&#39;]    = self.setDatation.to_numpy()
            xList[&#39;datstr&#39;] = self.setDatation.to_numpy(func = DatationValue.json)
            xList[&#39;datnam&#39;] = self.setDatation.to_numpy(func = DatationValue.vName)
            xList[&#39;datran&#39;] = np.arange(len(xList[&#39;dat&#39;]))
        if self.setProperty != None: 
            xList[&#39;prp&#39;]    = self.setProperty.to_numpy()
            xList[&#39;prpstr&#39;] = self.setProperty.to_numpy(func = PropertyValue.json)
            xList[&#39;prpnam&#39;] = self.setProperty.to_numpy(func = PropertyValue.vName)
            xList[&#39;prpran&#39;] = np.arange(len(xList[&#39;prp&#39;]))
        if self.setResult  != None: 
            xList[&#39;res&#39;]    = self.setResult.to_numpy()
            xList[&#39;resval&#39;] = self.setResult.to_numpy(func = ResultValue.to_float)
            xList[&#39;resstr&#39;] = self.setResult.to_numpy(func = ResultValue.json)
            xList[&#39;resnam&#39;] = self.setResult.to_numpy(func = ResultValue.vName)
            xList[&#39;resran&#39;] = np.arange(len(xList[&#39;res&#39;]))
        return xList

    def xAttrs(self) :
        attrs = ES.xattrs
        attrs[&#39;info&#39;]   = json.loads(&#34;{&#34; + self.jsonInfo(True, False, True, False) + &#34;}&#34;)[&#34;information&#34;]
        return attrs

    def axeCoor(self, nValAxe) :
        for ax in self.setResult.axes :
            if ax &gt; 100 : return ax
            if ax &lt; 9 and nValAxe == ax : return ax
            elif ax &gt; 9 and (nValAxe == ax//10 or nValAxe == ax%10) : return ax
        return None
    
    def xCoord(self, xList, attrs, dataArray, complet, numeric) :
        #nax = {&#39;dat&#39; : 0, &#39;loc&#39; : 1, &#39;prp&#39; : 2}
        coord = {}
        for key, val in xList.items() :
            if key[:3] != &#39;res&#39; and self.axeCoor(ES.nax[key[:3]]) != None \
                and (complet or (not complet and len(key) == 3)):
                coord[key] = ([ES.axes[self.axeCoor(ES.nax[key[:3]])]], val, attrs[key[:3]])
                if key == &#39;loclon&#39; : coord[key] = (coord[key][0], val, attrs[&#39;lon&#39;])
                if key == &#39;loclat&#39; : coord[key] = (coord[key][0], val, attrs[&#39;lat&#39;])
        for ax in self.setResult.axes :
            if ax &gt; 9 :
                coord[ES.axes[ax]] = ([ES.axes[ax]], np.arange(len(xList[ES.axes[ax%10]])))
        if numeric :
            if &#39;loc&#39; in coord.keys() : coord[&#39;loc&#39;] = (coord[&#39;loc&#39;][0], xList[&#39;locran&#39;], coord[&#39;loc&#39;][2])
            if &#39;dat&#39; in coord.keys() : coord[&#39;dat&#39;] = (coord[&#39;dat&#39;][0], xList[&#39;datstr&#39;], coord[&#39;dat&#39;][2])
            if &#39;prp&#39; in coord.keys() : coord[&#39;prp&#39;] = (coord[&#39;prp&#39;][0], xList[&#39;prpran&#39;], coord[&#39;prp&#39;][2])
        return coord
    

    def to_xarray(self, dataArray = True, complet = False, info = False, numeric = False):
        self.sort()
        xList = self.xlist()
        attrs = self.xAttrs()
        coord = self.xCoord(xList, attrs, dataArray, complet, numeric=False)
        dims = [ES.axes[ax] for ax in self.setResult.axes]
        if numeric  : xres = xList[&#39;resval&#39;]
        else        : xres = xList[&#39;res&#39;]
        if dataArray and info :
            return xr.DataArray(xres, coord, dims, attrs=attrs[&#39;info&#39;])
        elif dataArray and not info :
            return xr.DataArray(xres, coord, dims)
        return None
    
    def plot(self):    


        if self.setResult.dim == 1 :
            obx = self.to_xarray().set_index(timeloc=&#34;point&#34;, prop = &#34;prpstr&#34;)
            if &#39;dat&#39; in obx.coords: obx.sortby([&#39;dat&#39;]).plot.line(x = &#39;dat&#39;)
            else : obx.plot.line(x=&#39;point&#39;)
            obg = self.to_geoDataFrame()
            for i in range(len(self.setProperty)): obg.plot(obg.columns.array[i], legend=True)
        elif self.setResult.dim == 2:
            obx = self.to_xarray().set_index(prop = &#34;prpstr&#34;)
            obx.sortby([&#34;dat&#34;, &#34;loc&#34;, &#34;prp&#34;]).plot(x=&#34;dat&#34;, y=&#34;loc&#34;, col=&#34;prp&#34;, col_wrap=2, size=5)
            obx.sortby([&#34;dat&#34;, &#34;loc&#34;, &#34;prp&#34;]).plot.line(    x=&#34;dat&#34;, col=&#34;prp&#34;, col_wrap=2, size=5)
            obg = self.to_geoDataFrame()
            for i in range(len(self.setProperty)): obg.plot(obg.columns.array[i], legend=True)
            plt.legend(obx.coords[&#39;loc&#39;].to_index().to_list())
        plt.show()    

    def to_dataFrame(self):
        if self.setResult.dim &gt; 0 : return self.to_xarray(False).to_dataframe()
        else : return None

    &#39;&#39;&#39;def majType(self, order = &#39;dlp&#39;):
        [nprp, ndat, nloc, nEch, nRes] = self.nValueObs()
        nPrp = max(1, nprp)
        nDat = max(1, ndat)
        nLoc = max(1, nloc)
        self.complet = (len(order) == 3 and  nRes == nLoc * nDat * nPrp) \
                        or nRes == nDat * nPrp == nDat * nLoc \
                        or nRes == nLoc * nPrp == nLoc * nDat \
                        or nRes == nPrp * nLoc == nPrp * nDat \
                        or nRes == nLoc == nDat == nPrp \
                        or nRes == 1
        if self.complet: self.setResult.majIndex(nRes, nPrp, nDat, nLoc, order)
        if self.setResult   != None: self.setResult.analyse()
        if self.setLocation != None: self.setLocation.analyse()
        if self.setDatation != None: self.setDatation.analyse()
        self.typeObs()&#39;&#39;&#39;

    &#39;&#39;&#39;def to_geoDataFrame(self):
        if self.setResult.dim &gt; 0 : return gp.GeoDataFrame(self.to_dataFrame())
        else : return None&#39;&#39;&#39;

    def choropleth(self):
        if self.setResult.dim == 1 or self.setResult.dim // 10 == 1:
            m = folium.Map(location=self.setLocation.valueList[0].coorInv, zoom_start=6)
            folium.PolyLine(
                list(self.setLocation.valueList[i].coorInv for i in range(len(self.setLocation.valueList)))
            ).add_to(m)
            folium.Choropleth(
                geo_data=self.jsonFeature,
                name=&#34;test choropleth&#34;,
                data=self.to_dataFrame(),
                key_on=&#34;feature.id&#34;,
                #columns=[&#34;point&#34;, json.loads(self.setProperty[0].json(False))[ES.prp_propType]],
                columns=[&#34;point&#34;, json.loads(self.setProperty[0].json(ES.mOption))[ES.prp_propType]],
                fill_color=&#34;BuGn&#34;,
                fill_opacity=0.7,
                line_opacity=0.2,
                legend_name=&#34;test choropleth&#34;
            ).add_to(m)
            folium.LayerControl().add_to(m)
            return m
        return None

    &#39;&#39;&#39;def typeObs(self):
        [nPrp, nDat, nLoc, nEch, nRes] = self.nValueObs()
        self.score = min(max(min(nEch, 2) * 100 + min(nLoc,2) * 10 + min(nDat, 2), -1), 223);
        if self.setResult != None and (self.setResult.error or self.setResult.getMaxIndex() == -1 or \
           self.setResult.nd &gt; nDat or self.setResult.nl &gt; nLoc or self.setResult.np &gt; nPrp):
               self.mAtt[ES.type] = &#34;obserror&#34;
               return
        self.mAtt[ES.type] = ES.obsCat[self.score]
        if self.score == 222 and self.setResult.dim == 1:       self.mAtt[ES.type] = &#34;obsPath&#34;
        if self.score == 222 and self.setResult.dim == 2:       self.mAtt[ES.type] = &#34;obsAreaSequence&#34;&#39;&#39;&#39;

    &#39;&#39;&#39;def tri2(self) :
        tup = [((self.setDatation.valueList[i], i)) for i in range(self.setDatation.nValue)]
        self.setDatation.iSort = [ v[1] for v in sorted(tup, key=lambda l: l[0])]
        tup = [((self.setLocation.valueList[i], i)) for i in range(self.setLocation.nValue)]
        self.setLocation.iSort = [ v[1] for v in sorted(tup, key=lambda l: l[0])]
        tup = [((self.setProperty.valueList[i], i)) for i in range(self.setProperty.nValue)]
        self.setProperty.iSort = [ v[1] for v in sorted(tup, key=lambda l: l[0])]
        tup = [(([self.setDatation.iSort[self.setResult.valueList[i].ind[0]],
                  self.setLocation.iSort[self.setResult.valueList[i].ind[1]],
                  self.setProperty.iSort[self.setResult.valueList[i].ind[2]]]
                  , i)) for i in range(self.setResult.nValue)]
        #tup = [((self.setResult.valueList[i], i)) for i in range(self.setResult.nValue)]
        self.setResult.iSort = [ v[1] for v in sorted(tup, key=lambda l: l[0])]&#39;&#39;&#39;

    &#39;&#39;&#39;def nValueObs(self):
        nPrp = nDat = nLoc = nEch = nRes = 0
        if self.setResult   != None: nEch = self.setResult.nEch
        if self.setResult   != None: nRes = self.setResult.nValue
        if self.setLocation != None: nLoc = self.setLocation.nValue
        if self.setDatation != None: nDat = self.setDatation.nValue
        if self.setProperty != None: nPrp = self.setProperty.nValue
        return [nPrp, nDat, nLoc, nEch, nRes]&#39;&#39;&#39;
    
    &#39;&#39;&#39;for ax in self.axes :
            coord[ES.axes[ax]]=([ES.axes[ax]], )
        
        
        [nPrp, nDat, nLoc, nRes] = self.nValueObs()
        nDatLoc = max(nDat, nLoc)
        coord = {}
        coord[&#34;prp&#34;]            = ([&#34;prp&#34;], xList[&#39;prp&#39;]        , attrs[&#39;prp&#39;])
        coord[&#34;prpstr&#34;]         = ([&#34;prp&#34;], xList[&#39;prpstr&#39;]     , attrs[&#39;prp&#39;])
        if self.setResult.dim == 1: 
            coord[&#34;datloc&#34;]      = ([&#34;datloc&#34;], np.arange(nDatLoc))
            coord[&#34;point&#34;]      = ([&#34;datloc&#34;], np.arange(nDatLoc))
            #coord[&#34;datloc&#34;]     = ([&#34;datloc&#34;], xList[&#39;datlocstr&#39;], attrs[&#39;datloc&#39;])
            if nLoc == nDatLoc:
                coord[&#34;lon&#34;]    = ([&#34;datloc&#34;], xList[&#39;lon&#39;]     , attrs[&#39;lon&#39;])
                coord[&#34;lat&#34;]    = ([&#34;datloc&#34;], xList[&#39;lat&#39;]     , attrs[&#39;lat&#39;])
                coord[&#34;geometry&#34;] = ([&#34;datloc&#34;], xList[&#39;loc&#39;]   , attrs[&#39;loc&#39;])
                coord[&#34;locstr&#34;] = ([&#34;datloc&#34;], xList[&#39;locstr&#39;]  , attrs[&#39;loc&#39;])
            if nDat == nDatLoc:
                coord[&#34;dat&#34;]    = ([&#34;datloc&#34;], xList[&#39;dat&#39;]     , attrs[&#39;dat&#39;])
                #coord[&#34;datstr&#34;] = ([&#34;datloc&#34;], xList[&#39;datstr&#39;]  , attrs[&#39;dat&#39;])
            if dataArray:
                ranking = np.arange(nDatLoc * nPrp).reshape(nDatLoc, nPrp)
                coord[&#34;ranking&#34;] = ([&#34;datloc&#34;, &#34;prp&#34;]           , ranking)
            else :
                ranking = np.arange(nDatLoc)
                coord[&#34;ranking&#34;] = ([&#34;datloc&#34;], ranking)
                coord.pop(&#39;prp&#39;)
                coord.pop(&#39;prpstr&#39;)
        else : 
            coord[&#34;geometry&#34;]   = ([&#34;loc&#34;], xList[&#39;loc&#39;]    , attrs[&#39;loc&#39;])
            coord[&#34;loc&#34;]        = ([&#34;loc&#34;], np.arange(nLoc))
            coord[&#34;lon&#34;]        = ([&#34;loc&#34;], xList[&#39;lon&#39;]    , attrs[&#39;lon&#39;])
            coord[&#34;lat&#34;]        = ([&#34;loc&#34;], xList[&#39;lat&#39;]    , attrs[&#39;lat&#39;])
            coord[&#34;locstr&#34;]     = ([&#34;loc&#34;], xList[&#39;locstr&#39;] , attrs[&#39;loc&#39;])
            coord[&#34;dat&#34;]        = ([&#34;dat&#34;], xList[&#39;dat&#39;]    , attrs[&#39;dat&#39;])
            coord[&#34;datstr&#34;]     = ([&#34;dat&#34;], xList[&#39;datstr&#39;] , attrs[&#39;dat&#39;])
            if dataArray :
                ranking = np.arange(nDat * nLoc * nPrp).reshape(nDat, nLoc, nPrp)
                coord[&#34;ranking&#34;] = ([&#34;dat&#34;, &#34;loc&#34;, &#34;prp&#34;]   , ranking)
            else :
                ranking = np.arange(nDat * nLoc).reshape(nDat, nLoc)
                coord[&#34;ranking&#34;] = ([&#34;dat&#34;, &#34;loc&#34;], ranking)
                coord.pop(&#39;prp&#39;)
                coord.pop(&#39;prpstr&#39;)
        return coord&#39;&#39;&#39;

    &#39;&#39;&#39;
        [nPrp, nDat, nLoc, nRes] = self.nValueObs()
        xList[&#39;loc&#39;] = xList[&#39;dat&#39;] = xList[&#39;prp&#39;] = xList[&#39;res&#39;] = list()
        xList[&#39;res&#39;]    = self.setResult.valueList
        if self.setLocation != None: xList[&#39;loc&#39;] = [val.shap for val in self.setLocation.valueList]
        #if self.setLocation != None: xList[&#39;loc&#39;] = self.setLocation.vListPoint
        #if self.setDatation != None: xList[&#39;dat&#39;] = [val.instant for val in self.setDatation.valueList]
        if self.setDatation != None: xList[&#39;dat&#39;] = self.setDatation.vListInstant
        if self.setProperty != None: xList[&#39;prp&#39;] = self.setProperty.valueList
        xList[&#39;lon&#39;]    = [geo.centroid.x for geo in xList[&#39;loc&#39;]]
        xList[&#39;lat&#39;]    = [geo.centroid.y for geo in xList[&#39;loc&#39;]]
        #xList[&#39;lon&#39;]    = [geo[0] for geo in xList[&#39;loc&#39;]]
        #xList[&#39;lat&#39;]    = [geo[1] for geo in xList[&#39;loc&#39;]]
        xList[&#39;locstr&#39;] = [json.dumps(geo.shap.__geo_interface__) for geo in self.setLocation.valueList]
        #xList[&#39;datstr&#39;] = [dat.isoformat() for dat in xList[&#39;dat&#39;]]
        #if xList[&#39;datstr&#39;] == []: xList[&#39;datlocstr&#39;] = xList[&#39;locstr&#39;]
        #elif xList[&#39;locstr&#39;] == []: xList[&#39;datlocstr&#39;] = xList[&#39;datstr&#39;]
        #else : xList[&#39;datlocstr&#39;] = [xList[&#39;datstr&#39;][min(i, nDat-1)] + xList[&#39;locstr&#39;][min(i, nLoc-1)] 
                                     #for i in range(max(nDat, nLoc))]
        xList[&#39;prpstr&#39;] = [pr.json(ES.mOption) for pr in xList[&#39;prp&#39;]]
        xList[&#39;resvalue&#39;] = [res.value for res in xList[&#39;res&#39;]]
        &#39;&#39;&#39;    

    &#39;&#39;&#39;def xCoord2(self, xList, attrs, dataArray) :
        [nPrp, nDat, nLoc, nRes] = self.nValueObs()
        nDatLoc = max(nDat, nLoc)
        coord = {}
        coord[&#34;prp&#34;]            = ([&#34;prp&#34;], xList[&#39;prp&#39;]        , attrs[&#39;prp&#39;])
        coord[&#34;prpstr&#34;]         = ([&#34;prp&#34;], xList[&#39;prpstr&#39;]     , attrs[&#39;prp&#39;])
        if self.setResult.dim == 1: 
            coord[&#34;datloc&#34;]      = ([&#34;datloc&#34;], np.arange(nDatLoc))
            coord[&#34;point&#34;]      = ([&#34;datloc&#34;], np.arange(nDatLoc))
            #coord[&#34;datloc&#34;]     = ([&#34;datloc&#34;], xList[&#39;datlocstr&#39;], attrs[&#39;datloc&#39;])
            if nLoc == nDatLoc:
                coord[&#34;lon&#34;]    = ([&#34;datloc&#34;], xList[&#39;lon&#39;]     , attrs[&#39;lon&#39;])
                coord[&#34;lat&#34;]    = ([&#34;datloc&#34;], xList[&#39;lat&#39;]     , attrs[&#39;lat&#39;])
                coord[&#34;geometry&#34;] = ([&#34;datloc&#34;], xList[&#39;loc&#39;]   , attrs[&#39;loc&#39;])
                coord[&#34;locstr&#34;] = ([&#34;datloc&#34;], xList[&#39;locstr&#39;]  , attrs[&#39;loc&#39;])
            if nDat == nDatLoc:
                coord[&#34;dat&#34;]    = ([&#34;datloc&#34;], xList[&#39;dat&#39;]     , attrs[&#39;dat&#39;])
                #coord[&#34;datstr&#34;] = ([&#34;datloc&#34;], xList[&#39;datstr&#39;]  , attrs[&#39;dat&#39;])
            if dataArray:
                ranking = np.arange(nDatLoc * nPrp).reshape(nDatLoc, nPrp)
                coord[&#34;ranking&#34;] = ([&#34;datloc&#34;, &#34;prp&#34;]           , ranking)
            else :
                ranking = np.arange(nDatLoc)
                coord[&#34;ranking&#34;] = ([&#34;datloc&#34;], ranking)
                coord.pop(&#39;prp&#39;)
                coord.pop(&#39;prpstr&#39;)
        else : 
            coord[&#34;geometry&#34;]   = ([&#34;loc&#34;], xList[&#39;loc&#39;]    , attrs[&#39;loc&#39;])
            coord[&#34;loc&#34;]        = ([&#34;loc&#34;], np.arange(nLoc))
            coord[&#34;lon&#34;]        = ([&#34;loc&#34;], xList[&#39;lon&#39;]    , attrs[&#39;lon&#39;])
            coord[&#34;lat&#34;]        = ([&#34;loc&#34;], xList[&#39;lat&#39;]    , attrs[&#39;lat&#39;])
            coord[&#34;locstr&#34;]     = ([&#34;loc&#34;], xList[&#39;locstr&#39;] , attrs[&#39;loc&#39;])
            coord[&#34;dat&#34;]        = ([&#34;dat&#34;], xList[&#39;dat&#39;]    , attrs[&#39;dat&#39;])
            coord[&#34;datstr&#34;]     = ([&#34;dat&#34;], xList[&#39;datstr&#39;] , attrs[&#39;dat&#39;])
            if dataArray :
                ranking = np.arange(nDat * nLoc * nPrp).reshape(nDat, nLoc, nPrp)
                coord[&#34;ranking&#34;] = ([&#34;dat&#34;, &#34;loc&#34;, &#34;prp&#34;]   , ranking)
            else :
                ranking = np.arange(nDat * nLoc).reshape(nDat, nLoc)
                coord[&#34;ranking&#34;] = ([&#34;dat&#34;, &#34;loc&#34;], ranking)
                coord.pop(&#39;prp&#39;)
                coord.pop(&#39;prpstr&#39;)
        return coord&#39;&#39;&#39;
    
        
        
    &#39;&#39;&#39;if self.setResult == None: return None
        xList = self.xlist()
        [nPrp, nDat, nLoc, nRes] = self.nValueObs()
        nDatLoc = max(nDat, nLoc)
        attrs = self.xAttrs()
        coord = self.xCoord(xList, attrs, dataArray)
        
        if self.setResult.dim == 1 :
            value = np.array(xList[&#39;resvalue&#39;]).reshape(nDatLoc, nPrp)
            if dataArray :
                return xr.DataArray(data=value, dims=[&#34;datloc&#34;, &#34;prp&#34;],
                                    coords=coord, attrs=attrs[&#39;info&#39;])
            else :
                datas ={}
                for i in range(nPrp):
                    prp = json.loads(xList[&#39;prp&#39;][i].json(ES.mOption))
                    datas[prp[ES.prp_propType]] = ([&#34;datloc&#34;], value[:,i])
                return xr.Dataset(data_vars=datas, coords=coord, attrs=attrs[&#39;info&#39;])
        elif self.setResult.dim == 2 :
            value = np.array(xList[&#39;resvalue&#39;]).reshape(nDat, nLoc, nPrp)
            if dataArray :
                return xr.DataArray(data=value, dims=[&#34;dat&#34;, &#34;loc&#34;, &#34;prp&#34;],
                                    coords=coord, attrs=attrs[&#39;info&#39;])    
            else :
                datas ={}
                for i in range(nPrp):
                    prp = json.loads(xList[&#39;prp&#39;][i].json(ES.mOption))
                    datas[prp[ES.prp_propType]] = ([&#34;dat&#34;,&#34;loc&#34;], value[:,:,i], 
                                                  {&#34;units&#34;: prp[&#34;unit&#34;]})
                return xr.Dataset(data_vars = datas, coords =  coord, attrs =  attrs[&#39;info&#39;])
        else : return None&#39;&#39;&#39;</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ES.ESObservation.Observation"><code class="flex name class">
<span>class <span class="ident">Observation</span></span>
<span>(</span><span>jso={}, order='dlp')</span>
</code></dt>
<dd>
<div class="desc"><p>An <code><a title="ES.ESObservation.Observation" href="#ES.ESObservation.Observation">Observation</a></code> is made up of objects from the <code><a title="ES.ESObs" href="ESObs.html">ES.ESObs</a></code> class
which each describe a dimension of this object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Observation(ESObject):
    &#34;&#34;&#34;
    An `ES.ESObservation.Observation` is made up of objects from the `ES.ESObs` class
     which each describe a dimension of this object.
    &#34;&#34;&#34;
    def __init__(self, jso = {}, order = &#39;dlp&#39;):
        ESObject.__init__(self)
        self.option = ES.mOption.copy()
        self.mAtt[ES.obs_reference] = 0
        &#39;&#39;&#39; Attribut décrivant une `Observation` de référence utilisée pour compléter l&#39;Observation actuelle.&#39;&#39;&#39;
        self.score = -1
        &#39;&#39;&#39; Nature de l&#39;assemblage des différents composants. Par exemple 122 
        indique qu&#39;il s&#39;agit d&#39;une mesure unique sur un trajet&#39;&#39;&#39;
        self.complet = False
        &#39;&#39;&#39; True si le nombre de résultats est cohérent avec le nombre d&#39;objets de type Location, Datation et Property.&#39;&#39;&#39;
        self.mAtt[ES.obs_resultTime] = &#34;null&#34;
        self.classES = ES.obs_classES
        self.typeES = ES.obs_typeES
        self.mAtt[ES.type] = &#34;obsError&#34;
        self.mAtt[ES.obs_id] = &#34;null&#34;
        if type(jso) == str :
            try:
                js=json.loads(jso)
            except:
                return
        elif type(jso) == dict :
            js = jso.copy()
        else : return
        if js == {}: return
        if ES.type not in list(js) or js[ES.type] != ES.obs_classES: return
        if ES.obs_id in list(js): self.mAtt[ES.obs_id] = js[ES.obs_id]
        if ES.obs_attributes in list(js): 
            if type(js[ES.obs_attributes]) == dict: js = js[ES.obs_attributes]
            else: return
        self.addAttributes(js)
        if isESObs(ES.dat_classES, js): ESSetDatation(self, js)
        if isESObs(ES.loc_classES, js): ESSetLocation(self, js)
        if isESObs(ES.prp_classES, js): ESSetProperty(self, js)
        if isESObs(ES.res_classES, js): ESSetResult  (self, js)
        self.majType(order)

    def addAttributes(self, js):
        &#39;&#39;&#39;Ajout d&#39;attributs à une Observation&#39;&#39;&#39;
        if type(js) != dict: return
        for k, v in js.items():
            if isESAtt(ES.obs_classES, k) or isUserAtt(k): self.mAtt[k] = v
            if k == ES.parameter: 
                try:  self.parameter = json.dumps(v)
                except:  self.parameter = &#34;null&#34;

    @property
    def bounds(self):
        &#39;&#39;&#39;boîte englobante de l&#39;Observation&#39;&#39;&#39;
        if self.setLocation : return shape(self).bounds
        else : return None

    @property
    def __geo_interface__(self):
        &#39;&#39;&#39;if self.option[&#34;json_loc_point&#34;] : indice = 0
        else : indice = 1&#39;&#39;&#39;
        if self.setLocation : 
            return gshape(self.setLocation.jsonSet(self.option)).__geo_interface__
            #return gshape(self.setLocation.geoInterface(self.option)).__geo_interface__
            &#39;&#39;&#39;return gshape(json.dumps(json.loads(&#39;{&#39; \
                        #+ self.setLocation.json(False, False, False, False)\
                        + self.setLocation.geoInterface(self.option)\
                        #+ &#39;}&#39;)[&#34;coordinates&#34;])).__geo_interface__
                        + &#39;}&#39;)[ES.loc_valName[indice]])).__geo_interface__&#39;&#39;&#39;
        else : return &#34;&#34;

    @property
    def jsonFeature(self):
        if self.setLocation : 
            geo = self.__geo_interface__
            if geo[&#39;type&#39;] == &#34;MultiPolygon&#34;: typ = &#34;Polygon&#34;
            else : typ = &#34;Point&#34;
            lis = list(dict(((&#34;type&#34;, typ), (&#34;coordinates&#34;, geo[&#39;coordinates&#39;][i]))) for i in range(len(geo[&#39;coordinates&#39;])))
            fea = list(dict(((&#34;type&#34;,&#34;Feature&#34;), (&#34;id&#34;, i), (&#34;geometry&#34;, lis[i]))) for i in range(len(geo[&#39;coordinates&#39;])))
            return json.dumps(dict(((&#34;type&#34;,&#34;FeatureCollection&#34;), (&#34;features&#34;,fea))))            
        else: return &#39;&#39;  
            
    @property
    def setLocation(self):  return self.element(ES.loc_classES)
    &#39;&#39;&#39; Objet `setLocation`s&#39;il existe, None sinon.&#39;&#39;&#39;
    @property
    def setDatation(self):  return self.element(ES.dat_classES)
    @property
    def setProperty(self):  return self.element(ES.prp_classES)
    @property
    def setResult(self):  return self.element(ES.res_classES)

    def __copy__(self):
        opt = self.option
        self.option[&#34;json_obs_val&#34;] = True
        cop = Observation(self.json())
        self.option = opt
        cop.option = opt
        return cop

    def __iadd__(self, other):
        other_opt = other.option
        self_opt = self.option
        ndat = nloc = nres = nprp = 0
        idat = 0; iloc = 1; iprp = 2
        other.option[&#34;maj_index&#34;] = True
        other.majType()
        self.option[&#34;maj_index&#34;] = True
        self.majType()
        if other.setResult != None and other.setResult.getMaxIndex() &gt; -1:
            for resVal in other.setResult.valueList:
                ndat = self.addValue(other.setDatation.valueList[resVal.ind[idat]])
                nloc = self.addValue(other.setLocation.valueList[resVal.ind[iloc]])
                nprp = self.addValue(other.setProperty.valueList[resVal.ind[iprp]])
                resv = ResultValue(resVal.value)
                resv.ind = [ndat, nloc, nprp]
                self.addResultValue(resv)
            self.majType()
        other.option = other_opt
        self.option = self_opt
        return self
    
    def __add__(self, other):
        obres = self.__copy__()
        obres.__iadd__(other)
        return obres
    
    def extend(self, obs):
        for p in obs.pComposant :
            if self.element(p.classES) == None : self.addComposant(p)
        self.majType()    
        
    def addResultValue(self, esValue):
        return self.element(ES.res_valueType).addValue(ResultValue, esValue)
    
    def addValue(self, esValue):
        if type(esValue)== PropertyValue:
            if self.element(ES.prp_valueType) == None: esSet = ESSetProperty(self)
            return self.element(ES.prp_valueType).addValue(PropertyValue, esValue)
        elif type(esValue)== LocationValue:
            if self.element(ES.loc_valueType) == None: esSet = ESSetLocation(self)
            return self.element(ES.loc_valueType).addValue(LocationValue, esValue)
        elif type(esValue)== DatationValue:
            if self.element(ES.dat_valueType) == None: esSet = ESSetDatation(self)
            return self.element(ES.dat_valueType).addValue(DatationValue, esValue)
        else: return 0

    def addListResultValue(self, listEsValue):
        if type(listEsValue) != list : return
        if self.element(ES.res_valueType) == None: resSet = ESSetResult(self)
        else: resSet = self.setResult
        for val in listEsValue : resSet.addValue(ResultValue, ResultValue(val))
            #self.addResultValue(ResultValue(val) )

    def majList(self, ValueClass, listVal, info = &#39;name&#39;):
        if ValueClass == DatationValue and self.setDatation != None : 
            if info == &#39;name&#39;: self.setDatation.majListName(listVal)
            else : self.setDatation.majListValue(ValueClass, listVal, info == &#39;base&#39;)
        elif ValueClass == LocationValue and self.setLocation != None : 
            if info == &#39;name&#39;: self.setLocation.majListName(listVal)
            else : self.setLocation.majListValue(ValueClass, listVal, info == &#39;base&#39;)
        elif ValueClass == PropertyValue and self.setProperty != None : 
            if info == &#39;name&#39;: self.setProperty.majListName(listVal)

    def addListValue(self, ValueClass, listEsValue):
        for val in listEsValue : self.addValue(ValueClass(val) )
        
    def addValueObservation(self, val, idat, iloc, iprp):
        if self.element(ES.res_valueType) == None: resSet = ESSetResult(self)
        return self.addResultValue(ResultValue(val, [idat, iloc, iprp]))

    def addListValueObservation(self, val, idat, iloc, iprp):
        for i in range(len(val)) :
            self.addResultValue(ResultValue(val[i], [idat[i], iloc[i], iprp[i]]))

    def addValueSensor(self, val, tim, coor, nprp):
        return self.addValueObservation(val, self.addValue(tim), self.addValue(coor), nprp)

    def json(self): 
        &#39;&#39;&#39; Export de l&#39;Observation sou s la forme dune chaîne de caractères au format JSON&#39;&#39;&#39;
        if self.option[&#34;json_elt_type&#34;]: option_type = 1
        else: option_type = 0
        js =&#34;&#34;
        &#39;&#39;&#39;variable interne retournée&#39;&#39;&#39;
        if self.option[&#34;json_obs_val&#34;]: js = &#34;{&#34;
        js += &#39;&#34;&#39; + ES.type +&#39;&#34;:&#34;&#39; + ES.obs_classES +&#39;&#34;,&#39;
        if self.mAtt[ES.obs_id] != &#34;null&#34;: js += &#39;&#34;&#39; + ES.obs_id + &#39;&#34;:&#34;&#39; + self.mAtt[ES.obs_id] + &#39;&#34;,&#39;
        if self.option[&#34;json_obs_attrib&#34;]: js += &#39;&#34;&#39; + ES.obs_attributes + &#39;&#34;:{&#39;
        js += self.jsonAtt(option_type)
        for cp in self.pComposant:
            js += cp.json(self.option)
            if js[-1] != &#39;,&#39;: js += &#34;,&#34;
        if self.option[&#34;json_param&#34;] and self.parameter != &#34;null&#34;: 
            js += &#39;&#34;&#39; + ES.parameter +&#39;&#34;:&#39; + self.parameter + &#39;,&#39;
        jsInfo = self.jsonInfo(self.option[&#34;json_info_type&#34;], self.option[&#34;json_info_nval&#34;],
                            self.option[&#34;json_info_box&#34;], self.option[&#34;json_info_autre&#34;])
        if jsInfo != &#34;&#34; : js +=  jsInfo + &#39;,&#39;
        if js[-1] == &#39;,&#39;: js = js[:-1]
        if self.option[&#34;json_obs_attrib&#34;]: js += &#34;}&#34;
        if self.option[&#34;json_obs_val&#34;]:    js += &#34;}&#34;
        return js
    
    def to_bytes(self):
        byt = bytes()
        code_el = ES.codeb[self.classES] 
        byt += struct.pack(&#39;&lt;B&#39;, (code_el &lt;&lt; 5) | self.mAtt[ES.obs_reference])
        if self.setProperty != None: 
            byt += self.setProperty.to_bytes(self.option[&#34;json_prp_name&#34;])
        if self.setLocation != None: 
            byt += self.setLocation.to_bytes(self.option[&#34;json_loc_name&#34;])
        if self.setDatation != None: 
            byt += self.setDatation.to_bytes(self.option[&#34;json_dat_name&#34;])
        if self.setResult != None: 
            propList = [self.setProperty.valueList[i].pType 
                        for i in range(self.setProperty.nValue)]
            byt += self.setResult.to_bytes(False, self.option[&#34;json_res_index&#34;], 
                                           self.option[&#34;bytes_res_format&#34;], propList)
        return byt
        
    def from_bytes(self, byt):
        code_ob = (byt[0] &amp; 0b11100000) &gt;&gt; 5
        self.mAtt[ES.obs_reference] = byt[0] &amp; 0b00011111
        if code_ob != ES.codeb[self.classES]: return
        idx = 1
        while idx &lt; byt.__len__() :
            code_el = (byt[idx] &amp; 0b11100000) &gt;&gt; 5
            #forma =  byt[idx] &amp; 0b00001111
            if   code_el == 1: es = ESSetLocation(self)
            elif code_el == 2: es = ESSetDatation(self)
            elif code_el == 3: es = ESSetProperty(self)
            elif code_el &lt; 6:
                es = ESSetResult(self)
                if code_el == 5: 
                    propList = [self.setProperty.valueList[i].pType 
                            for i in range(self.setProperty.nValue)]
                else :
                    n = es.from_bytes(byt[idx:], [])
                    es.majIndex(es.nValue, self.setProperty.nValue, 
                            self.setDatation.nValue, self.setLocation.nValue)
                    propList = [self.setProperty.valueList[es.valueList[i].ind[2]].pType
                            for i in range(es.nValue)]
                    es.__init__()
            else: return
            if code_el &lt; 4 : 
                idx += es.from_bytes(byt[idx:])
            else :
                idx += es.from_bytes(byt[idx:], propList)
    
    def jsonInfoTypes(self, dcinf):
        dcinf[ES.json_type_obs] = self.mAtt[ES.type]
        if self.setLocation != None :
            if self.setLocation.nValue &gt; 1 : 
                dcinf[ES.json_type_loc] = ES.multi + self.setLocation.mAtt[ES.type]
            else :
                dcinf[ES.json_type_loc] = self.setLocation.mAtt[ES.type]
        if self.setDatation != None :
            if self.setDatation.nValue &gt; 1 : 
                dcinf[ES.json_type_dat] = ES.multi + self.setDatation.mAtt[ES.type]
            else :
                dcinf[ES.json_type_dat] = self.setDatation.mAtt[ES.type]
        if self.setProperty != None :
            if self.setProperty.nValue &gt; 1 : 
                dcinf[ES.json_type_prp] = ES.multi + self.setProperty.mAtt[ES.type]
            else :
                dcinf[ES.json_type_prp] = self.setProperty.mAtt[ES.type]
        if self.setResult != None :
            if self.setResult.nValue &gt; 1 : 
                dcinf[ES.json_type_res] = ES.multi + self.setResult.mAtt[ES.type]
            else :
                dcinf[ES.json_type_res] = self.setResult.mAtt[ES.type]

    def jsonInfoNval(self, dcinf):
        if self.setLocation != None : dcinf[ES.json_nval_loc] = self.setLocation.nValue
        if self.setDatation != None : dcinf[ES.json_nval_dat] = self.setDatation.nValue
        if self.setProperty != None : dcinf[ES.json_nval_prp] = self.setProperty.nValue
        if self.setResult   != None : dcinf[ES.json_nval_res] = self.setResult.nValue

    def jsonInfoBox(self, dcinf):
        if self.setLocation != None :
            dcinf[ES.loc_boxMin] = self.setLocation.boxMin.point
            dcinf[ES.loc_boxMax] = self.setLocation.boxMax.point
        if self.setDatation != None :
            dcinf[ES.dat_boxMin] = self.setDatation.boxMin.json(ES.mOption)
            dcinf[ES.dat_boxMax] = self.setDatation.boxMax.json(ES.mOption)

    def jsonInfoAutre(self, dcinf):
        dcinf[ES.obs_complet] = self.complet
        dcinf[ES.obs_score] = self.score
        if self.setResult != None :
            dcinf[ES.res_mRate] = self.setResult.measureRate
            dcinf[ES.res_dim] = self.setResult.dim
            dcinf[ES.res_axes] = self.setResult.axes

    def jsonInfo(self, types, nval, box, autre):
        dcinf = dict()
        if types :  self.jsonInfoTypes(dcinf)
        if nval :   self.jsonInfoNval(dcinf)
        if box :    self.jsonInfoBox(dcinf)
        if autre:   self.jsonInfoAutre(dcinf)
        ldel =[]
        for k,v in dcinf.items() :
            if type(v) == str and (v == &#34;null&#34; or v ==&#39;&#39;)   : ldel.append(k)
            if type(v) == list and v == ES.nullCoor         : ldel.append(k) 
        for k in ldel :         del dcinf[k]
        if len(dcinf) == 0 :    return &#34;&#34;
        else :                  return &#39;&#34;&#39; +ES.information + &#39;&#34;:&#39; + json.dumps(dcinf)

    def nValueObs(self):
        nPrp = nDat = nLoc = nRes = 0
        if self.setResult   != None: nRes = self.setResult.nValue
        if self.setLocation != None: nLoc = self.setLocation.nValue
        if self.setDatation != None: nDat = self.setDatation.nValue
        if self.setProperty != None: nPrp = self.setProperty.nValue
        return [nPrp, nDat, nLoc, nRes]

    def iloc(self, idat, iloc, iprp):
        if not self.complet : return dict()
        dic = dict()
        if self.setDatation != None and idat &lt; self.setDatation.nValue: 
            dic[ES.dat_classES] = self.setDatation.valueList[idat].json(self.option)
        if self.setLocation != None and iloc &lt; self.setLocation.nValue: 
            dic[ES.loc_classES] = self.setLocation.valueList[iloc].json(self.option)
        if self.setProperty != None and iprp &lt; self.setProperty.nValue: 
            dic[ES.prp_classES] = self.setProperty.valueList[iprp].json(self.option)
        if self.setResult != None : 
            for i in range(self.setResult.nValue) : 
                if self.setResult.valueList[i].ind == [idat, iloc, iprp] : 
                    dic[ES.res_classES] = self.setResult.valueList[i].json(self.option)
        return dic
    
    def typeObs(self):
        [nPrp, nDat, nLoc, nRes] = self.nValueObs()
        self.score = min(max(min(nPrp, 2) * 100 + min(nLoc,2) * 10 + min(nDat, 2), -1), 229);
        if self.setResult == None or (self.setResult.error or self.setResult.getMaxIndex() == -1 or \
           self.setResult.nInd[0] &gt; nDat or self.setResult.nInd[1] &gt; nLoc or self.setResult.nInd[2] &gt; nPrp):
               self.mAtt[ES.type] = &#34;obserror&#34;
               return
        if self.score == 22  and self.setResult.dim == 2:       self.score = 23
        if self.score == 122 and self.setResult.dim == 2:       self.score = 123
        if self.score == 202 and self.setResult.dim == 2:       self.score = 203
        if self.score == 212 and self.setResult.dim == 2:       self.score = 213
        if self.score == 220 and self.setResult.dim == 2:       self.score = 223
        if self.score == 221 and self.setResult.dim == 2:       self.score = 224
        if self.score == 222 and self.setResult.dim == 3:       self.score = 228
        if self.score == 222 and self.setResult.dim == 2 and 2 in self.setResult.axes:  self.score = 225
        if self.score == 222 and self.setResult.dim == 2 and 1 in self.setResult.axes:  self.score = 226
        if self.score == 222 and self.setResult.dim == 2 and 0 in self.setResult.axes:  self.score = 227
        self.mAtt[ES.type] = ES.obsCat[self.score]

    @staticmethod
    def sortAlign(npInd, list1, ind1, ind2):
        return [npInd[list(npInd[:,ind1]).index(i),:][ind2]  for i in list1]    
        
    def sort(self, order = [0, 1, 2], cross = True, sort = [[], [], []]):  
        if self.setResult == None or not self.setResult.isIndex() : return
        tr = tri = [[], [], []]
        for i in range(3) : tri[i] = self.sortSet(i, sort[i], False)
        npInd = np.array(self.setResult.vListIndex)
        if cross:
            for ax in self.setResult.axes : 
                if ax &gt; 100 : 
                    tri[order[1]] = self.sortAlign(npInd, tri[order[0]], order[0], order[1])
                    tri[order[2]] = self.sortAlign(npInd, tri[order[0]], order[0], order[2])
                elif ax &gt; 9 :
                    (first, second) = (ax//10, ax%10)
                    if order.index(second) &lt; order.index(first) : (first, second) = (second, first)
                    tri[second] = self.sortAlign(npInd, tri[first], first, second)
        for i in range(3) : tr[i] = self.sortSet(i, tri[i])
        for resVal in self.setResult.valueList :
            for i in range(3) : resVal.ind[i] = tr[i].index(resVal.ind[i])
        resTri = self.setResult.sort()
    
    def sortSet(self, ax, tri = [], update = True):
        if ax == 0 and self.setDatation != None : return self.setDatation.sort(tri, update)
        if ax == 1 and self.setLocation != None : return self.setLocation.sort(tri, update)
        if ax == 2 and self.setProperty != None : return self.setProperty.sort(tri, update)
        return [0]
    
    def majType(self, order = &#39;dlp&#39;):
        [nprp, ndat, nloc, nRes] = self.nValueObs()
        nPrp = max(1, nprp)
        nDat = max(1, ndat)
        nLoc = max(1, nloc)
        if len(order) == 3 : 
            self.complet = nRes == nLoc * nDat * nPrp \
                        or nRes == nDat * nPrp == nDat * nLoc \
                        or nRes == nLoc * nPrp == nLoc * nDat \
                        or nRes == nPrp * nLoc == nPrp * nDat \
                        or nRes == nLoc == nDat == nPrp
        if len(order) == 2 : 
            self.complet = nRes == nDat * nPrp == nDat * nLoc \
                        or nRes == nLoc * nPrp == nLoc * nDat \
                        or nRes == nPrp * nLoc == nPrp * nDat \
                        or nRes == nLoc == nDat == nPrp
        if len(order) == 1 : 
            self.complet = nRes == nLoc == nDat == nPrp
        
        if self.complet: self.setResult.majIndex(nRes, nPrp, nDat, nLoc, order)
        if self.setResult   != None: self.setResult.  analyse()
        if self.setLocation != None: self.setLocation.analyse()
        if self.setDatation != None: self.setDatation.analyse()
        self.typeObs()

    def xlist(self):
        xList = {}
        if self.setLocation != None: 
            xList[&#39;loc&#39;]    = self.setLocation.to_numpy()
            xList[&#39;locstr&#39;] = self.setLocation.to_numpy(func = LocationValue.json)
            xList[&#39;loclon&#39;] = self.setLocation.to_numpy(func = LocationValue.vPointX)
            xList[&#39;loclat&#39;] = self.setLocation.to_numpy(func = LocationValue.vPointY)
            xList[&#39;locnam&#39;] = self.setLocation.to_numpy(func = LocationValue.vName)
            xList[&#39;locran&#39;] = np.arange(len(xList[&#39;loc&#39;]))
        if self.setDatation != None: 
            xList[&#39;dat&#39;]    = self.setDatation.to_numpy()
            xList[&#39;datstr&#39;] = self.setDatation.to_numpy(func = DatationValue.json)
            xList[&#39;datnam&#39;] = self.setDatation.to_numpy(func = DatationValue.vName)
            xList[&#39;datran&#39;] = np.arange(len(xList[&#39;dat&#39;]))
        if self.setProperty != None: 
            xList[&#39;prp&#39;]    = self.setProperty.to_numpy()
            xList[&#39;prpstr&#39;] = self.setProperty.to_numpy(func = PropertyValue.json)
            xList[&#39;prpnam&#39;] = self.setProperty.to_numpy(func = PropertyValue.vName)
            xList[&#39;prpran&#39;] = np.arange(len(xList[&#39;prp&#39;]))
        if self.setResult  != None: 
            xList[&#39;res&#39;]    = self.setResult.to_numpy()
            xList[&#39;resval&#39;] = self.setResult.to_numpy(func = ResultValue.to_float)
            xList[&#39;resstr&#39;] = self.setResult.to_numpy(func = ResultValue.json)
            xList[&#39;resnam&#39;] = self.setResult.to_numpy(func = ResultValue.vName)
            xList[&#39;resran&#39;] = np.arange(len(xList[&#39;res&#39;]))
        return xList

    def xAttrs(self) :
        attrs = ES.xattrs
        attrs[&#39;info&#39;]   = json.loads(&#34;{&#34; + self.jsonInfo(True, False, True, False) + &#34;}&#34;)[&#34;information&#34;]
        return attrs

    def axeCoor(self, nValAxe) :
        for ax in self.setResult.axes :
            if ax &gt; 100 : return ax
            if ax &lt; 9 and nValAxe == ax : return ax
            elif ax &gt; 9 and (nValAxe == ax//10 or nValAxe == ax%10) : return ax
        return None
    
    def xCoord(self, xList, attrs, dataArray, complet, numeric) :
        #nax = {&#39;dat&#39; : 0, &#39;loc&#39; : 1, &#39;prp&#39; : 2}
        coord = {}
        for key, val in xList.items() :
            if key[:3] != &#39;res&#39; and self.axeCoor(ES.nax[key[:3]]) != None \
                and (complet or (not complet and len(key) == 3)):
                coord[key] = ([ES.axes[self.axeCoor(ES.nax[key[:3]])]], val, attrs[key[:3]])
                if key == &#39;loclon&#39; : coord[key] = (coord[key][0], val, attrs[&#39;lon&#39;])
                if key == &#39;loclat&#39; : coord[key] = (coord[key][0], val, attrs[&#39;lat&#39;])
        for ax in self.setResult.axes :
            if ax &gt; 9 :
                coord[ES.axes[ax]] = ([ES.axes[ax]], np.arange(len(xList[ES.axes[ax%10]])))
        if numeric :
            if &#39;loc&#39; in coord.keys() : coord[&#39;loc&#39;] = (coord[&#39;loc&#39;][0], xList[&#39;locran&#39;], coord[&#39;loc&#39;][2])
            if &#39;dat&#39; in coord.keys() : coord[&#39;dat&#39;] = (coord[&#39;dat&#39;][0], xList[&#39;datstr&#39;], coord[&#39;dat&#39;][2])
            if &#39;prp&#39; in coord.keys() : coord[&#39;prp&#39;] = (coord[&#39;prp&#39;][0], xList[&#39;prpran&#39;], coord[&#39;prp&#39;][2])
        return coord
    

    def to_xarray(self, dataArray = True, complet = False, info = False, numeric = False):
        self.sort()
        xList = self.xlist()
        attrs = self.xAttrs()
        coord = self.xCoord(xList, attrs, dataArray, complet, numeric=False)
        dims = [ES.axes[ax] for ax in self.setResult.axes]
        if numeric  : xres = xList[&#39;resval&#39;]
        else        : xres = xList[&#39;res&#39;]
        if dataArray and info :
            return xr.DataArray(xres, coord, dims, attrs=attrs[&#39;info&#39;])
        elif dataArray and not info :
            return xr.DataArray(xres, coord, dims)
        return None
    
    def plot(self):    


        if self.setResult.dim == 1 :
            obx = self.to_xarray().set_index(timeloc=&#34;point&#34;, prop = &#34;prpstr&#34;)
            if &#39;dat&#39; in obx.coords: obx.sortby([&#39;dat&#39;]).plot.line(x = &#39;dat&#39;)
            else : obx.plot.line(x=&#39;point&#39;)
            obg = self.to_geoDataFrame()
            for i in range(len(self.setProperty)): obg.plot(obg.columns.array[i], legend=True)
        elif self.setResult.dim == 2:
            obx = self.to_xarray().set_index(prop = &#34;prpstr&#34;)
            obx.sortby([&#34;dat&#34;, &#34;loc&#34;, &#34;prp&#34;]).plot(x=&#34;dat&#34;, y=&#34;loc&#34;, col=&#34;prp&#34;, col_wrap=2, size=5)
            obx.sortby([&#34;dat&#34;, &#34;loc&#34;, &#34;prp&#34;]).plot.line(    x=&#34;dat&#34;, col=&#34;prp&#34;, col_wrap=2, size=5)
            obg = self.to_geoDataFrame()
            for i in range(len(self.setProperty)): obg.plot(obg.columns.array[i], legend=True)
            plt.legend(obx.coords[&#39;loc&#39;].to_index().to_list())
        plt.show()    

    def to_dataFrame(self):
        if self.setResult.dim &gt; 0 : return self.to_xarray(False).to_dataframe()
        else : return None

    &#39;&#39;&#39;def majType(self, order = &#39;dlp&#39;):
        [nprp, ndat, nloc, nEch, nRes] = self.nValueObs()
        nPrp = max(1, nprp)
        nDat = max(1, ndat)
        nLoc = max(1, nloc)
        self.complet = (len(order) == 3 and  nRes == nLoc * nDat * nPrp) \
                        or nRes == nDat * nPrp == nDat * nLoc \
                        or nRes == nLoc * nPrp == nLoc * nDat \
                        or nRes == nPrp * nLoc == nPrp * nDat \
                        or nRes == nLoc == nDat == nPrp \
                        or nRes == 1
        if self.complet: self.setResult.majIndex(nRes, nPrp, nDat, nLoc, order)
        if self.setResult   != None: self.setResult.analyse()
        if self.setLocation != None: self.setLocation.analyse()
        if self.setDatation != None: self.setDatation.analyse()
        self.typeObs()&#39;&#39;&#39;

    &#39;&#39;&#39;def to_geoDataFrame(self):
        if self.setResult.dim &gt; 0 : return gp.GeoDataFrame(self.to_dataFrame())
        else : return None&#39;&#39;&#39;

    def choropleth(self):
        if self.setResult.dim == 1 or self.setResult.dim // 10 == 1:
            m = folium.Map(location=self.setLocation.valueList[0].coorInv, zoom_start=6)
            folium.PolyLine(
                list(self.setLocation.valueList[i].coorInv for i in range(len(self.setLocation.valueList)))
            ).add_to(m)
            folium.Choropleth(
                geo_data=self.jsonFeature,
                name=&#34;test choropleth&#34;,
                data=self.to_dataFrame(),
                key_on=&#34;feature.id&#34;,
                #columns=[&#34;point&#34;, json.loads(self.setProperty[0].json(False))[ES.prp_propType]],
                columns=[&#34;point&#34;, json.loads(self.setProperty[0].json(ES.mOption))[ES.prp_propType]],
                fill_color=&#34;BuGn&#34;,
                fill_opacity=0.7,
                line_opacity=0.2,
                legend_name=&#34;test choropleth&#34;
            ).add_to(m)
            folium.LayerControl().add_to(m)
            return m
        return None

    &#39;&#39;&#39;def typeObs(self):
        [nPrp, nDat, nLoc, nEch, nRes] = self.nValueObs()
        self.score = min(max(min(nEch, 2) * 100 + min(nLoc,2) * 10 + min(nDat, 2), -1), 223);
        if self.setResult != None and (self.setResult.error or self.setResult.getMaxIndex() == -1 or \
           self.setResult.nd &gt; nDat or self.setResult.nl &gt; nLoc or self.setResult.np &gt; nPrp):
               self.mAtt[ES.type] = &#34;obserror&#34;
               return
        self.mAtt[ES.type] = ES.obsCat[self.score]
        if self.score == 222 and self.setResult.dim == 1:       self.mAtt[ES.type] = &#34;obsPath&#34;
        if self.score == 222 and self.setResult.dim == 2:       self.mAtt[ES.type] = &#34;obsAreaSequence&#34;&#39;&#39;&#39;

    &#39;&#39;&#39;def tri2(self) :
        tup = [((self.setDatation.valueList[i], i)) for i in range(self.setDatation.nValue)]
        self.setDatation.iSort = [ v[1] for v in sorted(tup, key=lambda l: l[0])]
        tup = [((self.setLocation.valueList[i], i)) for i in range(self.setLocation.nValue)]
        self.setLocation.iSort = [ v[1] for v in sorted(tup, key=lambda l: l[0])]
        tup = [((self.setProperty.valueList[i], i)) for i in range(self.setProperty.nValue)]
        self.setProperty.iSort = [ v[1] for v in sorted(tup, key=lambda l: l[0])]
        tup = [(([self.setDatation.iSort[self.setResult.valueList[i].ind[0]],
                  self.setLocation.iSort[self.setResult.valueList[i].ind[1]],
                  self.setProperty.iSort[self.setResult.valueList[i].ind[2]]]
                  , i)) for i in range(self.setResult.nValue)]
        #tup = [((self.setResult.valueList[i], i)) for i in range(self.setResult.nValue)]
        self.setResult.iSort = [ v[1] for v in sorted(tup, key=lambda l: l[0])]&#39;&#39;&#39;

    &#39;&#39;&#39;def nValueObs(self):
        nPrp = nDat = nLoc = nEch = nRes = 0
        if self.setResult   != None: nEch = self.setResult.nEch
        if self.setResult   != None: nRes = self.setResult.nValue
        if self.setLocation != None: nLoc = self.setLocation.nValue
        if self.setDatation != None: nDat = self.setDatation.nValue
        if self.setProperty != None: nPrp = self.setProperty.nValue
        return [nPrp, nDat, nLoc, nEch, nRes]&#39;&#39;&#39;
    
    &#39;&#39;&#39;for ax in self.axes :
            coord[ES.axes[ax]]=([ES.axes[ax]], )
        
        
        [nPrp, nDat, nLoc, nRes] = self.nValueObs()
        nDatLoc = max(nDat, nLoc)
        coord = {}
        coord[&#34;prp&#34;]            = ([&#34;prp&#34;], xList[&#39;prp&#39;]        , attrs[&#39;prp&#39;])
        coord[&#34;prpstr&#34;]         = ([&#34;prp&#34;], xList[&#39;prpstr&#39;]     , attrs[&#39;prp&#39;])
        if self.setResult.dim == 1: 
            coord[&#34;datloc&#34;]      = ([&#34;datloc&#34;], np.arange(nDatLoc))
            coord[&#34;point&#34;]      = ([&#34;datloc&#34;], np.arange(nDatLoc))
            #coord[&#34;datloc&#34;]     = ([&#34;datloc&#34;], xList[&#39;datlocstr&#39;], attrs[&#39;datloc&#39;])
            if nLoc == nDatLoc:
                coord[&#34;lon&#34;]    = ([&#34;datloc&#34;], xList[&#39;lon&#39;]     , attrs[&#39;lon&#39;])
                coord[&#34;lat&#34;]    = ([&#34;datloc&#34;], xList[&#39;lat&#39;]     , attrs[&#39;lat&#39;])
                coord[&#34;geometry&#34;] = ([&#34;datloc&#34;], xList[&#39;loc&#39;]   , attrs[&#39;loc&#39;])
                coord[&#34;locstr&#34;] = ([&#34;datloc&#34;], xList[&#39;locstr&#39;]  , attrs[&#39;loc&#39;])
            if nDat == nDatLoc:
                coord[&#34;dat&#34;]    = ([&#34;datloc&#34;], xList[&#39;dat&#39;]     , attrs[&#39;dat&#39;])
                #coord[&#34;datstr&#34;] = ([&#34;datloc&#34;], xList[&#39;datstr&#39;]  , attrs[&#39;dat&#39;])
            if dataArray:
                ranking = np.arange(nDatLoc * nPrp).reshape(nDatLoc, nPrp)
                coord[&#34;ranking&#34;] = ([&#34;datloc&#34;, &#34;prp&#34;]           , ranking)
            else :
                ranking = np.arange(nDatLoc)
                coord[&#34;ranking&#34;] = ([&#34;datloc&#34;], ranking)
                coord.pop(&#39;prp&#39;)
                coord.pop(&#39;prpstr&#39;)
        else : 
            coord[&#34;geometry&#34;]   = ([&#34;loc&#34;], xList[&#39;loc&#39;]    , attrs[&#39;loc&#39;])
            coord[&#34;loc&#34;]        = ([&#34;loc&#34;], np.arange(nLoc))
            coord[&#34;lon&#34;]        = ([&#34;loc&#34;], xList[&#39;lon&#39;]    , attrs[&#39;lon&#39;])
            coord[&#34;lat&#34;]        = ([&#34;loc&#34;], xList[&#39;lat&#39;]    , attrs[&#39;lat&#39;])
            coord[&#34;locstr&#34;]     = ([&#34;loc&#34;], xList[&#39;locstr&#39;] , attrs[&#39;loc&#39;])
            coord[&#34;dat&#34;]        = ([&#34;dat&#34;], xList[&#39;dat&#39;]    , attrs[&#39;dat&#39;])
            coord[&#34;datstr&#34;]     = ([&#34;dat&#34;], xList[&#39;datstr&#39;] , attrs[&#39;dat&#39;])
            if dataArray :
                ranking = np.arange(nDat * nLoc * nPrp).reshape(nDat, nLoc, nPrp)
                coord[&#34;ranking&#34;] = ([&#34;dat&#34;, &#34;loc&#34;, &#34;prp&#34;]   , ranking)
            else :
                ranking = np.arange(nDat * nLoc).reshape(nDat, nLoc)
                coord[&#34;ranking&#34;] = ([&#34;dat&#34;, &#34;loc&#34;], ranking)
                coord.pop(&#39;prp&#39;)
                coord.pop(&#39;prpstr&#39;)
        return coord&#39;&#39;&#39;

    &#39;&#39;&#39;
        [nPrp, nDat, nLoc, nRes] = self.nValueObs()
        xList[&#39;loc&#39;] = xList[&#39;dat&#39;] = xList[&#39;prp&#39;] = xList[&#39;res&#39;] = list()
        xList[&#39;res&#39;]    = self.setResult.valueList
        if self.setLocation != None: xList[&#39;loc&#39;] = [val.shap for val in self.setLocation.valueList]
        #if self.setLocation != None: xList[&#39;loc&#39;] = self.setLocation.vListPoint
        #if self.setDatation != None: xList[&#39;dat&#39;] = [val.instant for val in self.setDatation.valueList]
        if self.setDatation != None: xList[&#39;dat&#39;] = self.setDatation.vListInstant
        if self.setProperty != None: xList[&#39;prp&#39;] = self.setProperty.valueList
        xList[&#39;lon&#39;]    = [geo.centroid.x for geo in xList[&#39;loc&#39;]]
        xList[&#39;lat&#39;]    = [geo.centroid.y for geo in xList[&#39;loc&#39;]]
        #xList[&#39;lon&#39;]    = [geo[0] for geo in xList[&#39;loc&#39;]]
        #xList[&#39;lat&#39;]    = [geo[1] for geo in xList[&#39;loc&#39;]]
        xList[&#39;locstr&#39;] = [json.dumps(geo.shap.__geo_interface__) for geo in self.setLocation.valueList]
        #xList[&#39;datstr&#39;] = [dat.isoformat() for dat in xList[&#39;dat&#39;]]
        #if xList[&#39;datstr&#39;] == []: xList[&#39;datlocstr&#39;] = xList[&#39;locstr&#39;]
        #elif xList[&#39;locstr&#39;] == []: xList[&#39;datlocstr&#39;] = xList[&#39;datstr&#39;]
        #else : xList[&#39;datlocstr&#39;] = [xList[&#39;datstr&#39;][min(i, nDat-1)] + xList[&#39;locstr&#39;][min(i, nLoc-1)] 
                                     #for i in range(max(nDat, nLoc))]
        xList[&#39;prpstr&#39;] = [pr.json(ES.mOption) for pr in xList[&#39;prp&#39;]]
        xList[&#39;resvalue&#39;] = [res.value for res in xList[&#39;res&#39;]]
        &#39;&#39;&#39;    

    &#39;&#39;&#39;def xCoord2(self, xList, attrs, dataArray) :
        [nPrp, nDat, nLoc, nRes] = self.nValueObs()
        nDatLoc = max(nDat, nLoc)
        coord = {}
        coord[&#34;prp&#34;]            = ([&#34;prp&#34;], xList[&#39;prp&#39;]        , attrs[&#39;prp&#39;])
        coord[&#34;prpstr&#34;]         = ([&#34;prp&#34;], xList[&#39;prpstr&#39;]     , attrs[&#39;prp&#39;])
        if self.setResult.dim == 1: 
            coord[&#34;datloc&#34;]      = ([&#34;datloc&#34;], np.arange(nDatLoc))
            coord[&#34;point&#34;]      = ([&#34;datloc&#34;], np.arange(nDatLoc))
            #coord[&#34;datloc&#34;]     = ([&#34;datloc&#34;], xList[&#39;datlocstr&#39;], attrs[&#39;datloc&#39;])
            if nLoc == nDatLoc:
                coord[&#34;lon&#34;]    = ([&#34;datloc&#34;], xList[&#39;lon&#39;]     , attrs[&#39;lon&#39;])
                coord[&#34;lat&#34;]    = ([&#34;datloc&#34;], xList[&#39;lat&#39;]     , attrs[&#39;lat&#39;])
                coord[&#34;geometry&#34;] = ([&#34;datloc&#34;], xList[&#39;loc&#39;]   , attrs[&#39;loc&#39;])
                coord[&#34;locstr&#34;] = ([&#34;datloc&#34;], xList[&#39;locstr&#39;]  , attrs[&#39;loc&#39;])
            if nDat == nDatLoc:
                coord[&#34;dat&#34;]    = ([&#34;datloc&#34;], xList[&#39;dat&#39;]     , attrs[&#39;dat&#39;])
                #coord[&#34;datstr&#34;] = ([&#34;datloc&#34;], xList[&#39;datstr&#39;]  , attrs[&#39;dat&#39;])
            if dataArray:
                ranking = np.arange(nDatLoc * nPrp).reshape(nDatLoc, nPrp)
                coord[&#34;ranking&#34;] = ([&#34;datloc&#34;, &#34;prp&#34;]           , ranking)
            else :
                ranking = np.arange(nDatLoc)
                coord[&#34;ranking&#34;] = ([&#34;datloc&#34;], ranking)
                coord.pop(&#39;prp&#39;)
                coord.pop(&#39;prpstr&#39;)
        else : 
            coord[&#34;geometry&#34;]   = ([&#34;loc&#34;], xList[&#39;loc&#39;]    , attrs[&#39;loc&#39;])
            coord[&#34;loc&#34;]        = ([&#34;loc&#34;], np.arange(nLoc))
            coord[&#34;lon&#34;]        = ([&#34;loc&#34;], xList[&#39;lon&#39;]    , attrs[&#39;lon&#39;])
            coord[&#34;lat&#34;]        = ([&#34;loc&#34;], xList[&#39;lat&#39;]    , attrs[&#39;lat&#39;])
            coord[&#34;locstr&#34;]     = ([&#34;loc&#34;], xList[&#39;locstr&#39;] , attrs[&#39;loc&#39;])
            coord[&#34;dat&#34;]        = ([&#34;dat&#34;], xList[&#39;dat&#39;]    , attrs[&#39;dat&#39;])
            coord[&#34;datstr&#34;]     = ([&#34;dat&#34;], xList[&#39;datstr&#39;] , attrs[&#39;dat&#39;])
            if dataArray :
                ranking = np.arange(nDat * nLoc * nPrp).reshape(nDat, nLoc, nPrp)
                coord[&#34;ranking&#34;] = ([&#34;dat&#34;, &#34;loc&#34;, &#34;prp&#34;]   , ranking)
            else :
                ranking = np.arange(nDat * nLoc).reshape(nDat, nLoc)
                coord[&#34;ranking&#34;] = ([&#34;dat&#34;, &#34;loc&#34;], ranking)
                coord.pop(&#39;prp&#39;)
                coord.pop(&#39;prpstr&#39;)
        return coord&#39;&#39;&#39;
    
        
        
    &#39;&#39;&#39;if self.setResult == None: return None
        xList = self.xlist()
        [nPrp, nDat, nLoc, nRes] = self.nValueObs()
        nDatLoc = max(nDat, nLoc)
        attrs = self.xAttrs()
        coord = self.xCoord(xList, attrs, dataArray)
        
        if self.setResult.dim == 1 :
            value = np.array(xList[&#39;resvalue&#39;]).reshape(nDatLoc, nPrp)
            if dataArray :
                return xr.DataArray(data=value, dims=[&#34;datloc&#34;, &#34;prp&#34;],
                                    coords=coord, attrs=attrs[&#39;info&#39;])
            else :
                datas ={}
                for i in range(nPrp):
                    prp = json.loads(xList[&#39;prp&#39;][i].json(ES.mOption))
                    datas[prp[ES.prp_propType]] = ([&#34;datloc&#34;], value[:,i])
                return xr.Dataset(data_vars=datas, coords=coord, attrs=attrs[&#39;info&#39;])
        elif self.setResult.dim == 2 :
            value = np.array(xList[&#39;resvalue&#39;]).reshape(nDat, nLoc, nPrp)
            if dataArray :
                return xr.DataArray(data=value, dims=[&#34;dat&#34;, &#34;loc&#34;, &#34;prp&#34;],
                                    coords=coord, attrs=attrs[&#39;info&#39;])    
            else :
                datas ={}
                for i in range(nPrp):
                    prp = json.loads(xList[&#39;prp&#39;][i].json(ES.mOption))
                    datas[prp[ES.prp_propType]] = ([&#34;dat&#34;,&#34;loc&#34;], value[:,:,i], 
                                                  {&#34;units&#34;: prp[&#34;unit&#34;]})
                return xr.Dataset(data_vars = datas, coords =  coord, attrs =  attrs[&#39;info&#39;])
        else : return None&#39;&#39;&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>ESElement.ESObject</li>
<li>ESElement.ESElement</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="ES.ESObservation.Observation.sortAlign"><code class="name flex">
<span>def <span class="ident">sortAlign</span></span>(<span>npInd, list1, ind1, ind2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def sortAlign(npInd, list1, ind1, ind2):
    return [npInd[list(npInd[:,ind1]).index(i),:][ind2]  for i in list1]    </code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="ES.ESObservation.Observation.bounds"><code class="name">var <span class="ident">bounds</span></code></dt>
<dd>
<div class="desc"><p>boîte englobante de l'Observation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def bounds(self):
    &#39;&#39;&#39;boîte englobante de l&#39;Observation&#39;&#39;&#39;
    if self.setLocation : return shape(self).bounds
    else : return None</code></pre>
</details>
</dd>
<dt id="ES.ESObservation.Observation.complet"><code class="name">var <span class="ident">complet</span></code></dt>
<dd>
<div class="desc"><p>True si le nombre de résultats est cohérent avec le nombre d'objets de type Location, Datation et Property.</p></div>
</dd>
<dt id="ES.ESObservation.Observation.jsonFeature"><code class="name">var <span class="ident">jsonFeature</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def jsonFeature(self):
    if self.setLocation : 
        geo = self.__geo_interface__
        if geo[&#39;type&#39;] == &#34;MultiPolygon&#34;: typ = &#34;Polygon&#34;
        else : typ = &#34;Point&#34;
        lis = list(dict(((&#34;type&#34;, typ), (&#34;coordinates&#34;, geo[&#39;coordinates&#39;][i]))) for i in range(len(geo[&#39;coordinates&#39;])))
        fea = list(dict(((&#34;type&#34;,&#34;Feature&#34;), (&#34;id&#34;, i), (&#34;geometry&#34;, lis[i]))) for i in range(len(geo[&#39;coordinates&#39;])))
        return json.dumps(dict(((&#34;type&#34;,&#34;FeatureCollection&#34;), (&#34;features&#34;,fea))))            
    else: return &#39;&#39;  </code></pre>
</details>
</dd>
<dt id="ES.ESObservation.Observation.score"><code class="name">var <span class="ident">score</span></code></dt>
<dd>
<div class="desc"><p>Nature de l'assemblage des différents composants. Par exemple 122
indique qu'il s'agit d'une mesure unique sur un trajet</p></div>
</dd>
<dt id="ES.ESObservation.Observation.setDatation"><code class="name">var <span class="ident">setDatation</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def setDatation(self):  return self.element(ES.dat_classES)</code></pre>
</details>
</dd>
<dt id="ES.ESObservation.Observation.setLocation"><code class="name">var <span class="ident">setLocation</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def setLocation(self):  return self.element(ES.loc_classES)</code></pre>
</details>
</dd>
<dt id="ES.ESObservation.Observation.setProperty"><code class="name">var <span class="ident">setProperty</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def setProperty(self):  return self.element(ES.prp_classES)</code></pre>
</details>
</dd>
<dt id="ES.ESObservation.Observation.setResult"><code class="name">var <span class="ident">setResult</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def setResult(self):  return self.element(ES.res_classES)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="ES.ESObservation.Observation.addAttributes"><code class="name flex">
<span>def <span class="ident">addAttributes</span></span>(<span>self, js)</span>
</code></dt>
<dd>
<div class="desc"><p>Ajout d'attributs à une Observation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addAttributes(self, js):
    &#39;&#39;&#39;Ajout d&#39;attributs à une Observation&#39;&#39;&#39;
    if type(js) != dict: return
    for k, v in js.items():
        if isESAtt(ES.obs_classES, k) or isUserAtt(k): self.mAtt[k] = v
        if k == ES.parameter: 
            try:  self.parameter = json.dumps(v)
            except:  self.parameter = &#34;null&#34;</code></pre>
</details>
</dd>
<dt id="ES.ESObservation.Observation.addListResultValue"><code class="name flex">
<span>def <span class="ident">addListResultValue</span></span>(<span>self, listEsValue)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addListResultValue(self, listEsValue):
    if type(listEsValue) != list : return
    if self.element(ES.res_valueType) == None: resSet = ESSetResult(self)
    else: resSet = self.setResult
    for val in listEsValue : resSet.addValue(ResultValue, ResultValue(val))
        #self.addResultValue(ResultValue(val) )</code></pre>
</details>
</dd>
<dt id="ES.ESObservation.Observation.addListValue"><code class="name flex">
<span>def <span class="ident">addListValue</span></span>(<span>self, ValueClass, listEsValue)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addListValue(self, ValueClass, listEsValue):
    for val in listEsValue : self.addValue(ValueClass(val) )</code></pre>
</details>
</dd>
<dt id="ES.ESObservation.Observation.addListValueObservation"><code class="name flex">
<span>def <span class="ident">addListValueObservation</span></span>(<span>self, val, idat, iloc, iprp)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addListValueObservation(self, val, idat, iloc, iprp):
    for i in range(len(val)) :
        self.addResultValue(ResultValue(val[i], [idat[i], iloc[i], iprp[i]]))</code></pre>
</details>
</dd>
<dt id="ES.ESObservation.Observation.addResultValue"><code class="name flex">
<span>def <span class="ident">addResultValue</span></span>(<span>self, esValue)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addResultValue(self, esValue):
    return self.element(ES.res_valueType).addValue(ResultValue, esValue)</code></pre>
</details>
</dd>
<dt id="ES.ESObservation.Observation.addValue"><code class="name flex">
<span>def <span class="ident">addValue</span></span>(<span>self, esValue)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addValue(self, esValue):
    if type(esValue)== PropertyValue:
        if self.element(ES.prp_valueType) == None: esSet = ESSetProperty(self)
        return self.element(ES.prp_valueType).addValue(PropertyValue, esValue)
    elif type(esValue)== LocationValue:
        if self.element(ES.loc_valueType) == None: esSet = ESSetLocation(self)
        return self.element(ES.loc_valueType).addValue(LocationValue, esValue)
    elif type(esValue)== DatationValue:
        if self.element(ES.dat_valueType) == None: esSet = ESSetDatation(self)
        return self.element(ES.dat_valueType).addValue(DatationValue, esValue)
    else: return 0</code></pre>
</details>
</dd>
<dt id="ES.ESObservation.Observation.addValueObservation"><code class="name flex">
<span>def <span class="ident">addValueObservation</span></span>(<span>self, val, idat, iloc, iprp)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addValueObservation(self, val, idat, iloc, iprp):
    if self.element(ES.res_valueType) == None: resSet = ESSetResult(self)
    return self.addResultValue(ResultValue(val, [idat, iloc, iprp]))</code></pre>
</details>
</dd>
<dt id="ES.ESObservation.Observation.addValueSensor"><code class="name flex">
<span>def <span class="ident">addValueSensor</span></span>(<span>self, val, tim, coor, nprp)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addValueSensor(self, val, tim, coor, nprp):
    return self.addValueObservation(val, self.addValue(tim), self.addValue(coor), nprp)</code></pre>
</details>
</dd>
<dt id="ES.ESObservation.Observation.axeCoor"><code class="name flex">
<span>def <span class="ident">axeCoor</span></span>(<span>self, nValAxe)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def axeCoor(self, nValAxe) :
    for ax in self.setResult.axes :
        if ax &gt; 100 : return ax
        if ax &lt; 9 and nValAxe == ax : return ax
        elif ax &gt; 9 and (nValAxe == ax//10 or nValAxe == ax%10) : return ax
    return None</code></pre>
</details>
</dd>
<dt id="ES.ESObservation.Observation.choropleth"><code class="name flex">
<span>def <span class="ident">choropleth</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def choropleth(self):
    if self.setResult.dim == 1 or self.setResult.dim // 10 == 1:
        m = folium.Map(location=self.setLocation.valueList[0].coorInv, zoom_start=6)
        folium.PolyLine(
            list(self.setLocation.valueList[i].coorInv for i in range(len(self.setLocation.valueList)))
        ).add_to(m)
        folium.Choropleth(
            geo_data=self.jsonFeature,
            name=&#34;test choropleth&#34;,
            data=self.to_dataFrame(),
            key_on=&#34;feature.id&#34;,
            #columns=[&#34;point&#34;, json.loads(self.setProperty[0].json(False))[ES.prp_propType]],
            columns=[&#34;point&#34;, json.loads(self.setProperty[0].json(ES.mOption))[ES.prp_propType]],
            fill_color=&#34;BuGn&#34;,
            fill_opacity=0.7,
            line_opacity=0.2,
            legend_name=&#34;test choropleth&#34;
        ).add_to(m)
        folium.LayerControl().add_to(m)
        return m
    return None</code></pre>
</details>
</dd>
<dt id="ES.ESObservation.Observation.extend"><code class="name flex">
<span>def <span class="ident">extend</span></span>(<span>self, obs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extend(self, obs):
    for p in obs.pComposant :
        if self.element(p.classES) == None : self.addComposant(p)
    self.majType()    </code></pre>
</details>
</dd>
<dt id="ES.ESObservation.Observation.from_bytes"><code class="name flex">
<span>def <span class="ident">from_bytes</span></span>(<span>self, byt)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_bytes(self, byt):
    code_ob = (byt[0] &amp; 0b11100000) &gt;&gt; 5
    self.mAtt[ES.obs_reference] = byt[0] &amp; 0b00011111
    if code_ob != ES.codeb[self.classES]: return
    idx = 1
    while idx &lt; byt.__len__() :
        code_el = (byt[idx] &amp; 0b11100000) &gt;&gt; 5
        #forma =  byt[idx] &amp; 0b00001111
        if   code_el == 1: es = ESSetLocation(self)
        elif code_el == 2: es = ESSetDatation(self)
        elif code_el == 3: es = ESSetProperty(self)
        elif code_el &lt; 6:
            es = ESSetResult(self)
            if code_el == 5: 
                propList = [self.setProperty.valueList[i].pType 
                        for i in range(self.setProperty.nValue)]
            else :
                n = es.from_bytes(byt[idx:], [])
                es.majIndex(es.nValue, self.setProperty.nValue, 
                        self.setDatation.nValue, self.setLocation.nValue)
                propList = [self.setProperty.valueList[es.valueList[i].ind[2]].pType
                        for i in range(es.nValue)]
                es.__init__()
        else: return
        if code_el &lt; 4 : 
            idx += es.from_bytes(byt[idx:])
        else :
            idx += es.from_bytes(byt[idx:], propList)</code></pre>
</details>
</dd>
<dt id="ES.ESObservation.Observation.iloc"><code class="name flex">
<span>def <span class="ident">iloc</span></span>(<span>self, idat, iloc, iprp)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def iloc(self, idat, iloc, iprp):
    if not self.complet : return dict()
    dic = dict()
    if self.setDatation != None and idat &lt; self.setDatation.nValue: 
        dic[ES.dat_classES] = self.setDatation.valueList[idat].json(self.option)
    if self.setLocation != None and iloc &lt; self.setLocation.nValue: 
        dic[ES.loc_classES] = self.setLocation.valueList[iloc].json(self.option)
    if self.setProperty != None and iprp &lt; self.setProperty.nValue: 
        dic[ES.prp_classES] = self.setProperty.valueList[iprp].json(self.option)
    if self.setResult != None : 
        for i in range(self.setResult.nValue) : 
            if self.setResult.valueList[i].ind == [idat, iloc, iprp] : 
                dic[ES.res_classES] = self.setResult.valueList[i].json(self.option)
    return dic</code></pre>
</details>
</dd>
<dt id="ES.ESObservation.Observation.json"><code class="name flex">
<span>def <span class="ident">json</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Export de l'Observation sou s la forme dune chaîne de caractères au format JSON</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def json(self): 
    &#39;&#39;&#39; Export de l&#39;Observation sou s la forme dune chaîne de caractères au format JSON&#39;&#39;&#39;
    if self.option[&#34;json_elt_type&#34;]: option_type = 1
    else: option_type = 0
    js =&#34;&#34;
    &#39;&#39;&#39;variable interne retournée&#39;&#39;&#39;
    if self.option[&#34;json_obs_val&#34;]: js = &#34;{&#34;
    js += &#39;&#34;&#39; + ES.type +&#39;&#34;:&#34;&#39; + ES.obs_classES +&#39;&#34;,&#39;
    if self.mAtt[ES.obs_id] != &#34;null&#34;: js += &#39;&#34;&#39; + ES.obs_id + &#39;&#34;:&#34;&#39; + self.mAtt[ES.obs_id] + &#39;&#34;,&#39;
    if self.option[&#34;json_obs_attrib&#34;]: js += &#39;&#34;&#39; + ES.obs_attributes + &#39;&#34;:{&#39;
    js += self.jsonAtt(option_type)
    for cp in self.pComposant:
        js += cp.json(self.option)
        if js[-1] != &#39;,&#39;: js += &#34;,&#34;
    if self.option[&#34;json_param&#34;] and self.parameter != &#34;null&#34;: 
        js += &#39;&#34;&#39; + ES.parameter +&#39;&#34;:&#39; + self.parameter + &#39;,&#39;
    jsInfo = self.jsonInfo(self.option[&#34;json_info_type&#34;], self.option[&#34;json_info_nval&#34;],
                        self.option[&#34;json_info_box&#34;], self.option[&#34;json_info_autre&#34;])
    if jsInfo != &#34;&#34; : js +=  jsInfo + &#39;,&#39;
    if js[-1] == &#39;,&#39;: js = js[:-1]
    if self.option[&#34;json_obs_attrib&#34;]: js += &#34;}&#34;
    if self.option[&#34;json_obs_val&#34;]:    js += &#34;}&#34;
    return js</code></pre>
</details>
</dd>
<dt id="ES.ESObservation.Observation.jsonInfo"><code class="name flex">
<span>def <span class="ident">jsonInfo</span></span>(<span>self, types, nval, box, autre)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def jsonInfo(self, types, nval, box, autre):
    dcinf = dict()
    if types :  self.jsonInfoTypes(dcinf)
    if nval :   self.jsonInfoNval(dcinf)
    if box :    self.jsonInfoBox(dcinf)
    if autre:   self.jsonInfoAutre(dcinf)
    ldel =[]
    for k,v in dcinf.items() :
        if type(v) == str and (v == &#34;null&#34; or v ==&#39;&#39;)   : ldel.append(k)
        if type(v) == list and v == ES.nullCoor         : ldel.append(k) 
    for k in ldel :         del dcinf[k]
    if len(dcinf) == 0 :    return &#34;&#34;
    else :                  return &#39;&#34;&#39; +ES.information + &#39;&#34;:&#39; + json.dumps(dcinf)</code></pre>
</details>
</dd>
<dt id="ES.ESObservation.Observation.jsonInfoAutre"><code class="name flex">
<span>def <span class="ident">jsonInfoAutre</span></span>(<span>self, dcinf)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def jsonInfoAutre(self, dcinf):
    dcinf[ES.obs_complet] = self.complet
    dcinf[ES.obs_score] = self.score
    if self.setResult != None :
        dcinf[ES.res_mRate] = self.setResult.measureRate
        dcinf[ES.res_dim] = self.setResult.dim
        dcinf[ES.res_axes] = self.setResult.axes</code></pre>
</details>
</dd>
<dt id="ES.ESObservation.Observation.jsonInfoBox"><code class="name flex">
<span>def <span class="ident">jsonInfoBox</span></span>(<span>self, dcinf)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def jsonInfoBox(self, dcinf):
    if self.setLocation != None :
        dcinf[ES.loc_boxMin] = self.setLocation.boxMin.point
        dcinf[ES.loc_boxMax] = self.setLocation.boxMax.point
    if self.setDatation != None :
        dcinf[ES.dat_boxMin] = self.setDatation.boxMin.json(ES.mOption)
        dcinf[ES.dat_boxMax] = self.setDatation.boxMax.json(ES.mOption)</code></pre>
</details>
</dd>
<dt id="ES.ESObservation.Observation.jsonInfoNval"><code class="name flex">
<span>def <span class="ident">jsonInfoNval</span></span>(<span>self, dcinf)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def jsonInfoNval(self, dcinf):
    if self.setLocation != None : dcinf[ES.json_nval_loc] = self.setLocation.nValue
    if self.setDatation != None : dcinf[ES.json_nval_dat] = self.setDatation.nValue
    if self.setProperty != None : dcinf[ES.json_nval_prp] = self.setProperty.nValue
    if self.setResult   != None : dcinf[ES.json_nval_res] = self.setResult.nValue</code></pre>
</details>
</dd>
<dt id="ES.ESObservation.Observation.jsonInfoTypes"><code class="name flex">
<span>def <span class="ident">jsonInfoTypes</span></span>(<span>self, dcinf)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def jsonInfoTypes(self, dcinf):
    dcinf[ES.json_type_obs] = self.mAtt[ES.type]
    if self.setLocation != None :
        if self.setLocation.nValue &gt; 1 : 
            dcinf[ES.json_type_loc] = ES.multi + self.setLocation.mAtt[ES.type]
        else :
            dcinf[ES.json_type_loc] = self.setLocation.mAtt[ES.type]
    if self.setDatation != None :
        if self.setDatation.nValue &gt; 1 : 
            dcinf[ES.json_type_dat] = ES.multi + self.setDatation.mAtt[ES.type]
        else :
            dcinf[ES.json_type_dat] = self.setDatation.mAtt[ES.type]
    if self.setProperty != None :
        if self.setProperty.nValue &gt; 1 : 
            dcinf[ES.json_type_prp] = ES.multi + self.setProperty.mAtt[ES.type]
        else :
            dcinf[ES.json_type_prp] = self.setProperty.mAtt[ES.type]
    if self.setResult != None :
        if self.setResult.nValue &gt; 1 : 
            dcinf[ES.json_type_res] = ES.multi + self.setResult.mAtt[ES.type]
        else :
            dcinf[ES.json_type_res] = self.setResult.mAtt[ES.type]</code></pre>
</details>
</dd>
<dt id="ES.ESObservation.Observation.majList"><code class="name flex">
<span>def <span class="ident">majList</span></span>(<span>self, ValueClass, listVal, info='name')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def majList(self, ValueClass, listVal, info = &#39;name&#39;):
    if ValueClass == DatationValue and self.setDatation != None : 
        if info == &#39;name&#39;: self.setDatation.majListName(listVal)
        else : self.setDatation.majListValue(ValueClass, listVal, info == &#39;base&#39;)
    elif ValueClass == LocationValue and self.setLocation != None : 
        if info == &#39;name&#39;: self.setLocation.majListName(listVal)
        else : self.setLocation.majListValue(ValueClass, listVal, info == &#39;base&#39;)
    elif ValueClass == PropertyValue and self.setProperty != None : 
        if info == &#39;name&#39;: self.setProperty.majListName(listVal)</code></pre>
</details>
</dd>
<dt id="ES.ESObservation.Observation.majType"><code class="name flex">
<span>def <span class="ident">majType</span></span>(<span>self, order='dlp')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def majType(self, order = &#39;dlp&#39;):
    [nprp, ndat, nloc, nRes] = self.nValueObs()
    nPrp = max(1, nprp)
    nDat = max(1, ndat)
    nLoc = max(1, nloc)
    if len(order) == 3 : 
        self.complet = nRes == nLoc * nDat * nPrp \
                    or nRes == nDat * nPrp == nDat * nLoc \
                    or nRes == nLoc * nPrp == nLoc * nDat \
                    or nRes == nPrp * nLoc == nPrp * nDat \
                    or nRes == nLoc == nDat == nPrp
    if len(order) == 2 : 
        self.complet = nRes == nDat * nPrp == nDat * nLoc \
                    or nRes == nLoc * nPrp == nLoc * nDat \
                    or nRes == nPrp * nLoc == nPrp * nDat \
                    or nRes == nLoc == nDat == nPrp
    if len(order) == 1 : 
        self.complet = nRes == nLoc == nDat == nPrp
    
    if self.complet: self.setResult.majIndex(nRes, nPrp, nDat, nLoc, order)
    if self.setResult   != None: self.setResult.  analyse()
    if self.setLocation != None: self.setLocation.analyse()
    if self.setDatation != None: self.setDatation.analyse()
    self.typeObs()</code></pre>
</details>
</dd>
<dt id="ES.ESObservation.Observation.nValueObs"><code class="name flex">
<span>def <span class="ident">nValueObs</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nValueObs(self):
    nPrp = nDat = nLoc = nRes = 0
    if self.setResult   != None: nRes = self.setResult.nValue
    if self.setLocation != None: nLoc = self.setLocation.nValue
    if self.setDatation != None: nDat = self.setDatation.nValue
    if self.setProperty != None: nPrp = self.setProperty.nValue
    return [nPrp, nDat, nLoc, nRes]</code></pre>
</details>
</dd>
<dt id="ES.ESObservation.Observation.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self):    


    if self.setResult.dim == 1 :
        obx = self.to_xarray().set_index(timeloc=&#34;point&#34;, prop = &#34;prpstr&#34;)
        if &#39;dat&#39; in obx.coords: obx.sortby([&#39;dat&#39;]).plot.line(x = &#39;dat&#39;)
        else : obx.plot.line(x=&#39;point&#39;)
        obg = self.to_geoDataFrame()
        for i in range(len(self.setProperty)): obg.plot(obg.columns.array[i], legend=True)
    elif self.setResult.dim == 2:
        obx = self.to_xarray().set_index(prop = &#34;prpstr&#34;)
        obx.sortby([&#34;dat&#34;, &#34;loc&#34;, &#34;prp&#34;]).plot(x=&#34;dat&#34;, y=&#34;loc&#34;, col=&#34;prp&#34;, col_wrap=2, size=5)
        obx.sortby([&#34;dat&#34;, &#34;loc&#34;, &#34;prp&#34;]).plot.line(    x=&#34;dat&#34;, col=&#34;prp&#34;, col_wrap=2, size=5)
        obg = self.to_geoDataFrame()
        for i in range(len(self.setProperty)): obg.plot(obg.columns.array[i], legend=True)
        plt.legend(obx.coords[&#39;loc&#39;].to_index().to_list())
    plt.show()    </code></pre>
</details>
</dd>
<dt id="ES.ESObservation.Observation.sort"><code class="name flex">
<span>def <span class="ident">sort</span></span>(<span>self, order=[0, 1, 2], cross=True, sort=[[], [], []])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sort(self, order = [0, 1, 2], cross = True, sort = [[], [], []]):  
    if self.setResult == None or not self.setResult.isIndex() : return
    tr = tri = [[], [], []]
    for i in range(3) : tri[i] = self.sortSet(i, sort[i], False)
    npInd = np.array(self.setResult.vListIndex)
    if cross:
        for ax in self.setResult.axes : 
            if ax &gt; 100 : 
                tri[order[1]] = self.sortAlign(npInd, tri[order[0]], order[0], order[1])
                tri[order[2]] = self.sortAlign(npInd, tri[order[0]], order[0], order[2])
            elif ax &gt; 9 :
                (first, second) = (ax//10, ax%10)
                if order.index(second) &lt; order.index(first) : (first, second) = (second, first)
                tri[second] = self.sortAlign(npInd, tri[first], first, second)
    for i in range(3) : tr[i] = self.sortSet(i, tri[i])
    for resVal in self.setResult.valueList :
        for i in range(3) : resVal.ind[i] = tr[i].index(resVal.ind[i])
    resTri = self.setResult.sort()</code></pre>
</details>
</dd>
<dt id="ES.ESObservation.Observation.sortSet"><code class="name flex">
<span>def <span class="ident">sortSet</span></span>(<span>self, ax, tri=[], update=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sortSet(self, ax, tri = [], update = True):
    if ax == 0 and self.setDatation != None : return self.setDatation.sort(tri, update)
    if ax == 1 and self.setLocation != None : return self.setLocation.sort(tri, update)
    if ax == 2 and self.setProperty != None : return self.setProperty.sort(tri, update)
    return [0]</code></pre>
</details>
</dd>
<dt id="ES.ESObservation.Observation.to_bytes"><code class="name flex">
<span>def <span class="ident">to_bytes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_bytes(self):
    byt = bytes()
    code_el = ES.codeb[self.classES] 
    byt += struct.pack(&#39;&lt;B&#39;, (code_el &lt;&lt; 5) | self.mAtt[ES.obs_reference])
    if self.setProperty != None: 
        byt += self.setProperty.to_bytes(self.option[&#34;json_prp_name&#34;])
    if self.setLocation != None: 
        byt += self.setLocation.to_bytes(self.option[&#34;json_loc_name&#34;])
    if self.setDatation != None: 
        byt += self.setDatation.to_bytes(self.option[&#34;json_dat_name&#34;])
    if self.setResult != None: 
        propList = [self.setProperty.valueList[i].pType 
                    for i in range(self.setProperty.nValue)]
        byt += self.setResult.to_bytes(False, self.option[&#34;json_res_index&#34;], 
                                       self.option[&#34;bytes_res_format&#34;], propList)
    return byt</code></pre>
</details>
</dd>
<dt id="ES.ESObservation.Observation.to_dataFrame"><code class="name flex">
<span>def <span class="ident">to_dataFrame</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dataFrame(self):
    if self.setResult.dim &gt; 0 : return self.to_xarray(False).to_dataframe()
    else : return None</code></pre>
</details>
</dd>
<dt id="ES.ESObservation.Observation.to_xarray"><code class="name flex">
<span>def <span class="ident">to_xarray</span></span>(<span>self, dataArray=True, complet=False, info=False, numeric=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_xarray(self, dataArray = True, complet = False, info = False, numeric = False):
    self.sort()
    xList = self.xlist()
    attrs = self.xAttrs()
    coord = self.xCoord(xList, attrs, dataArray, complet, numeric=False)
    dims = [ES.axes[ax] for ax in self.setResult.axes]
    if numeric  : xres = xList[&#39;resval&#39;]
    else        : xres = xList[&#39;res&#39;]
    if dataArray and info :
        return xr.DataArray(xres, coord, dims, attrs=attrs[&#39;info&#39;])
    elif dataArray and not info :
        return xr.DataArray(xres, coord, dims)
    return None</code></pre>
</details>
</dd>
<dt id="ES.ESObservation.Observation.typeObs"><code class="name flex">
<span>def <span class="ident">typeObs</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def typeObs(self):
    [nPrp, nDat, nLoc, nRes] = self.nValueObs()
    self.score = min(max(min(nPrp, 2) * 100 + min(nLoc,2) * 10 + min(nDat, 2), -1), 229);
    if self.setResult == None or (self.setResult.error or self.setResult.getMaxIndex() == -1 or \
       self.setResult.nInd[0] &gt; nDat or self.setResult.nInd[1] &gt; nLoc or self.setResult.nInd[2] &gt; nPrp):
           self.mAtt[ES.type] = &#34;obserror&#34;
           return
    if self.score == 22  and self.setResult.dim == 2:       self.score = 23
    if self.score == 122 and self.setResult.dim == 2:       self.score = 123
    if self.score == 202 and self.setResult.dim == 2:       self.score = 203
    if self.score == 212 and self.setResult.dim == 2:       self.score = 213
    if self.score == 220 and self.setResult.dim == 2:       self.score = 223
    if self.score == 221 and self.setResult.dim == 2:       self.score = 224
    if self.score == 222 and self.setResult.dim == 3:       self.score = 228
    if self.score == 222 and self.setResult.dim == 2 and 2 in self.setResult.axes:  self.score = 225
    if self.score == 222 and self.setResult.dim == 2 and 1 in self.setResult.axes:  self.score = 226
    if self.score == 222 and self.setResult.dim == 2 and 0 in self.setResult.axes:  self.score = 227
    self.mAtt[ES.type] = ES.obsCat[self.score]</code></pre>
</details>
</dd>
<dt id="ES.ESObservation.Observation.xAttrs"><code class="name flex">
<span>def <span class="ident">xAttrs</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def xAttrs(self) :
    attrs = ES.xattrs
    attrs[&#39;info&#39;]   = json.loads(&#34;{&#34; + self.jsonInfo(True, False, True, False) + &#34;}&#34;)[&#34;information&#34;]
    return attrs</code></pre>
</details>
</dd>
<dt id="ES.ESObservation.Observation.xCoord"><code class="name flex">
<span>def <span class="ident">xCoord</span></span>(<span>self, xList, attrs, dataArray, complet, numeric)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def xCoord(self, xList, attrs, dataArray, complet, numeric) :
    #nax = {&#39;dat&#39; : 0, &#39;loc&#39; : 1, &#39;prp&#39; : 2}
    coord = {}
    for key, val in xList.items() :
        if key[:3] != &#39;res&#39; and self.axeCoor(ES.nax[key[:3]]) != None \
            and (complet or (not complet and len(key) == 3)):
            coord[key] = ([ES.axes[self.axeCoor(ES.nax[key[:3]])]], val, attrs[key[:3]])
            if key == &#39;loclon&#39; : coord[key] = (coord[key][0], val, attrs[&#39;lon&#39;])
            if key == &#39;loclat&#39; : coord[key] = (coord[key][0], val, attrs[&#39;lat&#39;])
    for ax in self.setResult.axes :
        if ax &gt; 9 :
            coord[ES.axes[ax]] = ([ES.axes[ax]], np.arange(len(xList[ES.axes[ax%10]])))
    if numeric :
        if &#39;loc&#39; in coord.keys() : coord[&#39;loc&#39;] = (coord[&#39;loc&#39;][0], xList[&#39;locran&#39;], coord[&#39;loc&#39;][2])
        if &#39;dat&#39; in coord.keys() : coord[&#39;dat&#39;] = (coord[&#39;dat&#39;][0], xList[&#39;datstr&#39;], coord[&#39;dat&#39;][2])
        if &#39;prp&#39; in coord.keys() : coord[&#39;prp&#39;] = (coord[&#39;prp&#39;][0], xList[&#39;prpran&#39;], coord[&#39;prp&#39;][2])
    return coord</code></pre>
</details>
</dd>
<dt id="ES.ESObservation.Observation.xlist"><code class="name flex">
<span>def <span class="ident">xlist</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def xlist(self):
    xList = {}
    if self.setLocation != None: 
        xList[&#39;loc&#39;]    = self.setLocation.to_numpy()
        xList[&#39;locstr&#39;] = self.setLocation.to_numpy(func = LocationValue.json)
        xList[&#39;loclon&#39;] = self.setLocation.to_numpy(func = LocationValue.vPointX)
        xList[&#39;loclat&#39;] = self.setLocation.to_numpy(func = LocationValue.vPointY)
        xList[&#39;locnam&#39;] = self.setLocation.to_numpy(func = LocationValue.vName)
        xList[&#39;locran&#39;] = np.arange(len(xList[&#39;loc&#39;]))
    if self.setDatation != None: 
        xList[&#39;dat&#39;]    = self.setDatation.to_numpy()
        xList[&#39;datstr&#39;] = self.setDatation.to_numpy(func = DatationValue.json)
        xList[&#39;datnam&#39;] = self.setDatation.to_numpy(func = DatationValue.vName)
        xList[&#39;datran&#39;] = np.arange(len(xList[&#39;dat&#39;]))
    if self.setProperty != None: 
        xList[&#39;prp&#39;]    = self.setProperty.to_numpy()
        xList[&#39;prpstr&#39;] = self.setProperty.to_numpy(func = PropertyValue.json)
        xList[&#39;prpnam&#39;] = self.setProperty.to_numpy(func = PropertyValue.vName)
        xList[&#39;prpran&#39;] = np.arange(len(xList[&#39;prp&#39;]))
    if self.setResult  != None: 
        xList[&#39;res&#39;]    = self.setResult.to_numpy()
        xList[&#39;resval&#39;] = self.setResult.to_numpy(func = ResultValue.to_float)
        xList[&#39;resstr&#39;] = self.setResult.to_numpy(func = ResultValue.json)
        xList[&#39;resnam&#39;] = self.setResult.to_numpy(func = ResultValue.vName)
        xList[&#39;resran&#39;] = np.arange(len(xList[&#39;res&#39;]))
    return xList</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ES" href="index.html">ES</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="ES.ESObservation.Observation" href="#ES.ESObservation.Observation">Observation</a></code></h4>
<ul class="">
<li><code><a title="ES.ESObservation.Observation.addAttributes" href="#ES.ESObservation.Observation.addAttributes">addAttributes</a></code></li>
<li><code><a title="ES.ESObservation.Observation.addListResultValue" href="#ES.ESObservation.Observation.addListResultValue">addListResultValue</a></code></li>
<li><code><a title="ES.ESObservation.Observation.addListValue" href="#ES.ESObservation.Observation.addListValue">addListValue</a></code></li>
<li><code><a title="ES.ESObservation.Observation.addListValueObservation" href="#ES.ESObservation.Observation.addListValueObservation">addListValueObservation</a></code></li>
<li><code><a title="ES.ESObservation.Observation.addResultValue" href="#ES.ESObservation.Observation.addResultValue">addResultValue</a></code></li>
<li><code><a title="ES.ESObservation.Observation.addValue" href="#ES.ESObservation.Observation.addValue">addValue</a></code></li>
<li><code><a title="ES.ESObservation.Observation.addValueObservation" href="#ES.ESObservation.Observation.addValueObservation">addValueObservation</a></code></li>
<li><code><a title="ES.ESObservation.Observation.addValueSensor" href="#ES.ESObservation.Observation.addValueSensor">addValueSensor</a></code></li>
<li><code><a title="ES.ESObservation.Observation.axeCoor" href="#ES.ESObservation.Observation.axeCoor">axeCoor</a></code></li>
<li><code><a title="ES.ESObservation.Observation.bounds" href="#ES.ESObservation.Observation.bounds">bounds</a></code></li>
<li><code><a title="ES.ESObservation.Observation.choropleth" href="#ES.ESObservation.Observation.choropleth">choropleth</a></code></li>
<li><code><a title="ES.ESObservation.Observation.complet" href="#ES.ESObservation.Observation.complet">complet</a></code></li>
<li><code><a title="ES.ESObservation.Observation.extend" href="#ES.ESObservation.Observation.extend">extend</a></code></li>
<li><code><a title="ES.ESObservation.Observation.from_bytes" href="#ES.ESObservation.Observation.from_bytes">from_bytes</a></code></li>
<li><code><a title="ES.ESObservation.Observation.iloc" href="#ES.ESObservation.Observation.iloc">iloc</a></code></li>
<li><code><a title="ES.ESObservation.Observation.json" href="#ES.ESObservation.Observation.json">json</a></code></li>
<li><code><a title="ES.ESObservation.Observation.jsonFeature" href="#ES.ESObservation.Observation.jsonFeature">jsonFeature</a></code></li>
<li><code><a title="ES.ESObservation.Observation.jsonInfo" href="#ES.ESObservation.Observation.jsonInfo">jsonInfo</a></code></li>
<li><code><a title="ES.ESObservation.Observation.jsonInfoAutre" href="#ES.ESObservation.Observation.jsonInfoAutre">jsonInfoAutre</a></code></li>
<li><code><a title="ES.ESObservation.Observation.jsonInfoBox" href="#ES.ESObservation.Observation.jsonInfoBox">jsonInfoBox</a></code></li>
<li><code><a title="ES.ESObservation.Observation.jsonInfoNval" href="#ES.ESObservation.Observation.jsonInfoNval">jsonInfoNval</a></code></li>
<li><code><a title="ES.ESObservation.Observation.jsonInfoTypes" href="#ES.ESObservation.Observation.jsonInfoTypes">jsonInfoTypes</a></code></li>
<li><code><a title="ES.ESObservation.Observation.majList" href="#ES.ESObservation.Observation.majList">majList</a></code></li>
<li><code><a title="ES.ESObservation.Observation.majType" href="#ES.ESObservation.Observation.majType">majType</a></code></li>
<li><code><a title="ES.ESObservation.Observation.nValueObs" href="#ES.ESObservation.Observation.nValueObs">nValueObs</a></code></li>
<li><code><a title="ES.ESObservation.Observation.plot" href="#ES.ESObservation.Observation.plot">plot</a></code></li>
<li><code><a title="ES.ESObservation.Observation.score" href="#ES.ESObservation.Observation.score">score</a></code></li>
<li><code><a title="ES.ESObservation.Observation.setDatation" href="#ES.ESObservation.Observation.setDatation">setDatation</a></code></li>
<li><code><a title="ES.ESObservation.Observation.setLocation" href="#ES.ESObservation.Observation.setLocation">setLocation</a></code></li>
<li><code><a title="ES.ESObservation.Observation.setProperty" href="#ES.ESObservation.Observation.setProperty">setProperty</a></code></li>
<li><code><a title="ES.ESObservation.Observation.setResult" href="#ES.ESObservation.Observation.setResult">setResult</a></code></li>
<li><code><a title="ES.ESObservation.Observation.sort" href="#ES.ESObservation.Observation.sort">sort</a></code></li>
<li><code><a title="ES.ESObservation.Observation.sortAlign" href="#ES.ESObservation.Observation.sortAlign">sortAlign</a></code></li>
<li><code><a title="ES.ESObservation.Observation.sortSet" href="#ES.ESObservation.Observation.sortSet">sortSet</a></code></li>
<li><code><a title="ES.ESObservation.Observation.to_bytes" href="#ES.ESObservation.Observation.to_bytes">to_bytes</a></code></li>
<li><code><a title="ES.ESObservation.Observation.to_dataFrame" href="#ES.ESObservation.Observation.to_dataFrame">to_dataFrame</a></code></li>
<li><code><a title="ES.ESObservation.Observation.to_xarray" href="#ES.ESObservation.Observation.to_xarray">to_xarray</a></code></li>
<li><code><a title="ES.ESObservation.Observation.typeObs" href="#ES.ESObservation.Observation.typeObs">typeObs</a></code></li>
<li><code><a title="ES.ESObservation.Observation.xAttrs" href="#ES.ESObservation.Observation.xAttrs">xAttrs</a></code></li>
<li><code><a title="ES.ESObservation.Observation.xCoord" href="#ES.ESObservation.Observation.xCoord">xCoord</a></code></li>
<li><code><a title="ES.ESObservation.Observation.xlist" href="#ES.ESObservation.Observation.xlist">xlist</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>