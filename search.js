window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "NTV.json_ntv", "modulename": "NTV.json_ntv", "kind": "module", "doc": "<p><strong><em>JSON-NTV Package</em></strong></p>\n\n<p>Created on Fri Dec 24 15:21:14 2021</p>\n\n<p>@author: philippe@loco-labs.io</p>\n\n<p>This package contains the following classes:</p>\n\n<ul>\n<li><p><code>NTV.json_ntv.namespace</code> :</p>\n\n<ul>\n<li><code>NTV.json_ntv.namespace.Namespace</code></li>\n<li><code>NTV.json_ntv.namespace.NtvType</code></li>\n</ul></li>\n<li><p><code>NTV.json_ntv.ntv</code> :</p>\n\n<ul>\n<li><code>NTV.json_ntv.ntv.NtvSingle</code></li>\n<li><code>NTV.json_ntv.ntv.NtvList</code></li>\n<li><code>NTV.json_ntv.ntv.Ntv</code> (abstract class)</li>\n</ul></li>\n<li><p><code>NTV.json_ntv.ntv_util</code> :</p>\n\n<ul>\n<li><code>NTV.json_ntv.ntv.NtvTree</code></li>\n<li><code>NTV.json_ntv.ntv.NtvJsonEncoder</code></li>\n<li><code>NTV.json_ntv.ntv.NtvError</code></li>\n<li><code>NTV.json_ntv.ntv.NtvConnector</code> (abstract class)    </li>\n</ul></li>\n<li><p><code>NTV.json_ntv.ntv_connector</code> :</p>\n\n<ul>\n<li><code>NTV.json_ntv.ntv_connector.DataFrameConnec</code></li>\n<li><code>NTV.json_ntv.ntv_connector.SeriesConnec</code></li>\n<li><code>NTV.json_ntv.ntv_connector.IlistConnec</code></li>\n<li><code>NTV.json_ntv.ntv_connector.NfieldConnec</code></li>\n<li><code>NTV.json_ntv.ntv_connector.SfieldConnec</code></li>\n<li><code>NTV.json_ntv.ntv_connector.NdatasetConnec</code></li>\n<li><code>NTV.json_ntv.ntv_connector.SdatasetConnec</code></li>\n<li><code>NTV.json_ntv.ntv_connector.IindexConnec</code></li>\n<li><code>NTV.json_ntv.ntv_connector.MermaidConnec</code></li>\n<li><code>NTV.json_ntv.ntv_connector.CborConnec</code></li>\n<li><code>NTV.json_ntv.ntv_connector.ShapelyConnec</code> </li>\n</ul></li>\n</ul>\n\n<h1 id=\"0-abstract\">0 - Abstract</h1>\n\n<p>Today, the semantic level of shared data remains low. It is very often limited \nto the type of data defined in the exchange formats (strings for CSV formats; \nnumbers, strings, arrays and objects for JSON formats).</p>\n\n<p>The proposed consists of adding a type and a name to the data exchanged (see also the \n<a href=\"https://github.com/loco-philippe/NTV/blob/main/documentation/JSON-NTV-standard.pdf\">JSON-NTV specification</a>).</p>\n\n<p>With this evolution any data, whatever its semantic level, can be identified, \nshared and interpreted in a consistent way.\nThe implementation of a type with a nested structure facilitates its appropriation.\nFinally, compatibility with existing JSON structures allows progressive deployment.</p>\n\n<h1 id=\"1-ntv-structure\">1 - NTV structure</h1>\n\n<p>The constructed entities (called NTV for <em>named typed value</em>) are therefore a triplet\n with one mandatory element (the value in JSON format) and two optional elements (name, type).\n&gt;</p>\n\n<blockquote>\n  <p><em>For example, the location of Paris can be represented by:</em></p>\n  \n  <ul>\n  <li><em>a name: \"Paris\",</em></li>\n  <li><em>a type: the coordinates of a point according to the GeoJSON format,</em></li>\n  <li><em>a value: [ 2.3522, 48.8566]</em></li>\n  </ul>\n</blockquote>\n\n<p>The easiest way to add this information is to use a JSON-object with a single member\n using the syntax <a href=\"https://github.com/glenkleidon/JSON-ND\">JSON-ND</a> for the first \n term of the member and the JSON-value for the second term of the member.\n&gt;</p>\n\n<blockquote>\n  <p><em>For the example above, the JSON representation is:</em> <br />\n  <em><code>{ \"paris:point\" : [2.3522, 48.8566] }</code></em></p>\n</blockquote>\n\n<p>With this approach, three NTV entities are defined:</p>\n\n<ul>\n<li>a primitive entity which is not composed of any other entity (NTV-single),</li>\n<li>two structured entities: an unordered collection of NTV entities (NTV-set) and\nan ordered sequence of NTV entities (NTV-list).</li>\n</ul>\n\n<p>as well as two JSON formats:</p>\n\n<ul>\n<li>simple format when the name and the type are not present (this is the usual case of CSV data),</li>\n<li>named format when the name or type is present (see example above for an NTV-single\nentity and below for a structured entity).\n&gt;</li>\n</ul>\n\n<blockquote>\n  <p><em>Example of an entity composed of two other entities:</em></p>\n  \n  <ul>\n  <li><em><code>{ \"cities::point\": [[2.3522, 48.8566], [4.8357, 45.7640]] }</code> for an NTV-list entity</em></li>\n  <li><em><code>{ \"cities::point\": { \"paris\":[2.3522, 48.8566], \"lyon\":[4.8357, 45.7640] } }</code> \n  for an NTV-set entity</em></li>\n  </ul>\n  \n  <p><em>Note: This syntax can also be used for CSV file headers</em></p>\n</blockquote>\n\n<p>The type incorporates a notion of <code>namespaces</code> that can be nested.</p>\n\n<blockquote>\n  <p><em>For example, the type: \"ns1.ns2.type\" means that:</em></p>\n  \n  <ul>\n  <li><em>ns1. is a namespace defined in the global namespace,</em></li>\n  <li><em>ns2. is a namespace defined in the ns1 namespace.,</em></li>\n  <li><em>type is defined in the ns2 namespace.</em>    </li>\n  </ul>\n</blockquote>\n\n<p>This structuring of type makes it possible to reference any type of data that has\n a JSON representation and to consolidate all the shared data structures within the\n same tree of types.</p>\n"}, {"fullname": "NTV.json_ntv.namespace", "modulename": "NTV.json_ntv.namespace", "kind": "module", "doc": "<p>Created on Jan 20 2023</p>\n\n<p>@author: Philippe@loco-labs.io</p>\n\n<p>The <code>namespace</code> module is part of the <code>NTV.json_ntv</code> package (<a href=\"https://github.com/loco-philippe/NTV/blob/main/documentation/JSON-NTV-standard.pdf\">specification document</a>).</p>\n\n<p>It contains the <code>Namespace</code> and the <code>NtvType</code> classes and the <code>str_type</code> method for NTV entities.</p>\n\n<h1 id=\"0-presentation\">0 - Presentation</h1>\n\n<p>The NTVtype is defined by a name and a Namespace. The name is unique in the Namespace</p>\n\n<p>A Namespace is represented by a string followed by a point.\nNamespaces may be nested (the global Namespace is represented by an empty string).</p>\n\n<p>The Namespace representations are added to the value of an NTVtype to have an absolute\nrepresentation of an NTVtype (long_name).</p>\n\n<p><em>Example for an absolute representation of an NTVtype defined in two nested Namespace :</em>\n<em>\u201cns1.ns2.type\u201d</em>\n<em>where:</em></p>\n\n<ul>\n<li><em>ns1. is a Namespace defined in the global Namespace,</em></li>\n<li><em>ns2. is a Namespace defined in the ns1. Namespace,</em></li>\n<li><em>type is a NTVtype defined in the ns2. Namespace</em></li>\n</ul>\n\n<h1 id=\"1-global-namespace\">1 - Global Namespace</h1>\n\n<p>The structure of types by namespace makes it possible to have types corresponding\nto recognized standards at the global level.\nGeneric types can also be defined (calculation of the exact type when decoding the value).</p>\n\n<p>The global namespace can include the following structures:</p>\n\n<h2 id=\"11-simple-json-rfc8259\">1.1 - Simple (JSON RFC8259)</h2>\n\n<table>\n<thead>\n<tr>\n  <th>type (generic type)</th>\n  <th>value example</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td>boolean (json)</td>\n  <td>true</td>\n</tr>\n<tr>\n  <td>null (json)</td>\n  <td>null</td>\n</tr>\n<tr>\n  <td>number (json)</td>\n  <td>45.2</td>\n</tr>\n<tr>\n  <td>string (json)</td>\n  <td>\"string\"</td>\n</tr>\n<tr>\n  <td>array  (json)</td>\n  <td>[1, 2, 3]</td>\n</tr>\n<tr>\n  <td>object (json)</td>\n  <td>{ \"str\": \"test\", \"bool\": true}</td>\n</tr>\n</tbody>\n</table>\n\n<h2 id=\"12-datation-iso8601-and-posix\">1.2 - Datation (ISO8601 and Posix)</h2>\n\n<table>\n<thead>\n<tr>\n  <th>type (generic type)</th>\n  <th>value example</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td>year</td>\n  <td>1998</td>\n</tr>\n<tr>\n  <td>month</td>\n  <td>10</td>\n</tr>\n<tr>\n  <td>day</td>\n  <td>21</td>\n</tr>\n<tr>\n  <td>week</td>\n  <td>38</td>\n</tr>\n<tr>\n  <td>hour</td>\n  <td>20</td>\n</tr>\n<tr>\n  <td>minute</td>\n  <td>18</td>\n</tr>\n<tr>\n  <td>second</td>\n  <td>54</td>\n</tr>\n<tr>\n  <td>timeposix (dat)</td>\n  <td>123456.78</td>\n</tr>\n<tr>\n  <td>date (dat)</td>\n  <td>\u201c2022-01-28\u201d</td>\n</tr>\n<tr>\n  <td>time (dat)</td>\n  <td>\u201cT18:23:54\u201d,  \u201c18:23\u201d, \u201cT18\u201d</td>\n</tr>\n<tr>\n  <td>datetime (dat)</td>\n  <td>\u201c2022-01-28T18-23-54Z\u201d, \u201c2022-01-28T18-23-54+0400\u201d</td>\n</tr>\n<tr>\n  <td>timearray (dat)</td>\n  <td>[date1, date2]</td>\n</tr>\n<tr>\n  <td>timeslot (dat)</td>\n  <td>[timearray1, timearray2]</td>\n</tr>\n</tbody>\n</table>\n\n<h2 id=\"13-duration-iso8601-and-posix\">1.3 - Duration (ISO8601 and Posix)</h2>\n\n<table>\n<thead>\n<tr>\n  <th>type (generic type)</th>\n  <th>value example</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td>timeinterval (dur)</td>\n  <td>\"2007-03-01T13:00:00Z/2008-05-11T15:30:00Z\"</td>\n</tr>\n<tr>\n  <td>durationiso (dur)</td>\n  <td>\"P0002-10- 15T10:30:20\"</td>\n</tr>\n<tr>\n  <td>durposix (dur)</td>\n  <td>123456.78</td>\n</tr>\n</tbody>\n</table>\n\n<h2 id=\"14-location-rfc7946-and-open-location-code\">1.4 - Location (RFC7946 and Open Location Code):</h2>\n\n<table>\n<thead>\n<tr>\n  <th>type (generic type)</th>\n  <th>value example</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td>point (loc)</td>\n  <td>[ 5.12, 45.256 ] (lon, lat)</td>\n</tr>\n<tr>\n  <td>line (loc)</td>\n  <td>[ point1, point2, point3 ]</td>\n</tr>\n<tr>\n  <td>ring</td>\n  <td>[ point1, point2, point3 ]</td>\n</tr>\n<tr>\n  <td>multiline</td>\n  <td>[ line1, line2, line3]</td>\n</tr>\n<tr>\n  <td>polygon (loc)</td>\n  <td>[ ring1, ring2, ring3]</td>\n</tr>\n<tr>\n  <td>multipolygon (loc)</td>\n  <td>[ poly1, poly2, poly3 ]</td>\n</tr>\n<tr>\n  <td>bbox (loc)</td>\n  <td>[ -10.0, -10.0, 10.0, 10.0 ]</td>\n</tr>\n<tr>\n  <td>geojson (loc)</td>\n  <td>{\u201ctype\u201d: \u201cpoint\u201d, \u201ccoordinates\u201d: [40.0, 0.0] }</td>\n</tr>\n<tr>\n  <td>codeolc (loc)</td>\n  <td>\u201c8FW4V75V+8F6\u201d</td>\n</tr>\n</tbody>\n</table>\n\n<h2 id=\"15-tabular-data\">1.5 - Tabular data</h2>\n\n<table>\n<thead>\n<tr>\n  <th>NTVtype</th>\n  <th>NTVvalue</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td>row</td>\n  <td>JSON-array of JSON-NTV</td>\n</tr>\n<tr>\n  <td>field</td>\n  <td>JSON-array of NTVvalue (following JSON-TAB format)</td>\n</tr>\n<tr>\n  <td>table</td>\n  <td>JSON-array of JSON-NTV fields with the same length</td>\n</tr>\n</tbody>\n</table>\n\n<h2 id=\"16-normalized-strings\">1.6 - Normalized strings</h2>\n\n<p>The type could be <code>uri</code>, cf exemples :</p>\n\n<ul>\n<li>\"https://www.ietf.org/rfc/rfc3986.txt\"</li>\n<li>\"https://gallica.bnf.fr/ark:/12148/bpt6k107371t\"</li>\n<li>\"urn:uuid:f81d4fae-7dec-11d0-a765-00a0c91e6bf6\"</li>\n<li>\"ni:///sha-256;UyaQV-Ev4rdLoHyJJWCi11OHfrYv9E1aGQAlMO2X_-Q\"</li>\n<li>\"geo:13.4125,103.86673\" <em>(RFC5870)</em></li>\n<li>\"info:eu-repo/dai/nl/12345\"</li>\n<li>\"mailto:John.Doe@example.com\"</li>\n<li>\"news:comp.infosystems.www.servers.unix\"</li>\n<li>\"urn:oasis:names:specification:docbook:dtd:xml:4.1.2\"</li>\n</ul>\n\n<h2 id=\"17-namespaces\">1.7 - Namespaces</h2>\n\n<p>Namespaces could also be defined to reference for example:</p>\n\n<ul>\n<li>geopolitical entities: ISO3166-1 country code (for example \"fr.\" for France)</li>\n<li>data catalogs, for example:</li>\n</ul>\n\n<table>\n<thead>\n<tr>\n  <th>NTVtype</th>\n  <th>example JSON-NTV</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td>schemaorg.</td>\n  <td><div>{ \u201c:schemaorg.propertyID\u201d: \u201cNO2\u201d }</div><div>{ \u201c:schemaorg.unitText\u201d:\u201d\u00b5g/m3\u201d}</div></td>\n</tr>\n<tr>\n  <td>darwincore.</td>\n  <td>{ \u201c:darwincore.acceptedNameUsage\u201d: \u201cTamias minimus\u201d }</td>\n</tr>\n</tbody>\n</table>\n\n<h2 id=\"18-identifiers\">1.8 - Identifiers</h2>\n\n<p>For example :</p>\n\n<table>\n<thead>\n<tr>\n  <th>type</th>\n  <th>definition</th>\n  <th>exemple</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td>fr.uic</td>\n  <td>code UIC station</td>\n  <td>8757449</td>\n</tr>\n<tr>\n  <td>fr.iata</td>\n  <td>code IATA airport</td>\n  <td>CDG</td>\n</tr>\n</tbody>\n</table>\n\n<h1 id=\"2-example-of-using-a-fr-namespace\">2 - Example of using a <code>fr.</code> namespace</h1>\n\n<p>This namespace is dedicated to datasets associated with the France geopolitical namespace\n(see also the <a href=\"https://github.com/loco-philippe/NTV/blob/main/documentation/JSON-NTV-namespace-fr.pdf\">presentation document</a>).</p>\n\n<p>A namespace defines:</p>\n\n<ul>\n<li>identifiers used to access additional data,</li>\n<li>namespaces associated with catalogs or data sets,</li>\n<li>structured entities used to facilitate the use of data</li>\n</ul>\n\n<h2 id=\"21-identifiers\">2.1 - Identifiers</h2>\n\n<p>They could correspond to identifiers used in many referenced datasets\n(via a data schema or a data model).</p>\n\n<p>For example :</p>\n\n<table>\n<thead>\n<tr>\n  <th>type</th>\n  <th>definition</th>\n  <th>example</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td>fr.dep</td>\n  <td>code d\u00e9partement</td>\n  <td>60</td>\n</tr>\n<tr>\n  <td>fr.cp</td>\n  <td>code postal</td>\n  <td>76450</td>\n</tr>\n<tr>\n  <td>fr.naf</td>\n  <td>code NAF</td>\n  <td>23</td>\n</tr>\n<tr>\n  <td>fr.siren</td>\n  <td>code SIREN enterprise</td>\n  <td>418447363</td>\n</tr>\n<tr>\n  <td>fr.fantoir</td>\n  <td>code FANTOIR voie</td>\n  <td>4500023086F</td>\n</tr>\n<tr>\n  <td>fr.uai</td>\n  <td>code UAI \u00e9tablissement</td>\n  <td>0951099D</td>\n</tr>\n<tr>\n  <td>fr.aca</td>\n  <td>code acad\u00e9mies</td>\n  <td>22</td>\n</tr>\n<tr>\n  <td>fr.finessej</td>\n  <td>code FINESS entit\u00e9 juridique</td>\n  <td>790001606</td>\n</tr>\n<tr>\n  <td>fr.rna</td>\n  <td>code WALDEC association</td>\n  <td>843S0843004860</td>\n</tr>\n<tr>\n  <td>fr.spi</td>\n  <td>code SPI num\u00e9ro fiscal</td>\n  <td>1899582886173</td>\n</tr>\n<tr>\n  <td>fr.nir</td>\n  <td>code NIR s\u00e9curit\u00e9 sociale</td>\n  <td>164026005705953</td>\n</tr>\n</tbody>\n</table>\n\n<h2 id=\"22-namespaces\">2.2 Namespaces</h2>\n\n<p>Namespaces could correspond to catalogs or data sets whose data types are identified\nin data models or in referenced data schemas.</p>\n\n<p>For example :</p>\n\n<table>\n<thead>\n<tr>\n  <th>type</th>\n  <th>example JSON-NTV</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td>fr.sandre.</td>\n  <td><div>{ \":fr.sandre.CdStationHydro\": K163 3010 01 }</div><div>{ \":fr.sandre.TypStationHydro\": \"standard\" }</div></td>\n</tr>\n<tr>\n  <td>fr.synop.</td>\n  <td><div>{ \":fr.synop.numer_sta\": 07130 }</div><div>{  \":fr.synop.t\": 300, \":fr.synop.ff\": 5 }</div></td>\n</tr>\n<tr>\n  <td>fr.IRVE.</td>\n  <td><div>{ \":fr.IRVE.nom_station\": \"M2026\" }</div><div>{ \":fr.IRVE.nom_operateur\": \"DEBELEC\" }</div></td>\n</tr>\n<tr>\n  <td>fr.BAN.</td>\n  <td><div>{ \":fr.BAN.numero\": 54 }</div><div>{ \":fr.BAN.lon\": 3.5124 }</div></td>\n</tr>\n</tbody>\n</table>\n\n<h2 id=\"23-entities\">2.3 Entities</h2>\n\n<p>They could correspond to assemblies of data associated with a defined structure.</p>\n\n<p>For example :</p>\n\n<table>\n<thead>\n<tr>\n  <th>type</th>\n  <th>example JSON-NTV</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td>fr.parcelle</td>\n  <td><div>{\u201cmaParcelle:fr.parcelle\u201d: [ 84500, 0, I, 97]}</div><div><i>(fr.cp, fr.cadastre.pr\u00e9fixe, fr.cadastre.section, fr.cadastre.num\u00e9ro)</i></div></td>\n</tr>\n<tr>\n  <td>fr.adresse</td>\n  <td><div>{\u201cmonAdresse:fr.adresse\u201d: [ 54, bis, rue de la mairie, 78730 ]</div><div><i>(fr.BAN.numero, fr.BAN.rep, fr.BAN.nom_voie, fr.cp)</i></div></td>\n</tr>\n</tbody>\n</table>\n"}, {"fullname": "NTV.json_ntv.namespace.agreg_type", "modulename": "NTV.json_ntv.namespace", "qualname": "agreg_type", "kind": "function", "doc": "<p>aggregate str_typ and def_type to return an NtvType or a Namespace if not single</p>\n\n<p><em>Parameters</em></p>\n\n<pre><code>- **str_typ** : NtvType or String (long_name) - NtvType to aggregate\n- **def_typ** : NtvType or String (long_name) - default NtvType or Namespace\n- **single** : Boolean - Ntv entity concerned (True if NtvSingle)\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">str_typ</span>, </span><span class=\"param\"><span class=\"n\">def_type</span>, </span><span class=\"param\"><span class=\"n\">single</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "NTV.json_ntv.namespace.relative_type", "modulename": "NTV.json_ntv.namespace", "qualname": "relative_type", "kind": "function", "doc": "<p>return relative str_typ string from NtvType or Namespace str_def</p>\n\n<p><em>Parameters</em></p>\n\n<pre><code>- **str_def** : String - long_name of the Namespace or NtvType\n- **str_type** : String - long_name of Ntvtype to be relative\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">str_def</span>, </span><span class=\"param\"><span class=\"n\">str_typ</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "NTV.json_ntv.namespace.str_type", "modulename": "NTV.json_ntv.namespace", "qualname": "str_type", "kind": "function", "doc": "<p>create a NtvType or a Namespace from a string</p>\n\n<p><em>Parameters</em></p>\n\n<pre><code>- **long_name** : String - name of the Namespace or NtvType\n- **single** : Boolean - If True, default type is 'json', else None\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">long_name</span>, </span><span class=\"param\"><span class=\"n\">single</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "NTV.json_ntv.namespace.NtvType", "modulename": "NTV.json_ntv.namespace", "qualname": "NtvType", "kind": "class", "doc": "<p>type of NTV entities.</p>\n\n<p><em>Attributes :</em></p>\n\n<ul>\n<li><strong>name</strong> : String - name of the type</li>\n<li><strong>nspace</strong> : Namespace - namespace associated</li>\n<li><strong>custom</strong> : boolean - True if not referenced</li>\n</ul>\n\n<p>The methods defined in this class are :</p>\n\n<p><em>classmethods</em></p>\n\n<ul>\n<li><code>types</code></li>\n<li><code>add</code></li>\n</ul>\n\n<p><em>dynamic values (@property)</em></p>\n\n<ul>\n<li><code>gen_type</code></li>\n<li><code>long_name</code></li>\n</ul>\n\n<p><em>instance methods</em></p>\n\n<ul>\n<li><code>isin_namespace</code></li>\n</ul>\n"}, {"fullname": "NTV.json_ntv.namespace.NtvType.__init__", "modulename": "NTV.json_ntv.namespace", "qualname": "NtvType.__init__", "kind": "function", "doc": "<p>NtvType constructor.</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>name</strong> : string - name of the Type</li>\n<li><strong>nspace</strong> : Namespace (default None) - namespace associated</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">name</span>, </span><span class=\"param\"><span class=\"n\">nspace</span><span class=\"o\">=</span><span class=\"kc\">None</span></span>)</span>"}, {"fullname": "NTV.json_ntv.namespace.NtvType.types", "modulename": "NTV.json_ntv.namespace", "qualname": "NtvType.types", "kind": "function", "doc": "<p>return the list of NtvType created</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "NTV.json_ntv.namespace.NtvType.add", "modulename": "NTV.json_ntv.namespace", "qualname": "NtvType.add", "kind": "function", "doc": "<p>activate and return a valid NtvType defined by the long name</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">long_name</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "NTV.json_ntv.namespace.NtvType.gen_type", "modulename": "NTV.json_ntv.namespace", "qualname": "NtvType.gen_type", "kind": "variable", "doc": "<p>return the generic type of the NtvType</p>\n"}, {"fullname": "NTV.json_ntv.namespace.NtvType.long_name", "modulename": "NTV.json_ntv.namespace", "qualname": "NtvType.long_name", "kind": "variable", "doc": "<p>return a string with the absolute name</p>\n"}, {"fullname": "NTV.json_ntv.namespace.NtvType.isin_namespace", "modulename": "NTV.json_ntv.namespace", "qualname": "NtvType.isin_namespace", "kind": "function", "doc": "<p>return the number of level between self and nspace, -1 if None</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">long_name</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "NTV.json_ntv.namespace.Namespace", "modulename": "NTV.json_ntv.namespace", "qualname": "Namespace", "kind": "class", "doc": "<p>Namespace of NTV entities.</p>\n\n<p><em>Attributes :</em></p>\n\n<ul>\n<li><strong>name</strong> : String - name of the namespace</li>\n<li><strong>file</strong> : string - location of the file init</li>\n<li><strong>parent</strong> : Namespace - parent namespace</li>\n<li><strong>custom</strong> : boolean - True if not referenced</li>\n</ul>\n\n<p>The methods defined in this class are :</p>\n\n<p><em>classmethods</em></p>\n\n<ul>\n<li><code>namespaces</code></li>\n<li><code>add</code></li>\n</ul>\n\n<p><em>dynamic values (@property)</em></p>\n\n<ul>\n<li><code>long_name</code></li>\n<li><code>content</code></li>\n</ul>\n\n<p><em>instance methods</em></p>\n\n<ul>\n<li><code>is_child</code></li>\n<li><code>is_parent</code></li>\n</ul>\n"}, {"fullname": "NTV.json_ntv.namespace.Namespace.__init__", "modulename": "NTV.json_ntv.namespace", "qualname": "Namespace.__init__", "kind": "function", "doc": "<p>Namespace constructor.</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>name</strong> : String - name of the namespace</li>\n<li><strong>parent</strong> : Namespace - parent namespace</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">name</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>, </span><span class=\"param\"><span class=\"n\">parent</span><span class=\"o\">=</span><span class=\"kc\">None</span></span>)</span>"}, {"fullname": "NTV.json_ntv.namespace.Namespace.namespaces", "modulename": "NTV.json_ntv.namespace", "qualname": "Namespace.namespaces", "kind": "function", "doc": "<p>return the list of Namespace created</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "NTV.json_ntv.namespace.Namespace.add", "modulename": "NTV.json_ntv.namespace", "qualname": "Namespace.add", "kind": "function", "doc": "<p>activate and return a valid Namespace defined by the long name</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">long_name</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "NTV.json_ntv.namespace.Namespace.long_name", "modulename": "NTV.json_ntv.namespace", "qualname": "Namespace.long_name", "kind": "variable", "doc": "<p>return a string with the absolute name</p>\n"}, {"fullname": "NTV.json_ntv.namespace.Namespace.is_child", "modulename": "NTV.json_ntv.namespace", "qualname": "Namespace.is_child", "kind": "function", "doc": "<p>return the number of level between self and nspace, -1 if None</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">nspace</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "NTV.json_ntv.namespace.Namespace.is_parent", "modulename": "NTV.json_ntv.namespace", "qualname": "Namespace.is_parent", "kind": "function", "doc": "<p>return the number of level between self and nspace, -1 if None</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">nspace</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "NTV.json_ntv.namespace.NtvTypeError", "modulename": "NTV.json_ntv.namespace", "qualname": "NtvTypeError", "kind": "class", "doc": "<p>NtvType or Namespace Exception</p>\n", "bases": "builtins.Exception"}, {"fullname": "NTV.json_ntv.ntv", "modulename": "NTV.json_ntv.ntv", "kind": "module", "doc": "<p>Created on Feb 27 2023</p>\n\n<p>@author: Philippe@loco-labs.io</p>\n\n<p>The <code>ntv</code> module is part of the <code>NTV.json_ntv</code> package (<a href=\"https://github.com/loco-philippe/NTV/blob/main/documentation/JSON-NTV-standard.pdf\">specification document</a>).</p>\n\n<p>It contains the classes <code>NtvSingle</code>, <code>NtvList</code>, <code>Ntv</code>(abstract) for NTV entities.</p>\n\n<h1 id=\"1-json-ntv-structure\">1 - JSON-NTV structure</h1>\n\n<p>The NTV triplet (name, type, value) is represented using a JSON-NTV format inspired\nby the RFC <a href=\"https://github.com/glenkleidon/JSON-ND\">JSON-ND</a> project :</p>\n\n<ul>\n<li><strong><code>value</code></strong> (if name and type are not documented)</li>\n<li><strong><code>{ \"name\" : value }</code></strong> (if name is documented but not type)</li>\n<li><strong><code>{ \":type\" : value }</code></strong> for primitive entities and <strong><code>{ \"::type\" : value }</code></strong>\nfor structured entities (if type is documented but not name)</li>\n<li><strong><code>{ \"name:type\" : value }</code></strong> for primitive entities and <strong><code>{\n\"name::type\" : value }</code></strong> for structured entities (if type and name are documented).</li>\n</ul>\n\n<p>For an NTV-single, the value is the JSON-value of the entity.\nFor an NTV-list, value is a JSON-array (JSON-object) where JSON-elements (JSON-members)\nare the JSON-NTV formats of included NTV entities.</p>\n\n<p>This JSON-NTV format allows full compatibility with existing JSON structures:</p>\n\n<ul>\n<li>a JSON-number, JSON-string or JSON-boolean is the representation of an NTV-single entity,</li>\n<li>a JSON-object with a single member is the representation of an NTV-single entity</li>\n<li>a JSON-array or JSON-object is the representation of an NTV-list entity</li>\n</ul>\n\n<h1 id=\"2-examples-of-json-ntv-representations\">2 - Examples of JSON-NTV representations</h1>\n\n<ul>\n<li>NTV-single, simple format :\n<ul>\n<li><code>\"lyon\"</code></li>\n<li><code>52.5</code></li>\n</ul></li>\n<li>NTV-single, named format :\n<ul>\n<li><code>{ \"paris:point\" : [2.3522, 48.8566] }</code></li>\n<li><code>{ \":point\" : [4.8357, 45.7640] }</code></li>\n<li><code>{ \"city\" : \"paris\" }</code></li>\n</ul></li>\n<li>NTV-list, simple format (whithout names):\n<ul>\n<li><code>[ [2.3522, 48.8566], {\"lyon\" : [4.8357, 45.7640]} ]</code></li>\n<li><code>[ { \":point\" : [2.3522, 48.8566]}, {\":point\" : [4.8357, 45.7640]} ]</code></li>\n<li><code>[ 4, 45 ]</code></li>\n<li><code>[ \"paris\" ]</code></li>\n<li><code>[ ]</code></li>\n</ul></li>\n<li>NTV-list, named format (whithout names):\n<ul>\n<li><code>{ \"cities::point\" : [ [2.3522, 48.8566], [4.8357, 45.7640] ] }</code></li>\n<li><code>{ \"::point\" : [ [2.3522, 48.8566], {\"lyon\" : [4.8357, 45.7640]} ] }</code></li>\n<li><code>{ \"simple list\" : [ 4, 45.7 ] }</code></li>\n<li><code>{ \"generic date::dat\" : [ \"2022-01-28T18-23-54Z\", \"2022-01-28\", 1234.78 ] }</code></li>\n</ul></li>\n<li>NTV-list, simple format (with names):\n<ul>\n<li><code>{ \"nom\u201d: \"white\", \"prenom\": \"walter\", \"surnom\": \"heisenberg\" }</code></li>\n<li><code>{ \"paris:point\" : [2.3522, 48.8566] , \"lyon\" : \"france\" }</code></li>\n<li><code>{ \"paris\" : [2.3522, 48.8566], \"\" : [4.8357, 45.7640] }</code></li>\n<li><code>{ }</code></li>\n</ul></li>\n<li>NTV-list, named format (with names):\n<ul>\n<li><code>{ \"cities::point\": { \"paris\": [2.352, 48.856], \"lyon\": [4.835, 45.764]}}</code></li>\n<li><code>{ \"cities\" :     { \"paris:point\" : [2.3522, 48.8566] , \"lyon\" : \"france\"} }</code></li>\n<li><code>{ \"city\" : { \"paris\" : [2.3522, 48.8566] } }</code></li>\n</ul></li>\n</ul>\n"}, {"fullname": "NTV.json_ntv.ntv.Ntv", "modulename": "NTV.json_ntv.ntv", "qualname": "Ntv", "kind": "class", "doc": "<p>The Ntv class is an abstract class used by <code>NtvSingle</code>and <code>NtvList</code> classes.</p>\n\n<p><em>Attributes :</em></p>\n\n<ul>\n<li><strong>ntv_name</strong> :  String - name of the NTV entity</li>\n<li><strong>ntv_type</strong>:   NtvType - type of the entity</li>\n<li><strong>ntv_value</strong>:  value of the entity</li>\n</ul>\n\n<p><em>Internal attributes :</em></p>\n\n<ul>\n<li><strong>parent</strong>:     parent NtvList entity</li>\n<li><strong>is_json</strong>:    True if ntv_value is a json_value</li>\n</ul>\n\n<p><em>dynamic values (@property)</em></p>\n\n<ul>\n<li><code>address</code></li>\n<li><code>address_name</code></li>\n<li><code>json_array</code></li>\n<li><code>type_str</code></li>\n<li><code>code_ntv</code></li>\n<li><code>max_len</code></li>\n<li><code>name</code></li>\n<li><code>tree</code></li>\n<li><code>val</code></li>\n</ul>\n\n<p>The methods defined in this class are :</p>\n\n<p><em>Ntv constructor (staticmethod)</em></p>\n\n<ul>\n<li><code>fast</code></li>\n<li><code>obj</code></li>\n<li><code>from_obj</code></li>\n<li><code>from_att</code></li>\n</ul>\n\n<p><em>NTV conversion (instance methods)</em></p>\n\n<ul>\n<li><code>alike</code></li>\n<li><code>to_json_ntv</code></li>\n<li><code>to_obj_ntv</code></li>\n</ul>\n\n<p><em>export (instance methods)</em></p>\n\n<ul>\n<li><code>to_fast</code></li>\n<li><code>to_name</code></li>\n<li><code>to_obj</code></li>\n<li><code>to_repr</code></li>\n<li><code>to_mermaid</code></li>\n<li><code>to_tuple</code></li>\n</ul>\n\n<p><em>instance methods</em></p>\n\n<ul>\n<li><code>from_value</code></li>\n<li><code>json_name</code></li>\n<li><code>set_name</code></li>\n<li><code>set_type</code></li>\n<li><code>set_value</code></li>\n</ul>\n\n<p><em>utility methods</em></p>\n\n<ul>\n<li><code>from_obj_name</code> <em>(staticmethod)</em></li>\n<li><code>obj_ntv</code> <em>(staticmethod)</em></li>\n</ul>\n\n<p><em>abstract method</em></p>\n\n<ul>\n<li><code>_obj_sep</code></li>\n<li><code>obj_value</code></li>\n<li><code>json_array</code> <em>(property)</em></li>\n</ul>\n", "bases": "abc.ABC"}, {"fullname": "NTV.json_ntv.ntv.Ntv.__init__", "modulename": "NTV.json_ntv.ntv", "qualname": "Ntv.__init__", "kind": "function", "doc": "<p>Ntv constructor.</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>ntv_value</strong>: Json entity - value of the entity</li>\n<li><strong>ntv_name</strong> : String (default None) - name of the NTV entity</li>\n<li><strong>ntv_type</strong>: String or NtvType or Namespace (default None) - type of the entity</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">ntv_value</span>, </span><span class=\"param\"><span class=\"n\">ntv_name</span>, </span><span class=\"param\"><span class=\"n\">ntv_type</span></span>)</span>"}, {"fullname": "NTV.json_ntv.ntv.Ntv.fast", "modulename": "NTV.json_ntv.ntv", "qualname": "Ntv.fast", "kind": "function", "doc": "<p>return an Ntv entity from data without conversion.</p>\n\n<p><em>Parameters</em> : see <code>obj</code> method</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data</span>, </span><span class=\"param\"><span class=\"n\">no_typ</span><span class=\"o\">=</span><span class=\"kc\">False</span>, </span><span class=\"param\"><span class=\"n\">typ_auto</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "NTV.json_ntv.ntv.Ntv.obj", "modulename": "NTV.json_ntv.ntv", "qualname": "Ntv.obj", "kind": "function", "doc": "<p>return an Ntv entity from data.</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>Data</strong> can be :\n<ul>\n<li>a tuple with value, name, typ and cat (see <code>from_att</code> method)</li>\n<li>a value to decode (see <code>from_obj</code>method)</li>\n</ul></li>\n<li><strong>no_typ</strong> : boolean (default False) - if True, NtvList is with 'json' type</li>\n<li><strong>type_auto</strong>: boolean (default False) - if True, default type for NtvList\nis the ntv_type of the first Ntv in the ntv_value</li>\n<li><strong>fast</strong> : boolean (default False) - if True, Ntv entity is created without conversion</li>\n<li><strong>decode_str</strong>: boolean (default False) - if True, string are loaded in json data</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data</span>, </span><span class=\"param\"><span class=\"n\">no_typ</span><span class=\"o\">=</span><span class=\"kc\">False</span>, </span><span class=\"param\"><span class=\"n\">decode_str</span><span class=\"o\">=</span><span class=\"kc\">False</span>, </span><span class=\"param\"><span class=\"n\">typ_auto</span><span class=\"o\">=</span><span class=\"kc\">False</span>, </span><span class=\"param\"><span class=\"n\">fast</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "NTV.json_ntv.ntv.Ntv.from_att", "modulename": "NTV.json_ntv.ntv", "qualname": "Ntv.from_att", "kind": "function", "doc": "<p>return an Ntv entity.</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>value</strong>: Ntv entity or value to convert in an Ntv entity</li>\n<li><strong>name</strong> : string - name of the Ntv entity</li>\n<li><strong>typ</strong> : string or NtvType - type of the NTV entity</li>\n<li><strong>cat</strong>: string - NTV category ('single', 'list')</li>\n<li><strong>fast</strong> : boolean (default False) - if True, Ntv entity is created without conversion</li>\n<li><strong>decode_str</strong>: boolean (default False) - if True, string are loaded as json data</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">value</span>, </span><span class=\"param\"><span class=\"n\">name</span>, </span><span class=\"param\"><span class=\"n\">typ</span>, </span><span class=\"param\"><span class=\"n\">cat</span>, </span><span class=\"param\"><span class=\"n\">decode_str</span><span class=\"o\">=</span><span class=\"kc\">False</span>, </span><span class=\"param\"><span class=\"n\">fast</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "NTV.json_ntv.ntv.Ntv.from_obj", "modulename": "NTV.json_ntv.ntv", "qualname": "Ntv.from_obj", "kind": "function", "doc": "<p>return an Ntv entity from an object value.</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>value</strong>: Ntv value to convert in an Ntv entity</li>\n<li><strong>no_typ</strong> : boolean (default None) - if True, NtvList is with 'json' type</li>\n<li><strong>def_type</strong> : NtvType or Namespace (default None) - default type of the value</li>\n<li><strong>def_sep</strong>: ':', '::' or None (default None) - default separator of the value</li>\n<li><strong>decode_str</strong>: boolean (default False) - if True, string are loaded as json data</li>\n<li><strong>type_auto</strong>: boolean (default False) - if True, default type for NtvList\nis the ntv_type of the first Ntv in the ntv_value</li>\n<li><strong>fast</strong> : boolean (default False) - if True, Ntv entity is created without conversion</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">value</span>,</span><span class=\"param\">\t<span class=\"n\">def_type</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">def_sep</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">no_typ</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">decode_str</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">typ_auto</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">fast</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "NTV.json_ntv.ntv.Ntv.address", "modulename": "NTV.json_ntv.ntv", "qualname": "Ntv.address", "kind": "variable", "doc": "<p>return a list of parent row from root</p>\n"}, {"fullname": "NTV.json_ntv.ntv.Ntv.address_name", "modulename": "NTV.json_ntv.ntv", "qualname": "Ntv.address_name", "kind": "variable", "doc": "<p>return a string of address</p>\n"}, {"fullname": "NTV.json_ntv.ntv.Ntv.code_ntv", "modulename": "NTV.json_ntv.ntv", "qualname": "Ntv.code_ntv", "kind": "variable", "doc": "<p>return a string with the NTV code composed with 1 to 3 letters:</p>\n\n<ul>\n<li>'l' (NtvList), 's' (NtvSingle / json_value) or 'o' (NtvSingle / obj_value)</li>\n<li>'N' if ntv_name is present else none</li>\n<li>'T' if ntv_type is present else none</li>\n</ul>\n"}, {"fullname": "NTV.json_ntv.ntv.Ntv.max_len", "modulename": "NTV.json_ntv.ntv", "qualname": "Ntv.max_len", "kind": "variable", "doc": "<p>return the highest len of Ntv entity included</p>\n"}, {"fullname": "NTV.json_ntv.ntv.Ntv.name", "modulename": "NTV.json_ntv.ntv", "qualname": "Ntv.name", "kind": "variable", "doc": "<p>return the ntv_name of the entity</p>\n"}, {"fullname": "NTV.json_ntv.ntv.Ntv.type_str", "modulename": "NTV.json_ntv.ntv", "qualname": "Ntv.type_str", "kind": "variable", "doc": "<p>return a string with the value of the NtvType of the entity</p>\n"}, {"fullname": "NTV.json_ntv.ntv.Ntv.val", "modulename": "NTV.json_ntv.ntv", "qualname": "Ntv.val", "kind": "variable", "doc": "<p>return the ntv_value of the entity</p>\n"}, {"fullname": "NTV.json_ntv.ntv.Ntv.from_obj_name", "modulename": "NTV.json_ntv.ntv", "qualname": "Ntv.from_obj_name", "kind": "function", "doc": "<p>return a tuple with name, type and separator from string</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">string</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "NTV.json_ntv.ntv.Ntv.alike", "modulename": "NTV.json_ntv.ntv", "qualname": "Ntv.alike", "kind": "function", "doc": "<p>return a Ntv entity with same name and type.</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>ntv_value</strong>: list of ntv values</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">ntv_value</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "NTV.json_ntv.ntv.Ntv.from_value", "modulename": "NTV.json_ntv.ntv", "qualname": "Ntv.from_value", "kind": "function", "doc": "<p>return a Ntv entity from ntv_value</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "NTV.json_ntv.ntv.Ntv.json_name", "modulename": "NTV.json_ntv.ntv", "qualname": "Ntv.json_name", "kind": "function", "doc": "<p>return the JSON name of the NTV entity (json-ntv format)</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>def_typ</strong> : NtvType or Namespace (default None) - type of the parent entity</li>\n<li><strong>string</strong> : boolean (default False) - If True, return a string else a tuple</li>\n<li><strong>explicit</strong> : boolean (default False) - If True, type is always included</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">def_type</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">string</span><span class=\"o\">=</span><span class=\"kc\">False</span>, </span><span class=\"param\"><span class=\"n\">explicit</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "NTV.json_ntv.ntv.Ntv.set_name", "modulename": "NTV.json_ntv.ntv", "qualname": "Ntv.set_name", "kind": "function", "doc": "<p>set new names to the entity</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>name</strong>: list or string (default '') - New name values</li>\n<li><strong>nodes</strong>: string (default 'simple') - nodes to be changed\n'simple': current entity\n'leaves': NtvSingle entities\n'inner': NtvList entities\n'all': all entities</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">name</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>, </span><span class=\"param\"><span class=\"n\">nodes</span><span class=\"o\">=</span><span class=\"s1\">&#39;simple&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "NTV.json_ntv.ntv.Ntv.set_type", "modulename": "NTV.json_ntv.ntv", "qualname": "Ntv.set_type", "kind": "function", "doc": "<p>set a new type to the entity</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>typ</strong>: string, NtvType, Namespace (default None)</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">typ</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "NTV.json_ntv.ntv.Ntv.set_value", "modulename": "NTV.json_ntv.ntv", "qualname": "Ntv.set_value", "kind": "function", "doc": "<p>set new ntv_value of a single entity or of a list of entities included</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>value</strong>: list or single value</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">value</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "NTV.json_ntv.ntv.Ntv.to_mermaid", "modulename": "NTV.json_ntv.ntv", "qualname": "Ntv.to_mermaid", "kind": "function", "doc": "<p>return a mermaid flowchart.</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>title</strong>: String (default '') - title of the flowchart</li>\n<li><strong>disp</strong>: Boolean (default False) - if true, return a display else return\na mermaid text diagram</li>\n<li><strong>row</strong>: Boolean (default False) - if True, add the node row</li>\n<li><strong>leaves</strong>: Boolean (default False) - if True, add the leaf row</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">title</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>, </span><span class=\"param\"><span class=\"n\">disp</span><span class=\"o\">=</span><span class=\"kc\">False</span>, </span><span class=\"param\"><span class=\"n\">row</span><span class=\"o\">=</span><span class=\"kc\">False</span>, </span><span class=\"param\"><span class=\"n\">leaves</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "NTV.json_ntv.ntv.Ntv.to_repr", "modulename": "NTV.json_ntv.ntv", "qualname": "Ntv.to_repr", "kind": "function", "doc": "<p>return a simple json representation of the Ntv entity.</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>nam</strong>: Boolean(default True) - if true, the names are included</li>\n<li><strong>typ</strong>: Boolean(default True) - if true, the types are included</li>\n<li><strong>val</strong>: Boolean(default True) - if true, the values are included</li>\n<li><strong>maxi</strong>: Integer (default 10) - number of values to include for NtvList\nentities. If maxi &lt; 1 all the values are included.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">nam</span><span class=\"o\">=</span><span class=\"kc\">True</span>, </span><span class=\"param\"><span class=\"n\">typ</span><span class=\"o\">=</span><span class=\"kc\">True</span>, </span><span class=\"param\"><span class=\"n\">val</span><span class=\"o\">=</span><span class=\"kc\">True</span>, </span><span class=\"param\"><span class=\"n\">maxi</span><span class=\"o\">=</span><span class=\"mi\">10</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "NTV.json_ntv.ntv.Ntv.to_name", "modulename": "NTV.json_ntv.ntv", "qualname": "Ntv.to_name", "kind": "function", "doc": "<p>return the name of the NTV entity</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>default</strong>: string (default ''): returned value if name is not present</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">default</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "NTV.json_ntv.ntv.Ntv.to_fast", "modulename": "NTV.json_ntv.ntv", "qualname": "Ntv.to_fast", "kind": "function", "doc": "<p>return the JSON representation of the NTV entity (json-ntv format)\nwithout value conversion.</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>def_type</strong> : NtvType or Namespace (default None) - default type to apply\nto the NTV entity</li>\n<li><strong>encoded</strong> : boolean (default False) - choice for return format\n(string/bytes if True, dict/list/tuple else)</li>\n<li><strong>format</strong>  : string (default 'json')- choice for return format\n(json, cbor, obj)</li>\n<li><strong>simpleval</strong> : boolean (default False) - if True, only value (without\nname and type) is included</li>\n<li><strong>name</strong> : boolean (default true) - if False, name is not included</li>\n<li><strong>json_array</strong> : boolean (default false) - if True, Json-object is not used for NtvList</li>\n<li><strong>maxi</strong>: Integer (default -1) - number of values to include for NtvList\nentities. If maxi &lt; 1 all the values are included.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">def_type</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "NTV.json_ntv.ntv.Ntv.to_obj", "modulename": "NTV.json_ntv.ntv", "qualname": "Ntv.to_obj", "kind": "function", "doc": "<p>return the JSON representation of the NTV entity (json-ntv format).</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>def_type</strong> : NtvType or Namespace (default None) - default type to apply\nto the NTV entity</li>\n<li><strong>encoded</strong> : boolean (default False) - choice for return format\n(string/bytes if True, dict/list/tuple else)</li>\n<li><strong>format</strong>  : string (default 'json')- choice for return format\n(json, cbor, obj)</li>\n<li><strong>simpleval</strong> : boolean (default False) - if True, only value (without\nname and type) is included</li>\n<li><strong>name</strong> : boolean (default true) - if False, name is not included</li>\n<li><strong>json_array</strong> : boolean (default false) - if True, Json-object is not used for NtvList</li>\n<li><strong>fast</strong> : boolean (default False) - if True, json is created without conversion</li>\n<li><strong>maxi</strong>: Integer (default -1) - number of values to include for NtvList\nentities. If maxi &lt; 1 all the values are included.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">def_type</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "NTV.json_ntv.ntv.Ntv.obj_ntv", "modulename": "NTV.json_ntv.ntv", "qualname": "Ntv.obj_ntv", "kind": "function", "doc": "<p>return a json-ntv representation without using Ntv structure.</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>value</strong> : ntv-value of the json-ntv</li>\n<li><strong>name</strong> : string (default '') - ntv-name of the json-ntv</li>\n<li><strong>typ</strong> : string (default '') - ntv_type of the json-ntv</li>\n<li><strong>single</strong> : boolean (default False) - if True, value is a single object\nelse value is a set of objetcs.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">value</span>, </span><span class=\"param\"><span class=\"n\">name</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>, </span><span class=\"param\"><span class=\"n\">typ</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>, </span><span class=\"param\"><span class=\"n\">single</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "NTV.json_ntv.ntv.Ntv.to_json_ntv", "modulename": "NTV.json_ntv.ntv", "qualname": "Ntv.to_json_ntv", "kind": "function", "doc": "<p>create a copy where ntv-value is converted in json-value</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "NTV.json_ntv.ntv.Ntv.to_obj_ntv", "modulename": "NTV.json_ntv.ntv", "qualname": "Ntv.to_obj_ntv", "kind": "function", "doc": "<p>create a copy where ntv-value is converted in object-value</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>kwargs</strong> : parameters used in NtvConnector class (specific for each Connector)</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "NTV.json_ntv.ntv.Ntv.to_tuple", "modulename": "NTV.json_ntv.ntv", "qualname": "Ntv.to_tuple", "kind": "function", "doc": "<p>return a nested tuple representation of the NTV entity\n(NtvList/NtvSingle, ntv_name, ntv_type, ntv_value).</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>maxi</strong>: Integer (default 10) - number of values to include for NtvList\nentities. If maxi &lt; 1 all the values are included.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">maxi</span><span class=\"o\">=</span><span class=\"mi\">10</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "NTV.json_ntv.ntv.Ntv.tree", "modulename": "NTV.json_ntv.ntv", "qualname": "Ntv.tree", "kind": "variable", "doc": "<p>return a tree with included entities (NtvTree object)</p>\n"}, {"fullname": "NTV.json_ntv.ntv.Ntv.obj_value", "modulename": "NTV.json_ntv.ntv", "qualname": "Ntv.obj_value", "kind": "function", "doc": "<p>return the ntv_value with different formats defined by kwargs (abstract method)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "NTV.json_ntv.ntv.Ntv.json_array", "modulename": "NTV.json_ntv.ntv", "qualname": "Ntv.json_array", "kind": "variable", "doc": "<p>return the json_array dynamic attribute (abstract method)</p>\n"}, {"fullname": "NTV.json_ntv.ntv.NtvSingle", "modulename": "NTV.json_ntv.ntv", "qualname": "NtvSingle", "kind": "class", "doc": "<p>A NTV-single entity is a Ntv entity not composed with other entities.</p>\n\n<p><em>Attributes :</em></p>\n\n<ul>\n<li>no additional attributes to those of parent class <code>Ntv</code></li>\n</ul>\n\n<p><em>dynamic values (@property)</em></p>\n\n<ul>\n<li><code>json_array</code></li>\n</ul>\n\n<p>The additional methods defined in this class are :</p>\n\n<p><em>instance methods</em></p>\n\n<ul>\n<li><code>obj_value</code></li>\n</ul>\n", "bases": "Ntv"}, {"fullname": "NTV.json_ntv.ntv.NtvSingle.__init__", "modulename": "NTV.json_ntv.ntv", "qualname": "NtvSingle.__init__", "kind": "function", "doc": "<p>NtvSingle constructor.</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>ntv_name</strong> : String (default None) - name of the NTV entity</li>\n<li><strong>ntv_type</strong>: String (default None) - type of the entity</li>\n<li><strong>value</strong>: value of the entity</li>\n<li><strong>fast</strong>: boolean (default False) - Ntv is created with a list of json values\nwithout control</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">value</span>, </span><span class=\"param\"><span class=\"n\">ntv_name</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">ntv_type</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">fast</span><span class=\"o\">=</span><span class=\"kc\">False</span></span>)</span>"}, {"fullname": "NTV.json_ntv.ntv.NtvSingle.json_array", "modulename": "NTV.json_ntv.ntv", "qualname": "NtvSingle.json_array", "kind": "variable", "doc": "<p>return the json_array dynamic attribute (always False)</p>\n"}, {"fullname": "NTV.json_ntv.ntv.NtvSingle.obj_value", "modulename": "NTV.json_ntv.ntv", "qualname": "NtvSingle.obj_value", "kind": "function", "doc": "<p>return the ntv_value with different formats defined by kwargs</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">def_type</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "NTV.json_ntv.ntv.NtvList", "modulename": "NTV.json_ntv.ntv", "qualname": "NtvList", "kind": "class", "doc": "<p>A NTV-list entity is a Ntv entity where:</p>\n\n<ul>\n<li>ntv_value is a list of NTV entities,</li>\n<li>ntv_type is a default type available for included NTV entities</li>\n</ul>\n\n<p><em>Attributes :</em></p>\n\n<ul>\n<li>no additional attributes to those of parent class <code>Ntv</code></li>\n</ul>\n\n<p><em>dynamic values (@property)</em></p>\n\n<ul>\n<li><code>json_array</code></li>\n</ul>\n\n<p>The additional methods defined in this class are :</p>\n\n<p><em>instance methods</em></p>\n\n<ul>\n<li><code>obj_value</code></li>\n</ul>\n", "bases": "Ntv"}, {"fullname": "NTV.json_ntv.ntv.NtvList.__init__", "modulename": "NTV.json_ntv.ntv", "qualname": "NtvList.__init__", "kind": "function", "doc": "<p>NtvList constructor.</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>ntv_name</strong> : String (default None) - name of the NTV entity</li>\n<li><strong>ntv_type</strong>: String (default None) - default type or namespace of\nthe included entities</li>\n<li><strong>list_ntv</strong>: list - list of Ntv objects or obj_value of Ntv objects</li>\n<li><strong>fast</strong>: boolean (default False) - if True, Ntv is created with a list\nof json values without control</li>\n<li><strong>type_auto</strong>: boolean (default False) - if True, default type for NtvList\nis the ntv_type of the first Ntv in the ntv_value</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">list_ntv</span>, </span><span class=\"param\"><span class=\"n\">ntv_name</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">ntv_type</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">typ_auto</span><span class=\"o\">=</span><span class=\"kc\">False</span>, </span><span class=\"param\"><span class=\"n\">fast</span><span class=\"o\">=</span><span class=\"kc\">False</span></span>)</span>"}, {"fullname": "NTV.json_ntv.ntv.NtvList.json_array", "modulename": "NTV.json_ntv.ntv", "qualname": "NtvList.json_array", "kind": "variable", "doc": "<p>return the json_array dynamic attribute</p>\n"}, {"fullname": "NTV.json_ntv.ntv.NtvList.obj_value", "modulename": "NTV.json_ntv.ntv", "qualname": "NtvList.obj_value", "kind": "function", "doc": "<p>return the ntv_value with different formats defined by kwargs</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">def_type</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "NTV.json_ntv.ntv_connector", "modulename": "NTV.json_ntv.ntv_connector", "kind": "module", "doc": "<p>Created on Feb 27 2023</p>\n\n<p>@author: Philippe@loco-labs.io</p>\n\n<p>The <code>NTV.ntv_connector</code> module is part of the <code>NTV.json_ntv</code> package (<a href=\"https://github.com/loco-philippe/NTV/blob/main/documentation/JSON-NTV-standard.pdf\">specification document</a>).</p>\n\n<p>It contains :</p>\n\n<ul>\n<li>methods <code>from_csv</code> and <code>to_csv</code> to convert CSV files and 'tab' NTV entity</li>\n<li>the child classes of <code>NTV.json_ntv.ntv.NtvConnector</code> abstract class:\n<ul>\n<li><code>IindexConnec</code>:    'field' connector</li>\n<li><code>IlistConnec</code>:     'tab' connector</li>\n<li><code>SfieldConnec</code>:    'field' connector</li>\n<li><code>SdatasetConnec</code>:  'tab' connector</li>\n<li><code>NfieldConnec</code>:    'field' connector</li>\n<li><code>NdatasetConnec</code>:  'tab' connector</li>\n<li><code>DataFrameConnec</code>: 'tab' connector</li>\n<li><code>SeriesConnec</code>:    'field' connector</li>\n<li><code>MermaidConnec</code>:   '$mermaid' connector</li>\n<li><code>ShapelyConnec</code>:   'geometry' connector</li>\n<li><code>CborConnec</code>:      '$cbor' connector</li>\n</ul></li>\n</ul>\n"}, {"fullname": "NTV.json_ntv.ntv_connector.from_csv", "modulename": "NTV.json_ntv.ntv_connector", "qualname": "from_csv", "kind": "function", "doc": "<p>return a 'tab' NtvSingle from a csv file</p>\n\n<p><em>parameters</em></p>\n\n<ul>\n<li><strong>file_name</strong> : name of the csv file</li>\n<li><strong>single_tab</strong> : boolean (default True) - if True return a 'tab' NtvSingle,\nelse return a NtvSet.</li>\n<li><strong>dialect, fmtparams</strong> : parameters of csv.DictReader object</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">file_name</span>, </span><span class=\"param\"><span class=\"n\">single_tab</span><span class=\"o\">=</span><span class=\"kc\">True</span>, </span><span class=\"param\"><span class=\"n\">dialect</span><span class=\"o\">=</span><span class=\"s1\">&#39;excel&#39;</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">fmtparams</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "NTV.json_ntv.ntv_connector.to_csv", "modulename": "NTV.json_ntv.ntv_connector", "qualname": "to_csv", "kind": "function", "doc": "<p>convert a 'tab' NtvSingle into csv file and return the file name</p>\n\n<p><em>parameters</em></p>\n\n<ul>\n<li><strong>file_name</strong> : name of the csv file</li>\n<li><strong>ntv</strong> : 'tab' NtvSingle to convert</li>\n<li><strong>args, restval, extrasaction, dialect, kwds</strong> : parameters of csv.DictWriter object</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">file_name</span>,</span><span class=\"param\">\t<span class=\"n\">ntv</span>,</span><span class=\"param\">\t<span class=\"o\">*</span><span class=\"n\">args</span>,</span><span class=\"param\">\t<span class=\"n\">restval</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">extrasaction</span><span class=\"o\">=</span><span class=\"s1\">&#39;raise&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">dialect</span><span class=\"o\">=</span><span class=\"s1\">&#39;excel&#39;</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwds</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "NTV.json_ntv.ntv_connector.ShapelyConnec", "modulename": "NTV.json_ntv.ntv_connector", "qualname": "ShapelyConnec", "kind": "class", "doc": "<p>NTV connector for geographic location</p>\n", "bases": "json_ntv.ntv_util.NtvConnector"}, {"fullname": "NTV.json_ntv.ntv_connector.ShapelyConnec.to_obj_ntv", "modulename": "NTV.json_ntv.ntv_connector", "qualname": "ShapelyConnec.to_obj_ntv", "kind": "function", "doc": "<p>convert ntv_value into a shapely geometry object defined by 'type_geo'.</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>type_geo</strong> : type of geometry (point, multipoint, line, multiline',\npolygon, multipolygon)</li>\n<li><strong>ntv_value</strong> : array - coordinates</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">ntv_value</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "NTV.json_ntv.ntv_connector.ShapelyConnec.to_json_ntv", "modulename": "NTV.json_ntv.ntv_connector", "qualname": "ShapelyConnec.to_json_ntv", "kind": "function", "doc": "<p>convert NTV object (value, name, type) into NTV json (json-value, name, type).</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>typ</strong> : string (default None) - NTV type of geometry (point, multipoint,\nline, multiline', polygon, multipolygon),</li>\n<li><strong>name</strong> : string (default None) - name of the NTV object</li>\n<li><strong>value</strong> : shapely geometry</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">value</span>, </span><span class=\"param\"><span class=\"n\">name</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">typ</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "NTV.json_ntv.ntv_connector.CborConnec", "modulename": "NTV.json_ntv.ntv_connector", "qualname": "CborConnec", "kind": "class", "doc": "<p>NTV connector for binary data</p>\n", "bases": "json_ntv.ntv_util.NtvConnector"}, {"fullname": "NTV.json_ntv.ntv_connector.CborConnec.to_obj_ntv", "modulename": "NTV.json_ntv.ntv_connector", "qualname": "CborConnec.to_obj_ntv", "kind": "function", "doc": "<p>convert json ntv_value into a binary CBOR object (no parameters).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">ntv_value</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "NTV.json_ntv.ntv_connector.CborConnec.to_json_ntv", "modulename": "NTV.json_ntv.ntv_connector", "qualname": "CborConnec.to_json_ntv", "kind": "function", "doc": "<p>convert NTV binary object (value, name, type) into NTV json (json-value, name, type).</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>typ</strong> : string (default None) - type of the NTV object,</li>\n<li><strong>name</strong> : string (default None) - name of the NTV object</li>\n<li><strong>value</strong> : binary data</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">value</span>, </span><span class=\"param\"><span class=\"n\">name</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">typ</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "NTV.json_ntv.ntv_connector.NfieldConnec", "modulename": "NTV.json_ntv.ntv_connector", "qualname": "NfieldConnec", "kind": "class", "doc": "<p>NTV connector for NTV Field data</p>\n", "bases": "json_ntv.ntv_util.NtvConnector"}, {"fullname": "NTV.json_ntv.ntv_connector.NfieldConnec.to_obj_ntv", "modulename": "NTV.json_ntv.ntv_connector", "qualname": "NfieldConnec.to_obj_ntv", "kind": "function", "doc": "<p>convert json ntv_value into a NTV Field object (no parameters).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">ntv_value</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "NTV.json_ntv.ntv_connector.NfieldConnec.to_json_ntv", "modulename": "NTV.json_ntv.ntv_connector", "qualname": "NfieldConnec.to_json_ntv", "kind": "function", "doc": "<p>convert NTV Field object (value, name, type) into NTV json (json-value, name, type).</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>typ</strong> : string (default None) - type of the NTV object,</li>\n<li><strong>name</strong> : string (default None) - name of the NTV object</li>\n<li><strong>value</strong> : NTV Field values (default format)</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">value</span>, </span><span class=\"param\"><span class=\"n\">name</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">typ</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "NTV.json_ntv.ntv_connector.SfieldConnec", "modulename": "NTV.json_ntv.ntv_connector", "qualname": "SfieldConnec", "kind": "class", "doc": "<p>NTV connector for simple Field data</p>\n", "bases": "json_ntv.ntv_util.NtvConnector"}, {"fullname": "NTV.json_ntv.ntv_connector.SfieldConnec.to_obj_ntv", "modulename": "NTV.json_ntv.ntv_connector", "qualname": "SfieldConnec.to_obj_ntv", "kind": "function", "doc": "<p>convert json ntv_value into a simple Field object (no parameters).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">ntv_value</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "NTV.json_ntv.ntv_connector.SfieldConnec.to_json_ntv", "modulename": "NTV.json_ntv.ntv_connector", "qualname": "SfieldConnec.to_json_ntv", "kind": "function", "doc": "<p>convert simple Field object (value, name, type) into NTV json (json-value, name, type).</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>typ</strong> : string (default None) - type of the NTV object,</li>\n<li><strong>name</strong> : string (default None) - name of the NTV object</li>\n<li><strong>value</strong> : simple Field values (default format)</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">value</span>, </span><span class=\"param\"><span class=\"n\">name</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">typ</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "NTV.json_ntv.ntv_connector.NdatasetConnec", "modulename": "NTV.json_ntv.ntv_connector", "qualname": "NdatasetConnec", "kind": "class", "doc": "<p>NTV connector for NTV Dataset data</p>\n", "bases": "json_ntv.ntv_util.NtvConnector"}, {"fullname": "NTV.json_ntv.ntv_connector.NdatasetConnec.to_obj_ntv", "modulename": "NTV.json_ntv.ntv_connector", "qualname": "NdatasetConnec.to_obj_ntv", "kind": "function", "doc": "<p>convert json ntv_value into a NTV Dataset object (no parameters).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">ntv_value</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "NTV.json_ntv.ntv_connector.NdatasetConnec.to_json_ntv", "modulename": "NTV.json_ntv.ntv_connector", "qualname": "NdatasetConnec.to_json_ntv", "kind": "function", "doc": "<p>convert NTV Dataset object (value, name, type) into NTV json (json-value, name, type).</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>typ</strong> : string (default None) - type of the NTV object,</li>\n<li><strong>name</strong> : string (default None) - name of the NTV object</li>\n<li><strong>value</strong> : NTV Dataset values</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">value</span>, </span><span class=\"param\"><span class=\"n\">name</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">typ</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "NTV.json_ntv.ntv_connector.SdatasetConnec", "modulename": "NTV.json_ntv.ntv_connector", "qualname": "SdatasetConnec", "kind": "class", "doc": "<p>NTV connector for simple Dataset data</p>\n", "bases": "json_ntv.ntv_util.NtvConnector"}, {"fullname": "NTV.json_ntv.ntv_connector.SdatasetConnec.to_obj_ntv", "modulename": "NTV.json_ntv.ntv_connector", "qualname": "SdatasetConnec.to_obj_ntv", "kind": "function", "doc": "<p>convert json ntv_value into a simple Dataset object (no parameters).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">ntv_value</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "NTV.json_ntv.ntv_connector.SdatasetConnec.to_json_ntv", "modulename": "NTV.json_ntv.ntv_connector", "qualname": "SdatasetConnec.to_json_ntv", "kind": "function", "doc": "<p>convert simple Dataset object (value, name, type) into NTV json\n(json-value, name, type).</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>typ</strong> : string (default None) - type of the NTV object,</li>\n<li><strong>name</strong> : string (default None) - name of the NTV object</li>\n<li><strong>value</strong> : simple Dataset values</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">value</span>, </span><span class=\"param\"><span class=\"n\">name</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">typ</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "NTV.json_ntv.ntv_connector.IindexConnec", "modulename": "NTV.json_ntv.ntv_connector", "qualname": "IindexConnec", "kind": "class", "doc": "<p>NTV connector for Iindex</p>\n", "bases": "json_ntv.ntv_util.NtvConnector"}, {"fullname": "NTV.json_ntv.ntv_connector.IindexConnec.to_obj_ntv", "modulename": "NTV.json_ntv.ntv_connector", "qualname": "IindexConnec.to_obj_ntv", "kind": "function", "doc": "<p>convert ntv_value into the return object</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">ntv_value</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "NTV.json_ntv.ntv_connector.IindexConnec.to_json_ntv", "modulename": "NTV.json_ntv.ntv_connector", "qualname": "IindexConnec.to_json_ntv", "kind": "function", "doc": "<p>convert object into the NTV entity (json-value, name, type).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">value</span>, </span><span class=\"param\"><span class=\"n\">name</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">typ</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "NTV.json_ntv.ntv_connector.IlistConnec", "modulename": "NTV.json_ntv.ntv_connector", "qualname": "IlistConnec", "kind": "class", "doc": "<p>NTV connector for Ilist</p>\n", "bases": "json_ntv.ntv_util.NtvConnector"}, {"fullname": "NTV.json_ntv.ntv_connector.IlistConnec.to_obj_ntv", "modulename": "NTV.json_ntv.ntv_connector", "qualname": "IlistConnec.to_obj_ntv", "kind": "function", "doc": "<p>convert ntv_value into the return object</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">ntv_value</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "NTV.json_ntv.ntv_connector.IlistConnec.to_json_ntv", "modulename": "NTV.json_ntv.ntv_connector", "qualname": "IlistConnec.to_json_ntv", "kind": "function", "doc": "<p>convert object into the NTV entity (json-value, name, type).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">value</span>, </span><span class=\"param\"><span class=\"n\">name</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">typ</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "NTV.json_ntv.ntv_connector.DataFrameConnec", "modulename": "NTV.json_ntv.ntv_connector", "qualname": "DataFrameConnec", "kind": "class", "doc": "<p>NTV connector for pandas DataFrame</p>\n", "bases": "json_ntv.ntv_util.NtvConnector"}, {"fullname": "NTV.json_ntv.ntv_connector.DataFrameConnec.to_obj_ntv", "modulename": "NTV.json_ntv.ntv_connector", "qualname": "DataFrameConnec.to_obj_ntv", "kind": "function", "doc": "<p>convert json ntv_value into a DataFrame.</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>index</strong> : list (default None) - list of index values,</li>\n<li><strong>alias</strong> : boolean (default False) - if True dtype alias else default dtype</li>\n<li><strong>annotated</strong> : boolean (default False) - if True, NTV names are not included.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">ntv_value</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "NTV.json_ntv.ntv_connector.DataFrameConnec.to_json_ntv", "modulename": "NTV.json_ntv.ntv_connector", "qualname": "DataFrameConnec.to_json_ntv", "kind": "function", "doc": "<p>convert a DataFrame (value, name, type) into NTV json (json-value, name, type).</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>typ</strong> : string (default None) - type of the NTV object,</li>\n<li><strong>name</strong> : string (default None) - name of the NTV object</li>\n<li><strong>value</strong> : DataFrame values</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">value</span>, </span><span class=\"param\"><span class=\"n\">name</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">typ</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "NTV.json_ntv.ntv_connector.DataFrameConnec.to_listidx", "modulename": "NTV.json_ntv.ntv_connector", "qualname": "DataFrameConnec.to_listidx", "kind": "function", "doc": "<p>convert a DataFrame in categorical data (list of dict for each column\nwith keys : 'codec', 'name, 'keys' and length of the DataFrame)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">dtf</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "NTV.json_ntv.ntv_connector.SeriesConnec", "modulename": "NTV.json_ntv.ntv_connector", "qualname": "SeriesConnec", "kind": "class", "doc": "<p>NTV connector for pandas Series</p>\n", "bases": "json_ntv.ntv_util.NtvConnector"}, {"fullname": "NTV.json_ntv.ntv_connector.SeriesConnec.to_obj_ntv", "modulename": "NTV.json_ntv.ntv_connector", "qualname": "SeriesConnec.to_obj_ntv", "kind": "function", "doc": "<p>convert json ntv_value into a Series.</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>index</strong> : list (default None) - list of index values,</li>\n<li><strong>leng</strong> : integer (default None) - leng of the series</li>\n<li><strong>alias</strong> : boolean (default False) - if True dtype alias else default dtype</li>\n<li><strong>annotated</strong> : boolean (default False) - if True, NTV names are not included.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">ntv_value</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "NTV.json_ntv.ntv_connector.SeriesConnec.to_json_ntv", "modulename": "NTV.json_ntv.ntv_connector", "qualname": "SeriesConnec.to_json_ntv", "kind": "function", "doc": "<p>convert a Series (value, name, type) into NTV json (json-value, name, type).</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>typ</strong> : string (default None) - type of the NTV object,</li>\n<li><strong>name</strong> : string (default None) - name of the NTV object</li>\n<li><strong>value</strong> : DataFrame values</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">value</span>, </span><span class=\"param\"><span class=\"n\">name</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">typ</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "NTV.json_ntv.ntv_connector.SeriesConnec.to_idx", "modulename": "NTV.json_ntv.ntv_connector", "qualname": "SeriesConnec.to_idx", "kind": "function", "doc": "<p>convert a Series in categorical data</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">ser</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "NTV.json_ntv.ntv_connector.MermaidConnec", "modulename": "NTV.json_ntv.ntv_connector", "qualname": "MermaidConnec", "kind": "class", "doc": "<p>NTV connector for Mermaid diagram</p>\n", "bases": "json_ntv.ntv_util.NtvConnector"}, {"fullname": "NTV.json_ntv.ntv_connector.MermaidConnec.to_obj_ntv", "modulename": "NTV.json_ntv.ntv_connector", "qualname": "MermaidConnec.to_obj_ntv", "kind": "function", "doc": "<p>convert ntv_value into a mermaid flowchart</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>title</strong>: String (default '') - title of the flowchart</li>\n<li><strong>disp</strong>: Boolean (default False) - if true, return a display else return\na mermaid text diagram</li>\n<li><strong>row</strong>: Boolean (default False) - if True, add the node row</li>\n<li><strong>leaves</strong>: Boolean (default False) - if True, add the leaf row</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">ntv_value</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "NTV.json_ntv.ntv_connector.MermaidConnec.diagram", "modulename": "NTV.json_ntv.ntv_connector", "qualname": "MermaidConnec.diagram", "kind": "function", "doc": "<p>create a mermaid code from a mermaid json</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">json_diag</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "NTV.json_ntv.ntv_util", "modulename": "NTV.json_ntv.ntv_util", "kind": "module", "doc": "<p>Created on Feb 27 2023</p>\n\n<p>@author: Philippe@loco-labs.io</p>\n\n<p>The <code>ntv_util</code> module is part of the <code>NTV.json_ntv</code> package (<a href=\"https://github.com/loco-philippe/NTV/blob/main/documentation/JSON-NTV-standard.pdf\">specification document</a>).</p>\n\n<p>It contains the classes <code>NtvConnector</code>, <code>NtvTree</code>, <code>NtvJsonEncoder</code> and <code>NtvError</code>\nfor NTV entities.</p>\n"}, {"fullname": "NTV.json_ntv.ntv_util.NtvConnector", "modulename": "NTV.json_ntv.ntv_util", "qualname": "NtvConnector", "kind": "class", "doc": "<p>The NtvConnector class is an abstract class used by all NTV connectors\nfor conversion between NTV-JSON data and NTV-OBJ data.</p>\n\n<p><em>class method :</em></p>\n\n<ul>\n<li><code>connector</code></li>\n<li><code>dic_connec</code></li>\n<li><code>castable</code> (@property)</li>\n<li><code>dic_obj</code> (@property)</li>\n<li><code>dic_type</code> (@property)</li>\n</ul>\n\n<p><em>abstract method</em></p>\n\n<ul>\n<li><code>to_obj_ntv</code></li>\n<li><code>to_json_ntv</code></li>\n</ul>\n\n<p><em>static method</em></p>\n\n<ul>\n<li><code>cast</code></li>\n<li><code>uncast</code></li>\n<li><code>is_json_class</code></li>\n<li><code>is_json</code></li>\n</ul>\n", "bases": "abc.ABC"}, {"fullname": "NTV.json_ntv.ntv_util.NtvConnector.castable", "modulename": "NTV.json_ntv.ntv_util", "qualname": "NtvConnector.castable", "kind": "variable", "doc": "<p>return a list with class_name allowed for json-obj conversion</p>\n"}, {"fullname": "NTV.json_ntv.ntv_util.NtvConnector.dic_obj", "modulename": "NTV.json_ntv.ntv_util", "qualname": "NtvConnector.dic_obj", "kind": "variable", "doc": "<p>return a dict with the connectors: { type: class_connec_name }</p>\n"}, {"fullname": "NTV.json_ntv.ntv_util.NtvConnector.dic_type", "modulename": "NTV.json_ntv.ntv_util", "qualname": "NtvConnector.dic_type", "kind": "variable", "doc": "<p>return a dict with the connectors: { class_obj_name: type }</p>\n"}, {"fullname": "NTV.json_ntv.ntv_util.NtvConnector.connector", "modulename": "NTV.json_ntv.ntv_util", "qualname": "NtvConnector.connector", "kind": "function", "doc": "<p>return a dict with the connectors: { class_connec_name: class_connec }</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "NTV.json_ntv.ntv_util.NtvConnector.dic_connec", "modulename": "NTV.json_ntv.ntv_util", "qualname": "NtvConnector.dic_connec", "kind": "function", "doc": "<p>return a dict with the clas associated to the connector:\n{ class_obj_name: class_connec_name }</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "NTV.json_ntv.ntv_util.NtvConnector.to_obj_ntv", "modulename": "NTV.json_ntv.ntv_util", "qualname": "NtvConnector.to_obj_ntv", "kind": "function", "doc": "<p>abstract - convert ntv_value into the return object</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">ntv_value</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "NTV.json_ntv.ntv_util.NtvConnector.to_json_ntv", "modulename": "NTV.json_ntv.ntv_util", "qualname": "NtvConnector.to_json_ntv", "kind": "function", "doc": "<p>abstract - convert NTV object (value, name, type) into the NTV json\n(json-value, name, type)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">value</span>, </span><span class=\"param\"><span class=\"n\">name</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">typ</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "NTV.json_ntv.ntv_util.NtvConnector.cast", "modulename": "NTV.json_ntv.ntv_util", "qualname": "NtvConnector.cast", "kind": "function", "doc": "<p>return JSON-NTV conversion (json_value, name, type_str) of the NTV entity\ndefined in parameters.</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>data</strong>: NtvSingle entity or NTVvalue of the NTV entity</li>\n<li><strong>name</strong> : String (default None) - name of the NTV entity</li>\n<li><strong>type_str</strong>: String (default None) - type of the NTV entity</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data</span>, </span><span class=\"param\"><span class=\"n\">name</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">type_str</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "NTV.json_ntv.ntv_util.NtvConnector.uncast", "modulename": "NTV.json_ntv.ntv_util", "qualname": "NtvConnector.uncast", "kind": "function", "doc": "<p>return OBJ-NTV conversion (obj_value, name, type_str) of a NTV entity</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>data</strong>: NtvSingle entity or NTVvalue of the NTV entity</li>\n<li><strong>name</strong> : String (default None) - name of the NTV entity</li>\n<li><strong>type_str</strong>: String (default None) - type of the NTV entity</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">value</span>, </span><span class=\"param\"><span class=\"n\">name</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">type_str</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "NTV.json_ntv.ntv_util.NtvConnector.is_json_class", "modulename": "NTV.json_ntv.ntv_util", "qualname": "NtvConnector.is_json_class", "kind": "function", "doc": "<p>return True if val is a json type</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">val</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "NTV.json_ntv.ntv_util.NtvConnector.is_json", "modulename": "NTV.json_ntv.ntv_util", "qualname": "NtvConnector.is_json", "kind": "function", "doc": "<p>check if obj is a json structure and return True if obj is a json-value</p>\n\n<p><em>Parameters</em></p>\n\n<ul>\n<li><strong>obj</strong> : object to check</li>\n<li><strong>ntvobj</strong> : boolean (default False) - if True NTV class value are accepted</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">obj</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "NTV.json_ntv.ntv_util.NtvTree", "modulename": "NTV.json_ntv.ntv_util", "qualname": "NtvTree", "kind": "class", "doc": "<p>The NtvTree class is an iterator class used to traverse a NTV tree structure.\nSome other methods give tree indicators and data.</p>\n\n<p><em>Attributes :</em></p>\n\n<ul>\n<li><strong>ntv</strong> : Ntv entity</li>\n<li><strong>_node</strong>:  Ntv entity - node pointer</li>\n</ul>\n\n<p><em>dynamic values (@property)</em></p>\n\n<ul>\n<li><code>breadth</code></li>\n<li><code>size</code></li>\n<li><code>height</code></li>\n<li><code>adjacency_list</code></li>\n<li><code>nodes</code></li>\n<li><code>leaf_nodes</code></li>\n<li><code>inner_nodes</code></li>\n</ul>\n"}, {"fullname": "NTV.json_ntv.ntv_util.NtvTree.__init__", "modulename": "NTV.json_ntv.ntv_util", "qualname": "NtvTree.__init__", "kind": "function", "doc": "<p>the parameter of the constructor is the Ntv entity</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">ntv</span></span>)</span>"}, {"fullname": "NTV.json_ntv.ntv_util.NtvTree.breadth", "modulename": "NTV.json_ntv.ntv_util", "qualname": "NtvTree.breadth", "kind": "variable", "doc": "<p>return the number of leaves</p>\n"}, {"fullname": "NTV.json_ntv.ntv_util.NtvTree.size", "modulename": "NTV.json_ntv.ntv_util", "qualname": "NtvTree.size", "kind": "variable", "doc": "<p>return the number of nodes</p>\n"}, {"fullname": "NTV.json_ntv.ntv_util.NtvTree.height", "modulename": "NTV.json_ntv.ntv_util", "qualname": "NtvTree.height", "kind": "variable", "doc": "<p>return the height of the tree</p>\n"}, {"fullname": "NTV.json_ntv.ntv_util.NtvTree.adjacency_list", "modulename": "NTV.json_ntv.ntv_util", "qualname": "NtvTree.adjacency_list", "kind": "variable", "doc": "<p>return a dict with the list of child nodes for each parent node</p>\n"}, {"fullname": "NTV.json_ntv.ntv_util.NtvTree.nodes", "modulename": "NTV.json_ntv.ntv_util", "qualname": "NtvTree.nodes", "kind": "variable", "doc": "<p>return the list of nodes</p>\n"}, {"fullname": "NTV.json_ntv.ntv_util.NtvTree.leaf_nodes", "modulename": "NTV.json_ntv.ntv_util", "qualname": "NtvTree.leaf_nodes", "kind": "variable", "doc": "<p>return the list of leaf nodes</p>\n"}, {"fullname": "NTV.json_ntv.ntv_util.NtvTree.inner_nodes", "modulename": "NTV.json_ntv.ntv_util", "qualname": "NtvTree.inner_nodes", "kind": "variable", "doc": "<p>return the list of inner nodes</p>\n"}, {"fullname": "NTV.json_ntv.ntv_util.NtvJsonEncoder", "modulename": "NTV.json_ntv.ntv_util", "qualname": "NtvJsonEncoder", "kind": "class", "doc": "<p>json encoder for Ntv data</p>\n", "bases": "json.encoder.JSONEncoder"}, {"fullname": "NTV.json_ntv.ntv_util.NtvJsonEncoder.default", "modulename": "NTV.json_ntv.ntv_util", "qualname": "NtvJsonEncoder.default", "kind": "function", "doc": "<p>Implement this method in a subclass such that it returns\na serializable object for <code>o</code>, or calls the base implementation\n(to raise a <code>TypeError</code>).</p>\n\n<p>For example, to support arbitrary iterators, you could\nimplement default like this::</p>\n\n<pre><code>def default(self, o):\n    try:\n        iterable = iter(o)\n    except TypeError:\n        pass\n    else:\n        return list(iterable)\n    # Let the base class default method raise the TypeError\n    return JSONEncoder.default(self, o)\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">o</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "NTV.json_ntv.ntv_util.NtvError", "modulename": "NTV.json_ntv.ntv_util", "qualname": "NtvError", "kind": "class", "doc": "<p>NTV Exception</p>\n", "bases": "builtins.Exception"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();